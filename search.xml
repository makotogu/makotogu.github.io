<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java的线程</title>
    <url>/2025/06/10/Java-ClassLoader/Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
    <content><![CDATA[<h1 id="什么是类加载器"><a href="#什么是类加载器" class="headerlink" title="什么是类加载器"></a>什么是类加载器</h1><h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2>]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>类加载器</tag>
        <tag>底层</tag>
      </tags>
  </entry>
  <entry>
    <title>个人技术地图 &amp; 学习记录</title>
    <url>/2025/05/23/%E4%B8%AA%E4%BA%BA%E6%8A%80%E6%9C%AF%E5%9C%B0%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="个人技术地图-学习记录"><a href="#个人技术地图-学习记录" class="headerlink" title="个人技术地图 &amp; 学习记录"></a>个人技术地图 &amp; 学习记录</h1><h2 id="📝-使用说明"><a href="#📝-使用说明" class="headerlink" title="📝 使用说明"></a>📝 使用说明</h2><p>个人技术学习记录，用于跟踪技术掌握情况、学习进度和写作规划。定期更新，记录成长轨迹。</p>
<h3 id="掌握程度标记"><a href="#掌握程度标记" class="headerlink" title="掌握程度标记"></a>掌握程度标记</h3><ul>
<li>🔴 <strong>未接触</strong> - 计划学习</li>
<li>🟡 <strong>了解</strong> - 基本概念，简单使用</li>
<li>🟠 <strong>熟悉</strong> - 掌握核心概念，能独立开发</li>
<li>🟢 <strong>熟练</strong> - 理解原理，能解决问题</li>
<li>🔵 <strong>深入</strong> - 具备深度理解，能指导他人</li>
</ul>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><ul>
<li><strong>掌握程度</strong>: 可以用 🔴🟡🟠🟢🔵 或其他方式标记</li>
<li><strong>项目经验</strong>: 记录实际使用时长或项目数量</li>
<li><strong>博客状态</strong>: ✅ 已发布 🚧 进行中 📅 已规划 💡 待规划</li>
<li><strong>是否想深入</strong>: ✅ 想深入 ❌ 不深入</li>
</ul>
<span id="more"></span>

<h2 id="🎯-当前学习重点"><a href="#🎯-当前学习重点" class="headerlink" title="🎯 当前学习重点"></a>🎯 当前学习重点</h2><ul>
<li><strong>Java 并发编程</strong> - 系统性学习，已完成基础篇</li>
<li><strong>Spring Boot 深入</strong> - 源码理解和实践应用</li>
<li><strong>分布式系统基础</strong> - 理论学习和实践经验积累</li>
</ul>
<h2 id="☕-Java-基础"><a href="#☕-Java-基础" class="headerlink" title="☕ Java 基础"></a>☕ Java 基础</h2><table>
<thead>
<tr>
<th>技术点</th>
<th>掌握程度</th>
<th>项目经验</th>
<th>博客状态</th>
<th>是否想深入</th>
</tr>
</thead>
<tbody><tr>
<td>Java 集合框架（List&#x2F;Set&#x2F;Map）</td>
<td>🟢 <strong>熟练</strong></td>
<td>3 年+</td>
<td></td>
<td></td>
</tr>
<tr>
<td>多线程 &amp; 并发编程</td>
<td>🟢 <strong>熟练</strong></td>
<td>2 年</td>
<td></td>
<td></td>
</tr>
<tr>
<td>线程池</td>
<td>🟠 <strong>熟悉</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>AQS、CAS、volatile、synchronized</td>
<td>🟡 <strong>了解</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>JVM 内存模型</td>
<td>🟡 <strong>了解</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>类加载机制</td>
<td>🟡 <strong>了解</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>GC 算法 &amp; 垃圾回收器</td>
<td>🟡 <strong>了解</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>异常机制</td>
<td>🟡 <strong>了解</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>泛型 &amp; 注解 &amp; 反射</td>
<td>🟠 <strong>熟悉</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Lambda 表达式 &amp; Stream API</td>
<td>🟡 <strong>了解</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>NIO &amp; AIO</td>
<td>🟡 <strong>了解</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="🌐-Spring-生态"><a href="#🌐-Spring-生态" class="headerlink" title="🌐 Spring 生态"></a>🌐 Spring 生态</h2><table>
<thead>
<tr>
<th>技术点</th>
<th>掌握程度</th>
<th>项目经验</th>
<th>博客状态</th>
<th>是否想深入</th>
</tr>
</thead>
<tbody><tr>
<td>Spring Boot 基础使用</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Spring Core（IOC&#x2F;AOP）</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Spring MVC</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Spring Security</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Spring Data JPA</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Spring Cloud</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>MyBatis&#x2F;MyBatis Plus</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Spring Task 定时任务</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="🗄️-数据库技术"><a href="#🗄️-数据库技术" class="headerlink" title="🗄️ 数据库技术"></a>🗄️ 数据库技术</h2><h3 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h3><table>
<thead>
<tr>
<th>技术点</th>
<th>掌握程度</th>
<th>项目经验</th>
<th>博客状态</th>
<th>是否想深入</th>
</tr>
</thead>
<tbody><tr>
<td>MySQL 基础使用</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>MySQL 索引优化、执行计划分析</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>MySQL 分库分表思路</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>SQL 优化</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>事务机制（ACID、隔离级别）</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>MySQL 主从复制</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>数据库连接池（Druid、HikariCP）</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="NoSQL-数据库"><a href="#NoSQL-数据库" class="headerlink" title="NoSQL 数据库"></a>NoSQL 数据库</h3><table>
<thead>
<tr>
<th>技术点</th>
<th>掌握程度</th>
<th>项目经验</th>
<th>博客状态</th>
<th>是否想深入</th>
</tr>
</thead>
<tbody><tr>
<td>Redis 基本数据类型（String&#x2F;Hash&#x2F;List）</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Redis 持久化机制（RDB&#x2F;AOF）</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Redis 高可用方案（哨兵、集群）</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Redis 缓存策略（缓存穿透、雪崩、击穿）</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>MongoDB</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Elasticsearch 基本使用</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ES 索引管理与性能优化</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="🔧-中间件"><a href="#🔧-中间件" class="headerlink" title="🔧 中间件"></a>🔧 中间件</h2><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><table>
<thead>
<tr>
<th>技术点</th>
<th>掌握程度</th>
<th>项目经验</th>
<th>博客状态</th>
<th>是否想深入</th>
</tr>
</thead>
<tbody><tr>
<td>Kafka 基本使用</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>生产者消费者、分区、重平衡</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>RocketMQ</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>RabbitMQ</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>消息可靠性保证</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>消息幂等性处理</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="调度程序"><a href="#调度程序" class="headerlink" title="调度程序"></a>调度程序</h3><table>
<thead>
<tr>
<th>技术点</th>
<th>掌握程度</th>
<th>项目经验</th>
<th>博客状态</th>
<th>是否想深入</th>
</tr>
</thead>
<tbody><tr>
<td>Quartz 定时任务</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>XXL-Job 分布式调度</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Elastic-Job</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>PowerJob</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>定时任务的高可用设计</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="网关和代理"><a href="#网关和代理" class="headerlink" title="网关和代理"></a>网关和代理</h3><table>
<thead>
<tr>
<th>技术点</th>
<th>掌握程度</th>
<th>项目经验</th>
<th>博客状态</th>
<th>是否想深入</th>
</tr>
</thead>
<tbody><tr>
<td>Nginx 基本配置</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Nginx 负载均衡 &amp; 反向代理</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Gateway 网关</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Zuul</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="📚-算法与数据结构"><a href="#📚-算法与数据结构" class="headerlink" title="📚 算法与数据结构"></a>📚 算法与数据结构</h2><table>
<thead>
<tr>
<th>技术点</th>
<th>掌握程度</th>
<th>项目经验</th>
<th>博客状态</th>
<th>是否想深入</th>
</tr>
</thead>
<tbody><tr>
<td>数组、链表、栈、队列</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>二叉树、二叉搜索树</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>哈希表、堆</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>排序算法（快排、归并等）</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>查找算法（二分查找等）</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>动态规划</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>贪心算法</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>图论算法（BFS、DFS）</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>字符串算法（KMP 等）</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>LeetCode 刷题</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="🌍-分布式系统"><a href="#🌍-分布式系统" class="headerlink" title="🌍 分布式系统"></a>🌍 分布式系统</h2><table>
<thead>
<tr>
<th>技术点</th>
<th>掌握程度</th>
<th>项目经验</th>
<th>博客状态</th>
<th>是否想深入</th>
</tr>
</thead>
<tbody><tr>
<td>CAP 理论</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>分布式锁（Redis、ZK）</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>分布式事务（TCC、Seata、Saga）</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>分布式 ID 生成方案（Snowflake、Redis）</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>注册中心（Nacos、Eureka、Zookeeper）</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>配置中心（Spring Cloud Config、Apollo、Nacos）</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>熔断限流（Sentinel、Hystrix）</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>微服务拆分与治理</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>分布式一致性（Raft、Paxos）</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>数据同步（Canal、DataX）</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="🎨-架构设计"><a href="#🎨-架构设计" class="headerlink" title="🎨 架构设计"></a>🎨 架构设计</h2><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><table>
<thead>
<tr>
<th>技术点</th>
<th>掌握程度</th>
<th>项目经验</th>
<th>博客状态</th>
<th>是否想深入</th>
</tr>
</thead>
<tbody><tr>
<td>单例、工厂、策略、模板方法等常用设计模式</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>观察者、装饰器、代理模式</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>建造者、适配器、门面模式</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="架构思想"><a href="#架构思想" class="headerlink" title="架构思想"></a>架构思想</h3><table>
<thead>
<tr>
<th>技术点</th>
<th>掌握程度</th>
<th>项目经验</th>
<th>博客状态</th>
<th>是否想深入</th>
</tr>
</thead>
<tbody><tr>
<td>MVC、MVVM、DDD 等架构思想</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>SOLID 原则</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>高内聚低耦合</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>系统可扩展性设计（开闭原则、接口抽象）</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="高并发设计"><a href="#高并发设计" class="headerlink" title="高并发设计"></a>高并发设计</h3><table>
<thead>
<tr>
<th>技术点</th>
<th>掌握程度</th>
<th>项目经验</th>
<th>博客状态</th>
<th>是否想深入</th>
</tr>
</thead>
<tbody><tr>
<td>高并发场景设计（缓存、异步、削峰）</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>读写分离、分库分表</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>负载均衡策略</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>缓存设计（多级缓存、缓存更新策略）</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="🔥-系统设计"><a href="#🔥-系统设计" class="headerlink" title="🔥 系统设计"></a>🔥 系统设计</h2><table>
<thead>
<tr>
<th>技术点</th>
<th>掌握程度</th>
<th>项目经验</th>
<th>博客状态</th>
<th>是否想深入</th>
</tr>
</thead>
<tbody><tr>
<td>秒杀系统设计</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>IM 即时通讯系统设计</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>短链接系统设计</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>电商系统架构设计</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>搜索引擎架构设计</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>分布式文件系统设计</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>推荐系统设计</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>支付系统设计</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="🔧-开发工具与环境"><a href="#🔧-开发工具与环境" class="headerlink" title="🔧 开发工具与环境"></a>🔧 开发工具与环境</h2><h3 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h3><table>
<thead>
<tr>
<th>技术点</th>
<th>掌握程度</th>
<th>项目经验</th>
<th>博客状态</th>
<th>是否想深入</th>
</tr>
</thead>
<tbody><tr>
<td>Maven 依赖管理</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Gradle</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><table>
<thead>
<tr>
<th>技术点</th>
<th>掌握程度</th>
<th>项目经验</th>
<th>博客状态</th>
<th>是否想深入</th>
</tr>
</thead>
<tbody><tr>
<td>Git 基本操作（clone、commit、branch、merge）</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>GitHub&#x2F;GitLab</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="🚀-DevOps-工程实践"><a href="#🚀-DevOps-工程实践" class="headerlink" title="🚀 DevOps 工程实践"></a>🚀 DevOps 工程实践</h2><table>
<thead>
<tr>
<th>技术点</th>
<th>掌握程度</th>
<th>项目经验</th>
<th>博客状态</th>
<th>是否想深入</th>
</tr>
</thead>
<tbody><tr>
<td>Docker 基础使用</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Docker 镜像构建与部署</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Kubernetes 基础</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Jenkins 流水线配置</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>CI&#x2F;CD 自动化部署流程</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="🖥️-运维与部署"><a href="#🖥️-运维与部署" class="headerlink" title="🖥️ 运维与部署"></a>🖥️ 运维与部署</h2><table>
<thead>
<tr>
<th>技术点</th>
<th>掌握程度</th>
<th>项目经验</th>
<th>博客状态</th>
<th>是否想深入</th>
</tr>
</thead>
<tbody><tr>
<td>Linux 基础命令（top、grep、tail、chmod、ps、netstat）</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Shell 脚本编写（变量、函数、条件判断）</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>服务优雅启动与关闭脚本</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>服务日志查看与问题定位</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="🔐-网络与安全"><a href="#🔐-网络与安全" class="headerlink" title="🔐 网络与安全"></a>🔐 网络与安全</h2><table>
<thead>
<tr>
<th>技术点</th>
<th>掌握程度</th>
<th>项目经验</th>
<th>博客状态</th>
<th>是否想深入</th>
</tr>
</thead>
<tbody><tr>
<td>HTTP 请求流程</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>HTTPS 原理</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Session &amp; Cookie 实现机制</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>JWT、OAuth2 鉴权机制</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>网关（Gateway）路由与鉴权实现</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>SQL 注入防护</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>XSS&#x2F;CSRF 攻击防护</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="📊-监控与日志"><a href="#📊-监控与日志" class="headerlink" title="📊 监控与日志"></a>📊 监控与日志</h2><table>
<thead>
<tr>
<th>技术点</th>
<th>掌握程度</th>
<th>项目经验</th>
<th>博客状态</th>
<th>是否想深入</th>
</tr>
</thead>
<tbody><tr>
<td>日志收集（Logback、ELK）</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>监控告警（Prometheus、Grafana）</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Logstash、Kibana 使用</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>SkyWalking 链路追踪</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Arthas Java 诊断工具</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="🧪-测试技术"><a href="#🧪-测试技术" class="headerlink" title="🧪 测试技术"></a>🧪 测试技术</h2><table>
<thead>
<tr>
<th>技术点</th>
<th>掌握程度</th>
<th>项目经验</th>
<th>博客状态</th>
<th>是否想深入</th>
</tr>
</thead>
<tbody><tr>
<td>JUnit 单元测试</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Mockito</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>集成测试</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>压力测试（JMeter）</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>接口测试（Postman）</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="💰-业务理解"><a href="#💰-业务理解" class="headerlink" title="💰 业务理解"></a>💰 业务理解</h2><table>
<thead>
<tr>
<th>技术点</th>
<th>掌握程度</th>
<th>项目经验</th>
<th>博客状态</th>
<th>是否想深入</th>
</tr>
</thead>
<tbody><tr>
<td>电商业务流程</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>金融支付业务</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>用户增长与留存</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>数据指标分析</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>产品需求理解</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="📊-大数据基础"><a href="#📊-大数据基础" class="headerlink" title="📊 大数据基础"></a>📊 大数据基础</h2><table>
<thead>
<tr>
<th>技术点</th>
<th>掌握程度</th>
<th>项目经验</th>
<th>博客状态</th>
<th>是否想深入</th>
</tr>
</thead>
<tbody><tr>
<td>Hive 基本语句（select、group by、join）</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>HDFS 文件系统基本使用</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ETL 流程理解</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Spark 基础</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Flink 流处理</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="💻-前端技术"><a href="#💻-前端技术" class="headerlink" title="💻 前端技术"></a>💻 前端技术</h2><table>
<thead>
<tr>
<th>技术点</th>
<th>掌握程度</th>
<th>项目经验</th>
<th>博客状态</th>
<th>是否想深入</th>
</tr>
</thead>
<tbody><tr>
<td>HTML&#x2F;CSS</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>JavaScript</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Vue.js</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>React</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>个人笔记</category>
      </categories>
      <tags>
        <tag>技术成长</tag>
        <tag>学习规划</tag>
        <tag>个人总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 内存模型(JMM)</title>
    <url>/2025/05/19/Java-Threads/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-JMM/</url>
    <content><![CDATA[<h1 id="Java-内存模型-JMM-Java-Memory-Model"><a href="#Java-内存模型-JMM-Java-Memory-Model" class="headerlink" title="Java 内存模型 (JMM - Java Memory Model)"></a>Java 内存模型 (JMM - Java Memory Model)</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在多年的 Java 开发实践中，我发现很多并发问题的根源都可以追溯到对 Java 内存模型的理解不足。无论是生产环境中偶现的数据不一致问题，还是性能优化中的锁竞争分析，JMM 都是绕不开的核心知识点。</p>
<p>本文将从<strong>理论基础</strong>到<strong>实际应用</strong>，系统梳理 JMM 的核心概念，并结合具体代码示例分析常见的并发问题及其解决方案。希望能够帮助读者：</p>
<ul>
<li>🎯 <strong>深入理解</strong> JMM 的抽象模型和底层实现</li>
<li>🔍 <strong>快速识别</strong> 并发编程中的可见性、原子性、有序性问题</li>
<li>🛠️ <strong>掌握最佳实践</strong> 选择合适的同步机制</li>
<li>📈 <strong>提升代码质量</strong> 编写线程安全且高性能的并发代码</li>
</ul>
<h2 id="为什么-JMM-如此重要？"><a href="#为什么-JMM-如此重要？" class="headerlink" title="为什么 JMM 如此重要？"></a>为什么 JMM 如此重要？</h2><blockquote>
<p><strong>实际案例</strong>：曾在生产环境中遇到一个诡异的 bug：配置热更新功能在单机测试时工作正常，但在多核服务器上偶尔会失效。经过排查发现，是因为配置标志位没有使用 <code>volatile</code> 修饰，导致某些线程看不到配置的最新值。这个案例让我深刻意识到 JMM 知识的重要性。</p>
</blockquote>
<p>在现代多核 CPU 架构下，每个 CPU 核心都有自己的缓存层次（L1、L2、L3），Java 程序要想正确运行在这样的硬件环境中，就必须有一套明确的内存访问规范。JMM 正是这样一套规范，它：</p>
<ul>
<li><strong>屏蔽硬件差异</strong>：让 Java 程序在不同硬件平台上表现一致</li>
<li><strong>定义可见性规则</strong>：明确什么时候一个线程的修改对另一个线程可见</li>
<li><strong>规范执行顺序</strong>：在保证性能的前提下约束指令重排序的范围</li>
</ul>
<p>JMM 是 Java 虚拟机规范的一部分，它试图在不同的硬件和操作系统之间提供一个一致的内存访问视图，并定义了 Java 程序中各种变量（尤其是共享变量）的访问规则，以及在并发环境下，一个线程对共享变量的写入何时对另一个线程可见。</p>
<span id="more"></span>

<h2 id="JMM-的目标与核心问题"><a href="#JMM-的目标与核心问题" class="headerlink" title="JMM 的目标与核心问题"></a>JMM 的目标与核心问题</h2><ul>
<li><strong>目标</strong>: 屏蔽各种硬件和操作系统的内存访问差异，实现让 Java 程序在各种平台下都能达到一致的内存访问效果。</li>
<li><strong>核心问题</strong>: 在多线程环境下，主要解决由 CPU 缓存、指令重排序等原因引发的：<ul>
<li><strong>可见性 (Visibility)</strong>: 一个线程修改了共享变量的值，其他线程能够立即得知这个修改。</li>
<li><strong>原子性 (Atomicity)</strong>: 一个或多个操作在 CPU 执行的过程中不被中断的特性。</li>
<li><strong>有序性 (Ordering)</strong>: 程序执行的顺序按照代码的先后顺序执行（或者至少结果与按代码顺序执行一致）。</li>
</ul>
</li>
</ul>
<h2 id="JMM-的核心抽象概念"><a href="#JMM-的核心抽象概念" class="headerlink" title="JMM 的核心抽象概念"></a>JMM 的核心抽象概念</h2><ul>
<li><p><strong>主内存 (Main Memory)</strong></p>
<ul>
<li>所有线程共享的存储区域。</li>
<li>存储了 Java 对象实例、静态字段、数组元素等。</li>
<li>是一个逻辑上的概念，可以对应物理硬件的 RAM。</li>
</ul>
</li>
<li><p><strong>工作内存 (Working Memory &#x2F; Local Memory)</strong></p>
<ul>
<li>每个线程私有的数据区域。</li>
<li>存储了该线程使用的变量在主内存中的<strong>副本拷贝</strong>。</li>
<li>线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，不能直接读写主内存。</li>
<li>工作内存也是一个抽象概念，可能对应 CPU 的高速缓存（L1, L2, L3 Cache）、寄存器等。</li>
</ul>
</li>
<li><p><strong>线程间通信</strong>: 线程之间的共享变量值的传递必须通过主内存来完成。</p>
<ul>
<li>线程 A 修改共享变量 -&gt; 工作内存 A -&gt; （通过 JMM 的规则）-&gt; 主内存。</li>
<li>线程 B 读取共享变量 -&gt; 主内存 -&gt; （通过 JMM 的规则）-&gt; 工作内存 B -&gt; 线程 B 使用。</li>
</ul>
</li>
</ul>
<pre class="mermaid" style="text-align: center;">
            graph TD
            subgraph CPU1_Core
WM1["工作内存 1 (L1/L2 Cache, Registers)"]
end
subgraph CPU2_Core
WM2["工作内存 2 (L1/L2 Cache, Registers)"]
end
Thread1 -->|操作| WM1
Thread2 -->|操作| WM2
WM1 <-->|"数据交换(Load/Store via Bus)"| MainMemory["主内存 (RAM)"]
WM2 <-->|"数据交换(Load/Store via Bus)"| MainMemory

style WM1 fill:#lightgreen,stroke:#333
style WM2 fill:#lightgreen,stroke:#333
style MainMemory fill:#lightblue,stroke:#333

          </pre>

<p><strong>类比</strong>:</p>
<ul>
<li><strong>主内存</strong>: 像是一个中央图书馆，存放着所有共享的书籍（数据）。</li>
<li><strong>工作内存</strong>: 每个研究员（线程）都有自己的办公桌，他们会从图书馆借阅书籍的复印件（数据副本）到自己的桌上进行阅读和修改。</li>
<li><strong>通信</strong>: 研究员 A 修改了复印件后，需要将修改后的版本送回图书馆（写回主内存），其他研究员 B 如果想看最新的，也需要从图书馆借阅最新的复印件（从主内存读取）。</li>
</ul>
<h2 id="内存间的交互操作-8-种原子操作-了解其语义"><a href="#内存间的交互操作-8-种原子操作-了解其语义" class="headerlink" title="内存间的交互操作 (8 种原子操作 - 了解其语义)"></a>内存间的交互操作 (8 种原子操作 - 了解其语义)</h2><p>JMM 定义了 8 种操作来完成主内存与工作内存之间的交互，这些操作都是原子的、不可再分的（对于 double 和 long 的非原子性协定除外，但现代 JVM 通常都实现为原子）：</p>
<ul>
<li><code>lock</code> (锁定): 作用于主内存变量，标识为线程独占。</li>
<li><code>unlock</code> (解锁): 作用于主内存变量，释放锁定状态。</li>
<li><code>read</code> (读取): 从主内存读取变量值，传输到工作内存，供<code>load</code>使用。</li>
<li><code>load</code> (载入): 把<code>read</code>到的值放入工作内存的变量副本中。</li>
<li><code>use</code> (使用): 把工作内存变量的值传递给执行引擎。</li>
<li><code>assign</code> (赋值): 把从执行引擎接收到的值赋给工作内存变量。</li>
<li><code>store</code> (存储): 把工作内存变量的值传送到主内存，供<code>write</code>使用。</li>
<li><code>write</code> (写入): 把<code>store</code>传送过来的值写入主内存变量。</li>
</ul>
<p><strong>规则 (部分)</strong>:</p>
<ul>
<li>不允许<code>read</code>和<code>load</code>、<code>store</code>和<code>write</code>操作之一单独出现。</li>
<li>不允许线程丢弃它最近的<code>assign</code>操作，即变量在工作内存中改变了之后必须同步到主内存中。</li>
<li>不允许线程无原因地（没有发生过任何<code>assign</code>操作）把数据从工作内存同步回主内存。</li>
<li>一个新的变量只能在主内存中”诞生”。</li>
<li>一个变量在同一时刻只允许一条线程对其进行<code>lock</code>操作，但<code>lock</code>操作可以被同一条线程重复执行多次（对应可重入锁）。</li>
<li>如果对一个变量执行<code>lock</code>操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行<code>load</code>或<code>assign</code>操作初始化变量的值。</li>
<li>如果一个变量事先没有被<code>lock</code>操作锁定，则不允许对它执行<code>unlock</code>操作，也不允许去<code>unlock</code>一个被其他线程锁定的变量。</li>
<li>对一个变量执行<code>unlock</code>操作之前，必须先把此变量同步回主内存中（执行<code>store</code>、<code>write</code>操作）。</li>
</ul>
<h2 id="并发编程中的三大特性-JMM-如何通过关键字和规则来保证"><a href="#并发编程中的三大特性-JMM-如何通过关键字和规则来保证" class="headerlink" title="并发编程中的三大特性 (JMM 如何通过关键字和规则来保证)"></a>并发编程中的三大特性 (JMM 如何通过关键字和规则来保证)</h2><ul>
<li><p><strong>原子性 (Atomicity)</strong></p>
<ul>
<li><strong>定义</strong>: 一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</li>
<li><strong>JMM 保证</strong>:<ul>
<li>基本数据类型（<code>byte</code>, <code>short</code>, <code>int</code>, <code>float</code>, <code>boolean</code>, <code>char</code>, <code>reference</code>）的简单读取和赋值操作是原子的。（<code>long</code>和<code>double</code>的 64 位非原子性协定在实际 JVM 中通常也被实现为原子）。</li>
<li><code>synchronized</code>关键字：通过<code>monitorenter</code>和<code>monitorexit</code>字节码指令，保证了被同步代码块的操作是原子的。它隐式地执行了<code>lock</code>和<code>unlock</code>操作。</li>
<li><code>java.util.concurrent.locks.Lock</code>接口的实现（如<code>ReentrantLock</code>）：提供了显式的<code>lock()</code>和<code>unlock()</code>操作，也保证了原子性。</li>
<li><code>java.util.concurrent.atomic</code>包下的原子类：通过 CAS 无锁操作保证了复合操作（如<code>i++</code>）的原子性。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>可见性 (Visibility)</strong></p>
<ul>
<li><strong>定义</strong>: 当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。</li>
<li><strong>JMM 保证</strong>:<ul>
<li><code>volatile</code>关键字：<ul>
<li>当写一个<code>volatile</code>变量时，JMM 会把该线程对应的本地内存中的共享变量值刷新到主内存。</li>
<li>当读一个<code>volatile</code>变量时，JMM 会把该线程对应的本地内存置为无效，线程将直接从主内存读取共享变量。</li>
</ul>
</li>
<li><code>synchronized</code>关键字：<ul>
<li>对一个变量执行<code>unlock</code>操作之前，必须先把此变量同步回主内存（<code>store</code>, <code>write</code>）。</li>
<li>对一个变量执行<code>lock</code>操作时，会清空工作内存中此变量的值，使用前需重新从主内存加载（<code>load</code>, <code>read</code>）。</li>
</ul>
</li>
<li><code>final</code>关键字：被<code>final</code>修饰的字段在构造器中一旦初始化完成，并且构造器没有把”this”引用传递出去（无逸出），那么在其他线程中就能看见<code>final</code>字段的值。</li>
<li><code>java.util.concurrent.locks.Lock</code>接口的实现。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>有序性 (Ordering)</strong></p>
<ul>
<li><strong>定义</strong>: 程序执行的顺序按照代码的先后顺序执行。</li>
<li><strong>指令重排序</strong>: 编译器和处理器为了优化性能，可能会改变程序中语句的执行顺序，只要不改变单线程程序的最终结果（<code>as-if-serial</code>语义）。但在多线程中，重排序可能导致问题。</li>
<li><strong>JMM 保证</strong>:<ul>
<li><code>volatile</code>关键字：通过插入<strong>内存屏障 (Memory Barrier&#x2F;Fence)</strong> 来禁止特定类型的指令重排序。</li>
<li><code>synchronized</code>关键字：一个变量在同一个锁上一次只能被一个线程操作，这使得持有同一个锁的两个同步块只能串行地进入，表现出一定的有序性。具体来说，一个<code>unlock</code>操作 <code>happens-before</code> 后续对同一个锁的<code>lock</code>操作。</li>
<li><code>java.util.concurrent.locks.Lock</code>接口的实现。</li>
<li><strong>Happens-Before 原则</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Happens-Before-原则-JMM-中非常核心的规则"><a href="#Happens-Before-原则-JMM-中非常核心的规则" class="headerlink" title="Happens-Before 原则 (JMM 中非常核心的规则)"></a>Happens-Before 原则 (JMM 中非常核心的规则)</h2><p>Happens-Before 是 JMM 中用于判断数据是否存在竞争、线程是否安全的主要依据。它定义了在 Java 内存模型中，两个操作之间的偏序关系。如果操作 A <code>happens-before</code> 操作 B (记作 A hb B)，那么 JMM 保证 A 操作的执行结果对 B 操作可见，并且 A 操作的执行顺序在 B 操作之前。</p>
<p><strong>主要的 Happens-Before 规则：</strong></p>
<ol>
<li><strong>程序次序规则 (Program Order Rule)</strong>: 在一个线程内，按照代码控制流顺序，书写在前面的操作先行发生于书写在后面的操作。</li>
<li><strong>管程锁定规则 (Monitor Lock Rule)</strong>: 一个<code>unlock</code>操作先行发生于后面对<strong>同一个锁</strong>的<code>lock</code>操作。</li>
<li><strong><code>volatile</code>变量规则 (Volatile Variable Rule)</strong>: 对一个<code>volatile</code>变量的写操作先行发生于后面对这个变量的读操作。</li>
<li><strong>线程启动规则 (Thread Start Rule)</strong>: <code>Thread</code>对象的<code>start()</code>方法先行发生于此线程的每一个动作。</li>
<li><strong>线程终止规则 (Thread Termination Rule)</strong>: 线程中的所有操作都先行发生于对此线程的终止检测（如<code>Thread.join()</code>返回，<code>Thread.isAlive()</code>返回<code>false</code>）。</li>
<li><strong>线程中断规则 (Thread Interruption Rule)</strong>: 对线程<code>interrupt()</code>方法的调用先行发生于被中断线程的代码检测到中断事件的发生。</li>
<li><strong>对象终结规则 (Finalizer Rule)</strong>: 一个对象的初始化完成（构造函数执行结束）先行发生于它的<code>finalize()</code>方法的开始。</li>
<li><strong>传递性 (Transitivity)</strong>: 如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，那么可以得出操作 A 先行发生于操作 C。</li>
</ol>
<p><strong>作用</strong>: 开发者可以通过这些规则来判断自己的并发程序是否是线程安全的，而无需关心底层 JMM 的复杂实现细节。如果两个操作之间不存在<code>happens-before</code>关系，那么 JVM 可以对它们进行任意重排序。</p>
<p><strong>类比 Happens-Before</strong>: 像是一系列”因果律令”。如果事件 A 是事件 B 的”因”（A hb B），那么 B 就能看到 A 造成的所有”果”（内存可见性），并且 A 一定在 B 之前发生。</p>
<h2 id="实际代码示例：看看-JMM-问题如何发生"><a href="#实际代码示例：看看-JMM-问题如何发生" class="headerlink" title="实际代码示例：看看 JMM 问题如何发生"></a>实际代码示例：看看 JMM 问题如何发生</h2><h3 id="可见性问题示例"><a href="#可见性问题示例" class="headerlink" title="可见性问题示例"></a>可见性问题示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VisibilityExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">stop</span> <span class="operator">=</span> <span class="literal">false</span>;  <span class="comment">// 未使用volatile</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">        stop = <span class="literal">true</span>;  <span class="comment">// 线程A修改stop</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stop) &#123;  <span class="comment">// 线程B可能永远看不到stop=true</span></span><br><span class="line">            <span class="comment">// 做其他工作</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;停止了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>问题</strong>: 线程 B 可能永远在循环中，因为它在工作内存中的<code>stop</code>副本可能一直是<code>false</code>。</p>
<p><strong>解决方案</strong>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">stop</span> <span class="operator">=</span> <span class="literal">false</span>;  <span class="comment">// 使用volatile保证可见性</span></span><br></pre></td></tr></table></figure>

<h3 id="原子性问题示例"><a href="#原子性问题示例" class="headerlink" title="原子性问题示例"></a>原子性问题示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicityExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 非原子操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;  <span class="comment">// 这不是原子操作！实际是三步：读取-&gt;增加-&gt;写入</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>问题</strong>: 多线程同时调用<code>increment()</code>可能导致计数错误。</p>
<p><strong>解决方案</strong>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方案1: 使用synchronized</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方案2: 使用原子类</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    count.incrementAndGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="有序性问题示例（双重检查锁定）"><a href="#有序性问题示例（双重检查锁定）" class="headerlink" title="有序性问题示例（双重检查锁定）"></a>有序性问题示例（双重检查锁定）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  <span class="comment">// 问题：缺少volatile</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;  <span class="comment">// 第一次检查</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;  <span class="comment">// 第二次检查</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();  <span class="comment">// 可能发生指令重排序！</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>问题</strong>: <code>new Singleton()</code>分为三步：</p>
<ol>
<li>分配内存空间</li>
<li>初始化对象</li>
<li>将<code>instance</code>指向内存地址</li>
</ol>
<p>由于指令重排序，可能变成 1→3→2，导致其他线程拿到未初始化完成的对象。</p>
<p><strong>解决方案</strong>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;  <span class="comment">// 使用volatile禁止重排序</span></span><br></pre></td></tr></table></figure>

<h2 id="内存屏障深入理解"><a href="#内存屏障深入理解" class="headerlink" title="内存屏障深入理解"></a>内存屏障深入理解</h2><p>volatile 关键字通过插入内存屏障来实现其语义：</p>
<ul>
<li><strong>LoadLoad 屏障</strong>: 确保屏障前的 load 操作先于屏障后的 load 操作</li>
<li><strong>StoreStore 屏障</strong>: 确保屏障前的 store 操作先于屏障后的 store 操作</li>
<li><strong>LoadStore 屏障</strong>: 确保屏障前的 load 操作先于屏障后的 store 操作</li>
<li><strong>StoreLoad 屏障</strong>: 确保屏障前的 store 操作先于屏障后的 load 操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// volatile变量的内存屏障插入策略</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> v;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写volatile变量时的内存屏障</span></span><br><span class="line">StoreStore屏障</span><br><span class="line">v = <span class="number">1</span>;  <span class="comment">// volatile写</span></span><br><span class="line">StoreLoad屏障</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读volatile变量时的内存屏障</span></span><br><span class="line">LoadLoad屏障</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> v;  <span class="comment">// volatile读</span></span><br><span class="line">LoadStore屏障</span><br></pre></td></tr></table></figure>

<h2 id="性能考虑：volatile-vs-synchronized"><a href="#性能考虑：volatile-vs-synchronized" class="headerlink" title="性能考虑：volatile vs synchronized"></a>性能考虑：volatile vs synchronized</h2><table>
<thead>
<tr>
<th>特性</th>
<th>volatile</th>
<th>synchronized</th>
</tr>
</thead>
<tbody><tr>
<td><strong>原子性</strong></td>
<td>❌ 仅保证读写原子性</td>
<td>✅ 保证代码块原子性</td>
</tr>
<tr>
<td><strong>可见性</strong></td>
<td>✅ 立即可见</td>
<td>✅ 解锁时刷新到主内存</td>
</tr>
<tr>
<td><strong>有序性</strong></td>
<td>✅ 禁止重排序</td>
<td>✅ 串行执行</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>⚡ 较高（无锁）</td>
<td>🐌 较低（加锁）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>状态标志、配置值</td>
<td>复合操作、临界区</td>
</tr>
</tbody></table>
<p><strong>选择建议</strong>:</p>
<ul>
<li>简单的状态标志 → 使用<code>volatile</code></li>
<li>复合操作（如 i++） → 使用<code>synchronized</code>或原子类</li>
<li>高并发计数 → 使用<code>AtomicInteger</code>等原子类</li>
<li>复杂业务逻辑 → 使用<code>synchronized</code>或<code>Lock</code></li>
</ul>
<h2 id="常见误区与陷阱"><a href="#常见误区与陷阱" class="headerlink" title="常见误区与陷阱"></a>常见误区与陷阱</h2><h3 id="❌-误区-1：认为-volatile-能保证原子性"><a href="#❌-误区-1：认为-volatile-能保证原子性" class="headerlink" title="❌ 误区 1：认为 volatile 能保证原子性"></a>❌ 误区 1：认为 volatile 能保证原子性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    count++;  <span class="comment">// 仍然不是原子操作！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="❌-误区-2：过度使用-synchronized"><a href="#❌-误区-2：过度使用-synchronized" class="headerlink" title="❌ 误区 2：过度使用 synchronized"></a>❌ 误区 2：过度使用 synchronized</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不必要的同步</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> name;  <span class="comment">// 如果name是final或不会变化，无需同步</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="❌-误区-3：忽略构造函数中的”this”逸出"><a href="#❌-误区-3：忽略构造函数中的”this”逸出" class="headerlink" title="❌ 误区 3：忽略构造函数中的”this”逸出"></a>❌ 误区 3：忽略构造函数中的”this”逸出</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThisEscape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThisEscape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 危险！构造未完成就暴露this引用</span></span><br><span class="line">        EventQueue.addListener(<span class="keyword">new</span> <span class="title class_">EventListener</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Event e)</span> &#123;</span><br><span class="line">                doSomething(e);  <span class="comment">// 可能访问到未初始化完成的对象</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        value = <span class="number">42</span>;  <span class="comment">// 这个赋值可能在listener注册之后执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实际开发中的最佳实践"><a href="#实际开发中的最佳实践" class="headerlink" title="实际开发中的最佳实践"></a>实际开发中的最佳实践</h2><h3 id="1-优先使用线程安全的工具类"><a href="#1-优先使用线程安全的工具类" class="headerlink" title="1. 优先使用线程安全的工具类"></a>1. 优先使用线程安全的工具类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 推荐使用并发集合</span></span><br><span class="line">ConcurrentHashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">BlockingQueue&lt;Task&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h3 id="2-合理使用-volatile-的经典场景"><a href="#2-合理使用-volatile-的经典场景" class="headerlink" title="2. 合理使用 volatile 的经典场景"></a>2. 合理使用 volatile 的经典场景</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置更新标志</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">configUpdated</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双重检查锁定</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleton instance;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态标志</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">shutdown</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<h3 id="3-使用-final-提高安全性"><a href="#3-使用-final-提高安全性" class="headerlink" title="3. 使用 final 提高安全性"></a>3. 使用 final 提高安全性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImmutablePoint</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ImmutablePoint</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">        <span class="comment">// final字段在构造完成后对所有线程可见</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-谨慎使用双重检查锁定"><a href="#4-谨慎使用双重检查锁定" class="headerlink" title="4. 谨慎使用双重检查锁定"></a>4. 谨慎使用双重检查锁定</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确的双重检查锁定实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazySingleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Java 内存模型是并发编程的理论基础，理解 JMM 有助于：</p>
<ol>
<li><strong>写出正确的并发代码</strong>：避免数据竞争和内存一致性问题</li>
<li><strong>性能优化</strong>：合理选择同步机制，避免过度同步</li>
<li><strong>问题排查</strong>：理解并发 bug 的根本原因</li>
<li><strong>代码 Review</strong>：识别潜在的并发安全问题</li>
</ol>
<p><strong>记住这个口诀</strong>：</p>
<ul>
<li><strong>原子性</strong>靠锁（synchronized&#x2F;Lock）或原子类</li>
<li><strong>可见性</strong>靠 volatile、synchronized 或 final</li>
<li><strong>有序性</strong>靠 volatile、synchronized 或 happens-before</li>
</ul>
<p>最重要的是：<strong>在实际开发中，优先使用<code>java.util.concurrent</code>包下的线程安全工具类，而不是自己实现复杂的同步逻辑</strong>。这样既能保证正确性，又能获得更好的性能。</p>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>底层</tag>
        <tag>线程</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发编程深度解析 - 系列导读</title>
    <url>/2025/05/15/Java-Threads/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E7%B3%BB%E5%88%97%E5%AF%BC%E8%AF%BB/</url>
    <content><![CDATA[<h1 id="Java-并发编程深度解析-系列导读"><a href="#Java-并发编程深度解析-系列导读" class="headerlink" title="Java 并发编程深度解析 - 系列导读"></a>Java 并发编程深度解析 - 系列导读</h1><h2 id="系列文章概述"><a href="#系列文章概述" class="headerlink" title="系列文章概述"></a>系列文章概述</h2><p>并发编程是 Java 开发中的核心技能，也是技术面试和实际项目中的重点难点。本系列文章将从底层原理到实战应用，全面深入地解析 Java 并发编程的各个方面。</p>
<span id="more"></span>

<h2 id="📚-系列文章目录"><a href="#📚-系列文章目录" class="headerlink" title="📚 系列文章目录"></a>📚 系列文章目录</h2><h3 id="基础篇：理论基础与核心概念"><a href="#基础篇：理论基础与核心概念" class="headerlink" title="基础篇：理论基础与核心概念"></a>基础篇：理论基础与核心概念</h3><ol>
<li><p><strong><a href="/2025/05/17/Java-Threads/Java%E7%9A%84%E7%BA%BF%E7%A8%8B/" title="Java的线程">Java 线程与操作系统线程</a></strong></p>
<ul>
<li>Java 线程模型与 OS 线程的映射关系</li>
<li>线程生命周期和状态转换详解</li>
<li>Thread 类核心 API 使用指南</li>
<li>线程间协作机制分析</li>
</ul>
</li>
<li><p><strong><a href="/2025/05/19/Java-Threads/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-JMM/" title="Java 内存模型(JMM)">Java 内存模型 (JMM)</a></strong></p>
<ul>
<li>JMM 抽象模型与底层实现</li>
<li>可见性、原子性、有序性三大特性</li>
<li>Happens-Before 原则与内存屏障</li>
<li>8 种内存交互操作详解</li>
</ul>
</li>
<li><p><strong><a href="/2025/05/23/Java-Threads/volatile-%E4%B8%8E-synchronized/" title="Volatile 与 Synchronized">volatile 与 synchronized 深度对比</a></strong></p>
<ul>
<li>volatile 关键字原理与内存屏障实现</li>
<li>synchronized 锁机制与 Monitor 对象详解</li>
<li>两者在 JMM 三大特性上的差异分析</li>
<li>性能对比与实际应用场景选择</li>
</ul>
</li>
</ol>
<h3 id="进阶篇：Lock-框架与-AQS-原理"><a href="#进阶篇：Lock-框架与-AQS-原理" class="headerlink" title="进阶篇：Lock 框架与 AQS 原理"></a>进阶篇：Lock 框架与 AQS 原理</h3><ol start="4">
<li><p><strong>Lock 接口与 ReentrantLock 深度分析</strong></p>
<ul>
<li>Lock 接口设计理念与 API 详解</li>
<li>深入 ReentrantLock 原理</li>
<li>ReentrantLock 的公平锁与非公平锁</li>
<li>可中断锁与定时锁的实现</li>
<li>与 synchronized 的详细对比</li>
</ul>
</li>
<li><p><strong>AbstractQueuedSynchronizer (AQS) 框架源码解析</strong></p>
<ul>
<li>AQS 的设计思想与核心数据结构</li>
<li>独占锁与共享锁的实现机制</li>
<li>条件队列 (Condition) 的工作原理</li>
<li>自定义同步器的开发实践</li>
</ul>
</li>
<li><p><strong>读写锁与 StampedLock 优化</strong></p>
<ul>
<li>ReentrantReadWriteLock 原理与应用</li>
<li>读写锁的性能特征与适用场景</li>
<li>StampedLock 的乐观读锁机制</li>
<li>锁升级与降级的最佳实践</li>
</ul>
</li>
</ol>
<h3 id="实用篇：并发工具类深度应用"><a href="#实用篇：并发工具类深度应用" class="headerlink" title="实用篇：并发工具类深度应用"></a>实用篇：并发工具类深度应用</h3><ol start="7">
<li><p><strong>信号量与计数同步器</strong></p>
<ul>
<li>Semaphore 信号量的原理与应用场景</li>
<li>CountDownLatch 倒计时门闩的使用模式</li>
<li>CyclicBarrier 循环屏障与分阶段计算</li>
<li>Phaser 灵活的多阶段同步器</li>
</ul>
</li>
<li><p><strong>线程间数据交换与协作</strong></p>
<ul>
<li>Exchanger 双线程数据交换器</li>
<li>SynchronousQueue 同步传输队列</li>
<li>TransferQueue 与数据传输模式</li>
<li>PipedInputStream&#x2F;PipedOutputStream 管道通信</li>
</ul>
</li>
<li><p><strong>并发集合类全解析</strong></p>
<ul>
<li>ConcurrentHashMap 的演进：JDK 7 vs JDK 8+</li>
<li>BlockingQueue 家族详解：ArrayBlockingQueue、LinkedBlockingQueue 等</li>
<li>ConcurrentLinkedQueue 无锁队列的实现</li>
<li>CopyOnWriteArrayList 写时复制容器</li>
</ul>
</li>
<li><p><strong>原子类与无锁编程</strong></p>
<ul>
<li>Atomic 基础类型：AtomicInteger、AtomicLong、AtomicBoolean</li>
<li>Atomic 引用类型：AtomicReference、AtomicStampedReference</li>
<li>Atomic 数组类型与 FieldUpdater 系列</li>
<li>CAS 操作原理与 ABA 问题解决方案</li>
</ul>
</li>
</ol>
<h3 id="高级篇：线程池与异步编程"><a href="#高级篇：线程池与异步编程" class="headerlink" title="高级篇：线程池与异步编程"></a>高级篇：线程池与异步编程</h3><ol start="11">
<li><p><strong>ThreadPoolExecutor 线程池深度调优</strong></p>
<ul>
<li>核心参数详解：corePoolSize、maximumPoolSize、workQueue</li>
<li>拒绝策略与自定义策略实现</li>
<li>线程池监控与动态调整</li>
<li>合理选择线程池类型的最佳实践</li>
</ul>
</li>
<li><p><strong>ScheduledThreadPoolExecutor 定时任务调度</strong></p>
<ul>
<li>定时任务的实现原理与延迟队列</li>
<li>固定延迟 vs 固定频率执行</li>
<li>任务异常处理与恢复机制</li>
<li>与 Timer 的对比与迁移指南</li>
</ul>
</li>
<li><p><strong>ForkJoinPool 与分治编程</strong></p>
<ul>
<li>工作窃取算法的设计原理</li>
<li>ForkJoinTask 的递归分解模式</li>
<li>并行流的底层实现机制</li>
<li>分治算法的性能调优技巧</li>
</ul>
</li>
<li><p><strong>CompletableFuture 异步编程实战</strong></p>
<ul>
<li>Future 模式的演进历程</li>
<li>CompletableFuture 的组合与链式调用</li>
<li>异常处理与超时控制</li>
<li>异步编程的最佳实践模式</li>
</ul>
</li>
</ol>
<h3 id="实战篇：性能优化与问题诊断"><a href="#实战篇：性能优化与问题诊断" class="headerlink" title="实战篇：性能优化与问题诊断"></a>实战篇：性能优化与问题诊断</h3><ol start="15">
<li><p><strong>并发性能优化策略</strong></p>
<ul>
<li>锁竞争分析与优化方案</li>
<li>无锁数据结构的选择与应用</li>
<li>CPU 缓存友好的并发编程技巧</li>
<li>分段锁与细粒度同步</li>
</ul>
</li>
<li><p><strong>并发问题诊断与调试</strong></p>
<ul>
<li>死锁检测与预防策略</li>
<li>活锁与饥饿问题分析</li>
<li>线程 dump 分析与工具使用</li>
<li>性能瓶颈定位与解决方案</li>
</ul>
</li>
<li><p><strong>生产环境并发故障案例</strong></p>
<ul>
<li>高并发场景下的常见问题</li>
<li>内存泄漏与线程泄漏排查</li>
<li>分布式系统中的并发控制</li>
<li>监控告警与应急处理</li>
</ul>
</li>
</ol>
<h3 id="前沿篇：新特性与发展趋势"><a href="#前沿篇：新特性与发展趋势" class="headerlink" title="前沿篇：新特性与发展趋势"></a>前沿篇：新特性与发展趋势</h3><ol start="18">
<li><p><strong>Virtual Threads (JDK 19+) 虚拟线程</strong></p>
<ul>
<li>虚拟线程的设计理念与实现原理</li>
<li>与传统线程的性能对比</li>
<li>适用场景与迁移策略</li>
<li>对现有并发编程模式的影响</li>
</ul>
</li>
<li><p><strong>响应式编程与并发</strong></p>
<ul>
<li>Reactive Streams 规范</li>
<li>RxJava 与 Project Reactor</li>
<li>背压 (Backpressure) 控制机制</li>
<li>响应式与传统并发模式对比</li>
</ul>
</li>
</ol>
<h2 id="🎯-学习目标"><a href="#🎯-学习目标" class="headerlink" title="🎯 学习目标"></a>🎯 学习目标</h2><p>通过本系列文章的学习，您将能够：</p>
<h3 id="理论层面"><a href="#理论层面" class="headerlink" title="理论层面"></a>理论层面</h3><ul>
<li>✅ 深入理解 Java 并发编程的底层原理</li>
<li>✅ 掌握内存模型、线程同步、锁机制等核心概念</li>
<li>✅ 理解各种并发工具类的实现原理和适用场景</li>
<li>🔥 掌握 AQS 框架的设计思想和源码实现</li>
<li>🔥 理解无锁编程与 CAS 操作的原理</li>
</ul>
<h3 id="实践层面"><a href="#实践层面" class="headerlink" title="实践层面"></a>实践层面</h3><ul>
<li>🛠️ 能够编写线程安全且高性能的并发代码</li>
<li>🛠️ 合理选择并使用各种并发工具和设计模式</li>
<li>🛠️ 具备并发问题的诊断和解决能力</li>
<li>🛠️ 掌握线程池调优与异步编程技巧</li>
<li>🛠️ 能够处理生产环境中的并发故障</li>
</ul>
<h3 id="面试层面"><a href="#面试层面" class="headerlink" title="面试层面"></a>面试层面</h3><ul>
<li>💼 应对各种并发编程相关的技术面试问题</li>
<li>💼 展示深度的技术理解和实战经验</li>
<li>💼 体现系统性的知识结构和学习能力</li>
<li>💼 具备架构设计中的并发控制思维</li>
</ul>
<h2 id="🚀-学习建议"><a href="#🚀-学习建议" class="headerlink" title="🚀 学习建议"></a>🚀 学习建议</h2><h3 id="基础要求"><a href="#基础要求" class="headerlink" title="基础要求"></a>基础要求</h3><ul>
<li>熟悉 Java 基础语法和面向对象编程</li>
<li>了解 JVM 基本概念和内存模型</li>
<li>有一定的多线程编程经验</li>
</ul>
<h3 id="学习路径"><a href="#学习路径" class="headerlink" title="学习路径"></a>学习路径</h3><ol>
<li><strong>按阶段循序渐进</strong>：基础篇 → 进阶篇 → 实用篇 → 高级篇 → 实战篇 → 前沿篇</li>
<li><strong>动手实践</strong>：每篇文章的代码示例都建议亲自运行和修改</li>
<li><strong>深入思考</strong>：结合实际项目经验，思考如何应用所学知识</li>
<li><strong>阶段性总结</strong>：每完成一个篇章，进行知识点梳理和面试题练习</li>
</ol>
<h3 id="扩展学习"><a href="#扩展学习" class="headerlink" title="扩展学习"></a>扩展学习</h3><ul>
<li>📖 推荐书籍：《Java 并发编程实战》、《Java 并发编程的艺术》</li>
<li>🔗 官方文档：Oracle Java 并发编程指南、JEP 文档</li>
<li>💻 开源项目：分析知名开源项目中的并发编程实践</li>
<li>🎯 源码阅读：深入研究 JUC 包的源码实现</li>
</ul>
<h2 id="🔖-快速导航"><a href="#🔖-快速导航" class="headerlink" title="🔖 快速导航"></a>🔖 快速导航</h2><h3 id="按难度分类"><a href="#按难度分类" class="headerlink" title="按难度分类"></a>按难度分类</h3><ul>
<li><strong>入门级</strong>: <a href="/2025/05/17/Java-Threads/Java%E7%9A%84%E7%BA%BF%E7%A8%8B/" title="Java的线程">Java 线程基础</a></li>
<li><strong>中级</strong>: <a href="/2025/05/19/Java-Threads/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-JMM/" title="Java 内存模型(JMM)">Java 内存模型</a></li>
<li><strong>中级</strong>: <a href="/2025/05/23/Java-Threads/volatile-%E4%B8%8E-synchronized/" title="Volatile 与 Synchronized">volatile 与 synchronized 深度对比</a></li>
<li><strong>高级</strong>: Lock 框架、AQS 源码分析</li>
<li><strong>专家级</strong>: 虚拟线程、响应式编程</li>
</ul>
<h3 id="按应用场景分类"><a href="#按应用场景分类" class="headerlink" title="按应用场景分类"></a>按应用场景分类</h3><ul>
<li><strong>理论基础</strong>: 线程模型、内存模型、JMM 三大特性</li>
<li><strong>关键字深入</strong>: <a href="/2025/05/23/Java-Threads/volatile-%E4%B8%8E-synchronized/" title="Volatile 与 Synchronized">volatile、synchronized 原理与对比</a></li>
<li><strong>锁机制</strong>: ReentrantLock、读写锁、StampedLock</li>
<li><strong>同步工具</strong>: Semaphore、CountDownLatch、CyclicBarrier、Phaser</li>
<li><strong>并发集合</strong>: ConcurrentHashMap、BlockingQueue、原子类</li>
<li><strong>线程池</strong>: ThreadPoolExecutor、ForkJoinPool、异步编程</li>
<li><strong>性能优化</strong>: 无锁编程、分段锁、并发调优</li>
<li><strong>问题排查</strong>: 死锁诊断、性能分析、故障案例</li>
</ul>
<h3 id="面试重点标记-⭐"><a href="#面试重点标记-⭐" class="headerlink" title="面试重点标记 ⭐"></a>面试重点标记 ⭐</h3><ul>
<li>⭐⭐⭐ <a href="/2025/05/19/Java-Threads/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-JMM/" title="Java 内存模型(JMM)">JMM三大特性与happens-before</a></li>
<li>⭐⭐⭐ <a href="/2025/05/17/Java-Threads/Java%E7%9A%84%E7%BA%BF%E7%A8%8B/" title="Java的线程">线程状态转换</a></li>
<li>⭐⭐⭐ <a href="/2025/05/23/Java-Threads/volatile-%E4%B8%8E-synchronized/" title="Volatile 与 Synchronized">volatile 与 synchronized 深度对比</a></li>
<li>⭐⭐⭐ AQS 框架原理与源码分析（规划中）</li>
<li>⭐⭐⭐ ConcurrentHashMap 实现原理（规划中）</li>
<li>⭐⭐ 线程池参数调优与拒绝策略（规划中）</li>
<li>⭐⭐ CountDownLatch 与 CyclicBarrier 对比（规划中）</li>
<li>⭐⭐ 死锁检测与预防策略（规划中）</li>
</ul>
<h3 id="📈-学习进度跟踪"><a href="#📈-学习进度跟踪" class="headerlink" title="📈 学习进度跟踪"></a>📈 学习进度跟踪</h3><ul>
<li>✅ <strong>基础篇已完成</strong> (3&#x2F;3)：线程基础、内存模型、volatile&#x2F;synchronized 对比</li>
<li>🚧 <strong>进阶篇开发中</strong> (0&#x2F;3)：Lock 接口、AQS 框架、读写锁</li>
<li>📅 <strong>实用篇规划中</strong> (0&#x2F;4)：信号量工具、数据交换、并发集合、原子类</li>
<li>📅 <strong>高级篇规划中</strong> (0&#x2F;4)：线程池调优、定时任务、分治编程、异步编程</li>
<li>📅 <strong>实战篇规划中</strong> (0&#x2F;3)：性能优化、问题诊断、故障案例</li>
<li>📅 <strong>前沿篇规划中</strong> (0&#x2F;2)：虚拟线程、响应式编程</li>
</ul>
<p><strong>总进度</strong>: 3&#x2F;19 篇 (15.8%)</p>
<h2 id="📝-阶段性面试题合集"><a href="#📝-阶段性面试题合集" class="headerlink" title="📝 阶段性面试题合集"></a>📝 阶段性面试题合集</h2><p>为了帮助读者更好地准备技术面试，我们将阶段性地整理相关的面试题合集：</p>
<h3 id="已发布"><a href="#已发布" class="headerlink" title="已发布"></a>已发布</h3><h3 id="规划中"><a href="#规划中" class="headerlink" title="规划中"></a>规划中</h3><ul>
<li>📅 <strong>进阶篇面试题合集</strong> - AQS 框架、Lock 接口、读写锁相关问题</li>
<li>📅 <strong>实用篇面试题合集</strong> - 并发工具类、集合类、原子类问题</li>
<li>📅 <strong>综合篇面试题合集</strong> - 线程池、性能优化、故障排查问题</li>
</ul>
<h2 id="💡-作者说明"><a href="#💡-作者说明" class="headerlink" title="💡 作者说明"></a>💡 作者说明</h2><p>作为一名有多年 Java 开发经验的工程师，我在实际项目中遇到过各种并发编程的挑战。从最初的线程安全问题，到后来的性能优化，再到分布式系统中的并发控制，每一次深入都让我对 Java 并发编程有了更深的理解。</p>
<p>本系列文章是我对这些年学习和实践的总结，希望能够帮助读者：</p>
<ul>
<li>🎯 系统性地掌握 Java 并发编程知识</li>
<li>🔍 理解复杂概念背后的简单原理</li>
<li>🛠️ 在实际工作中应用所学知识</li>
<li>📈 在技术成长道路上少走弯路</li>
</ul>
<h2 id="📮-反馈与交流"><a href="#📮-反馈与交流" class="headerlink" title="📮 反馈与交流"></a>📮 反馈与交流</h2><p>如果您在阅读过程中有任何疑问、建议或发现错误，欢迎：</p>
<ul>
<li>在文章下方留言讨论</li>
<li>通过邮件联系作者</li>
<li>分享您的实践经验和心得</li>
</ul>
<p>让我们一起在 Java 并发编程的学习道路上不断进步！</p>
<hr>
<blockquote>
<p><strong>最后更新时间</strong>: 2025-05-23<br><strong>文章状态</strong>: 基础篇已完成，进阶篇开发中<br><strong>预计完成时间</strong>: 2025 年 12 月底</p>
<p>💡 <strong>温馨提示</strong>: 建议收藏此页面，方便随时查看学习进度和文章更新状态</p>
</blockquote>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发编程</tag>
        <tag>系列文章</tag>
        <tag>技术总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Java的线程</title>
    <url>/2025/05/17/Java-Threads/Java%E7%9A%84%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Java-线程与操作系统线程"><a href="#Java-线程与操作系统线程" class="headerlink" title="Java 线程与操作系统线程"></a>Java 线程与操作系统线程</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>线程是现代 Java 应用程序的核心构建块，无论是 Web 服务的请求处理、批量任务的并行执行，还是实时数据处理，都离不开对线程的深入理解。在面试和实际开发中，线程相关的问题往往是考察候选人技术深度的重要指标。</p>
<p>本文将深入探讨 Java 线程的底层实现机制，从<strong>JVM 线程模型</strong>到<strong>操作系统线程映射</strong>，从<strong>线程状态转换</strong>到<strong>实际编程应用</strong>。通过学习本文，您将能够：</p>
<ul>
<li>💡 <strong>理解底层原理</strong>：掌握 Java 线程与 OS 线程的映射关系</li>
<li>🎯 <strong>精通状态管理</strong>：深入理解线程生命周期和状态转换</li>
<li>🔧 <strong>熟练使用 API</strong>：掌握 Thread 类的核心方法和最佳实践</li>
<li>🚀 <strong>解决实际问题</strong>：能够分析和解决常见的线程相关问题</li>
</ul>
<h2 id="为什么要深入理解线程？"><a href="#为什么要深入理解线程？" class="headerlink" title="为什么要深入理解线程？"></a>为什么要深入理解线程？</h2><blockquote>
<p><strong>实际场景</strong>：在优化一个高并发 Web 应用时，发现系统在高负载下响应缓慢。通过分析线程 dump 发现，大量线程阻塞在某个同步方法上。理解线程状态转换和锁机制后，成功通过优化锁粒度和使用并发工具类解决了性能瓶颈。</p>
</blockquote>
<p>现代应用程序几乎都是多线程的，深入理解线程有助于：</p>
<ul>
<li><strong>性能调优</strong>：识别和解决线程竞争、死锁等问题</li>
<li><strong>系统设计</strong>：合理设计并发架构，提高系统吞吐量</li>
<li><strong>问题排查</strong>：快速定位生产环境中的并发问题</li>
<li><strong>技术面试</strong>：线程是 Java 面试的高频考点</li>
</ul>
<h2 id="采用一对一模型"><a href="#采用一对一模型" class="headerlink" title="采用一对一模型"></a>采用一对一模型</h2><ul>
<li><strong>关系</strong>: 主流 JVM（如 HotSpot）采用”一对一”线程模型：一个 Java 线程映射到一个操作系统内核线程。</li>
<li><strong>特点</strong>:<ul>
<li><strong>优点</strong>: 充分利用多核 CPU，操作系统级调度，阻塞不影响其他线程。</li>
<li><strong>缺点</strong>: 创建&#x2F;销毁&#x2F;切换成本高（重量级），线程数量受限。</li>
</ul>
</li>
</ul>
<pre class="mermaid" style="text-align: center;">
            graph LR
            subgraph OS Kernel
KThread1[Kernel Thread 1]
KThread2[Kernel Thread 2]
KThreadN[Kernel Thread N]
end
subgraph JVM Process
JThread1[Java Thread 1] --- KThread1
JThread2[Java Thread 2] --- KThread2
JThreadN[Java Thread N] --- KThreadN
end
UserApp[User Application] -- Creates --> JThread1
UserApp -- Creates --> JThread2
UserApp -- Creates --> JThreadN
          </pre>

<span id="more"></span>

<h2 id="JVM-的线程生命周期"><a href="#JVM-的线程生命周期" class="headerlink" title="JVM 的线程生命周期"></a>JVM 的线程生命周期</h2><p>JVM 规范定义了线程的 6 种状态：</p>
<ul>
<li>NEW：线程刚被创建，但尚未调用 <code>start()</code> 方法。</li>
<li>RUNNABLE：线程已调用 <code>start()</code> 方法，在 JVM 中等待 CPU 调度执行（可能对应操作系统的 <code>Ready</code> 或 <code>Running</code> 状态）。</li>
<li>BLOCKED：线程等待获取一个监视器锁（<code>monitor lock</code>，即 <code>synchronized</code> 块或方法）而阻塞。</li>
<li>WAITING：线程无限期等待另一个线程执行一个特定的唤醒动作。例如，调用了 <code>Object.wait()</code> (无超时)，<code>Thread.join()</code> (无超时)，或 <code>LockSupport.park()</code>。</li>
<li>TIMED_WAITING：线程在指定的时间内等待另一个线程执行一个特定的唤醒动作。例如，调用了 <code>Thread.sleep(t)</code>, <code>Object.wait(t)</code>, <code>Thread.join(t)</code>, <code>LockSupport.parkNanos(t)</code>, <code>LockSupport.parkUntil(deadline)</code>。</li>
<li>TERMINATED：线程的 <code>run()</code> 方法已经执行完毕并正常退出，或者因为一个未捕获的异常而提前终止。</li>
</ul>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentStyleType="text/css" data-diagram-type="STATE" height="510px" preserveAspectRatio="none" style="width:450px;height:510px;background:#FFFFFF;" version="1.1" viewBox="0 0 450 510" width="450px" zoomAndPan="magnify"><title>JVM Thread States</title><defs/><g><g class="title" data-source-line="1"><text fill="#000000" font-family="sans-serif" font-size="14" font-weight="bold" lengthAdjust="spacing" textLength="0" x="218.485" y="10">JVM Thread States</text></g><rect fill="#F1F1F1" height="40" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="50" x="217.97" y="38"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="33.1611" x="226.3894" y="62.8467">NEW</text><rect fill="#F1F1F1" height="40" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="77.1426" x="164.4" y="200.14"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="67.1426" x="169.4" y="224.9867">RUNNABLE</text><rect fill="#F1F1F1" height="40" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="58.2207" x="128.86" y="464.27"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="48.2207" x="133.86" y="489.1167">BLOCKED</text><rect fill="#F1F1F1" height="40" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="71.5508" x="168.19" y="347.27"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="61.5508" x="173.19" y="372.1167">WAITING</text><rect fill="#F1F1F1" height="40" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="115.9365" x="7" y="38"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="105.9365" x="12" y="62.8467">TIMED_WAITING</text><rect fill="#F1F1F1" height="40" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="101.5605" x="286.19" y="200.14"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="91.5605" x="291.19" y="224.9867">TERMINATED</text><ellipse cx="167.97" cy="58" fill="#222222" rx="10" ry="10" style="stroke:#222222;stroke-width:1;"/><ellipse cx="433.97" cy="220.14" fill="none" rx="11" ry="11" style="stroke:#222222;stroke-width:1;"/><ellipse cx="433.97" cy="220.14" fill="#222222" rx="6" ry="6" style="stroke:#222222;stroke-width:1;"/><g class="entity" data-entity="GMN2" data-source-line="32" data-uid="ent0003" id="entity_GMN2"><path d="M88.14,200 L88.14,240.2656 A0,0 0 0 0 88.14,240.2656 L129.8016,240.2656 A0,0 0 0 0 129.8016,240.2656 L129.8016,224.14 L164.06,220.14 L129.8016,216.14 L129.8016,210 L119.8016,200 L88.14,200 A0,0 0 0 0 88.14,200" fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M119.8016,200 L119.8016,210 L129.8016,210 L119.8016,200" fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="20.6616" x="94.14" y="217.0669">JVM RUNNABLE state can correspond to</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="20.6616" x="94.14" y="232.1997">OS Ready or OS Running state.</text></g><!--link *start* to NEW--><g class="link" data-entity-1=".start." data-entity-2="NEW" data-source-line="11" data-uid="lnk3" id="link_.start._NEW"><path d="M178.4,58 C188.54,58 198.34,58 211.77,58" fill="none" id="*start*-to-NEW" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="217.77,58,208.77,54,212.77,58,208.77,62,217.77,58" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="4.1323" x="195.97" y="51.0669">new Thread()</text></g><!--link NEW to RUNNABLE--><g class="link" data-entity-1="NEW" data-entity-2="RUNNABLE" data-source-line="12" data-uid="lnk4" id="link_NEW_RUNNABLE"><path d="M238.14,78.32 C230.46,109.1 216.9643,163.1089 209.2643,193.9289" fill="none" id="NEW-to-RUNNABLE" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="207.81,199.75,213.8722,191.9879,209.0219,194.8991,206.1108,190.0488,207.81,199.75" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="0" x="230.97" y="143.5669">thread.start()</text></g><!--reverse link BLOCKED to RUNNABLE--><g class="link" data-entity-1="BLOCKED" data-entity-2="RUNNABLE" data-source-line="15" data-uid="lnk6" id="link_BLOCKED_RUNNABLE"><path d="M192.1234,461.9952 C216.2934,445.2652 243.79,421.19 256.97,387.27 C276.04,338.16 259.95,318.15 237.97,270.27 C233.16,259.8 226.02,249.26 219.44,240.64" fill="none" id="BLOCKED-backto-RUNNABLE" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="187.19,465.41,196.8667,463.5767,191.3012,462.5643,192.3136,456.9988,187.19,465.41" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="8.2646" x="268.0362" y="364.3369">Enter synchronized block</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="12.397" x="265.97" y="379.4697">(lock held by other)</text></g><!--reverse link RUNNABLE to BLOCKED--><g class="link" data-entity-1="RUNNABLE" data-entity-2="BLOCKED" data-source-line="16" data-uid="lnk8" id="link_RUNNABLE_BLOCKED"><path d="M186.6341,245.659 C171.3941,269.559 150.36,306.87 140.97,347.27 C131.43,388.29 143.21,437.6 151.39,464.13" fill="none" id="RUNNABLE-backto-BLOCKED" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="189.86,240.6,181.6485,246.0379,187.1717,244.8158,188.3938,250.3391,189.86,240.6" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="8.2646" x="141.97" y="371.8369">Acquired synchronized lock</text></g><!--reverse link WAITING to RUNNABLE--><g class="link" data-entity-1="WAITING" data-entity-2="RUNNABLE" data-source-line="18" data-uid="lnk10" id="link_WAITING_RUNNABLE"><path d="M201.5092,341.2344 C200.6892,332.1744 200.37,327.16 199.97,317.27 C199.12,296.4 199.33,291.15 199.97,270.27 C200.27,260.36 200.91,249.34 201.53,240.26" fill="none" id="WAITING-backto-RUNNABLE" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="202.05,347.21,205.2225,337.8861,201.5993,342.2304,197.255,338.6072,202.05,347.21" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="0" x="200.97" y="283.3369">obj.wait()</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="0" x="200.97" y="298.4697">t.join()</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="0" x="200.97" y="313.6025">LockSupport.park()</text></g><!--reverse link RUNNABLE to WAITING--><g class="link" data-entity-1="RUNNABLE" data-entity-2="WAITING" data-source-line="19" data-uid="lnk12" id="link_RUNNABLE_WAITING"><path d="M203.1411,246.4099 C203.3311,274.1699 203.64,319.11 203.83,346.92" fill="none" id="RUNNABLE-backto-WAITING" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="203.1,240.41,199.1617,249.4372,203.1342,245.4099,207.1615,249.3824,203.1,240.41" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="8.2646" x="213.2346" y="283.3369">obj.notify() / notifyAll()</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="0" x="217.367" y="298.4697">LockSupport.unpark(t)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="24.7939" x="204.97" y="313.6025">Interrupted (leads to RUNNABLE after handling IE)</text></g><!--reverse link TIMED_WAITING to RUNNABLE--><g class="link" data-entity-1="TIMED_WAITING" data-entity-2="RUNNABLE" data-source-line="21" data-uid="lnk14" id="link_TIMED_WAITING_RUNNABLE"><path d="M108.5818,81.3756 C121.8818,89.3156 131.02,96.33 141.97,108 C167.86,135.62 186.49,176.3 195.94,200.01" fill="none" id="TIMED_WAITING-backto-RUNNABLE" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="103.43,78.3,109.1073,86.3479,107.7232,80.863,113.2081,79.4788,103.43,78.3" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="0" x="182.97" y="121.0669">Thread.sleep(t)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="0" x="182.97" y="136.1997">obj.wait(t)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="0" x="182.97" y="151.3325">t.join(t)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="0" x="182.97" y="166.4653">LockSupport.parkNanos/Until()</text></g><!--link TIMED_WAITING to RUNNABLE--><g class="link" data-entity-1="TIMED_WAITING" data-entity-2="RUNNABLE" data-source-line="22" data-uid="lnk15" id="link_TIMED_WAITING_RUNNABLE"><path d="M68.15,78.47 C72.97,102.54 84.22,143.55 107.97,170 C122.98,186.72 139.4764,196.3147 158.5564,204.2147" fill="none" id="TIMED_WAITING-to-RUNNABLE" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="164.1,206.51,157.3148,199.3713,159.4803,204.5972,154.2544,206.7628,164.1,206.51" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="0" x="121.367" y="121.0669">Timeout</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="8.2646" x="117.2346" y="136.1997">obj.notify() / notifyAll()</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="0" x="121.367" y="151.3325">LockSupport.unpark(t)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="24.7939" x="108.97" y="166.4653">Interrupted (leads to RUNNABLE after handling IE)</text></g><!--link WAITING to BLOCKED--><g class="link" data-entity-1="WAITING" data-entity-2="BLOCKED" data-source-line="25" data-uid="lnk16" id="link_WAITING_BLOCKED"><path d="M196.27,387.52 C187.78,408.75 176.4183,437.1391 167.9183,458.3891" fill="none" id="WAITING-to-BLOCKED" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="165.69,463.96,172.7464,457.0893,167.547,459.3176,165.3186,454.1181,165.69,463.96" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="20.6616" x="184.97" y="430.3369">Awakened, tries to re-acquire lock (held)</text></g><!--link TIMED_WAITING to BLOCKED--><g class="link" data-entity-1="TIMED_WAITING" data-entity-2="BLOCKED" data-source-line="26" data-uid="lnk17" id="link_TIMED_WAITING_BLOCKED"><path d="M65.4,78.26 C65.91,100.4 66.85,137.83 67.97,170 C69.06,201.24 65.5,209.5 70.97,240.27 C86.82,329.39 98.51,350.57 132.97,434.27 C137.11,444.34 139.7042,449.8618 144.4342,458.7618" fill="none" id="TIMED_WAITING-to-BLOCKED" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="147.25,464.06,146.5585,454.2355,144.9035,459.6448,139.4941,457.9899,147.25,464.06" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="20.6616" x="88.97" y="298.3369">Awakened, tries to re-acquire lock (held)</text></g><!--link RUNNABLE to TERMINATED--><g class="link" data-entity-1="RUNNABLE" data-entity-2="TERMINATED" data-source-line="28" data-uid="lnk18" id="link_RUNNABLE_TERMINATED"><path d="M241.73,220.14 C255.49,220.14 265.19,220.14 279.82,220.14" fill="none" id="RUNNABLE-to-TERMINATED" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="285.82,220.14,276.82,216.14,280.82,220.14,276.82,224.14,285.82,220.14" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="8.2646" x="259.86" y="198.2069">run() completes or</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="4.1323" x="261.9262" y="213.3397">uncaught exception</text></g><!--link TERMINATED to *end*--><g class="link" data-entity-1="TERMINATED" data-entity-2=".end." data-source-line="30" data-uid="lnk20" id="link_TERMINATED_.end."><path d="M388.12,220.14 C399.58,220.14 405.04,220.14 416.51,220.14" fill="none" id="TERMINATED-to-*end*" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="422.51,220.14,413.51,216.14,417.51,220.14,413.51,224.14,422.51,220.14" style="stroke:#181818;stroke-width:1;"/></g><!--SRC=[jLHBRzim3BxhL_3MPAYJ-mu3tDKOl2KkaBZheHa6rMPgDGxboHIoxDUFSfpdiik0dVGW-P4VNsouHlZyTGfvvL2NC6VDsAhAb0YuRdWB9RQ5CmqRIqgrGGnPyjJVPezP5jzDalvvDtdu-2MvxrzFSPgdsQV-bQVJvFxxnLyocwPPd8k9Udxt3I9dNYkEFWGFy1u8DtrSWw4ANr5fDoJYlLlHuKu-4Zp7egNKGHRLk0nOVL2Ycn2ZWtPBHUKicLzOmajjYzM21k602clvsOBb2jrGxGqZtvpxZ8iVtZYnFeCA45VSzup5pBwyZJRQI9WBuj6RDHHk4p6R-wQnZaUDTYiXiJVvmt508CjckHqCOGoxQrpNbpYUEYIMxpHmThvXYN1GIwfQO7l4rCkGaafJMHjwXJGPNg5mLZe98-zpNYCsdPC3CpvIuolSCass7JyI6mbPdSDUgMrkrcWzx_3_F- -RdbWBUgDNI6AvT7RTLN1y7YoX20LFr7Uzq5M_lON2-j13MDZrOHnkr2N7Oql6lQTRO6UmtM56fw0m26tvjspz2z99WVVpTXn4GN9U6bEOh9iQPHc0TGloL6Wlke0_2-oNmOdH0KYcM2cfZtYKtW6xFArds3E7vsu359h4atFODfP2IXVqC8UPL476q46uUw9Geav_z1i0]--></g></svg>

<h2 id="操作系统（LINUX）的线程生命周期"><a href="#操作系统（LINUX）的线程生命周期" class="headerlink" title="操作系统（LINUX）的线程生命周期"></a>操作系统（LINUX）的线程生命周期</h2><p>操作系统层面的线程状态比 JVM 定义的更细致一些，并且不同操作系统的术语可能略有差异。以下是一个通用的模型，常用于类 Unix 系统（如 Linux）：</p>
<ul>
<li><strong>New (新建)</strong>: 线程刚被创建，系统为其分配了资源（如线程控制块 TCB），但尚未被调度执行。 (类似 JVM NEW)</li>
<li><strong>Ready (就绪)</strong>: 线程已准备好运行，拥有了除 CPU 之外的所有必需资源，正在等待 CPU 调度器分配 CPU 时间片。</li>
<li><strong>Running (运行)</strong>: 线程正在 CPU 上执行指令。</li>
<li><strong>Blocked&#x2F;Waiting&#x2F;Sleeping (阻塞&#x2F;等待&#x2F;睡眠)</strong>: 线程因为等待某个事件而暂停执行，例如：<ul>
<li>等待 I&#x2F;O 操作完成。</li>
<li>等待获取一个锁或信号量。</li>
<li>主动调用 sleep。</li>
<li>等待另一个线程的信号 (wait, join)。</li>
<li>(类似 JVM BLOCKED, WAITING, TIMED_WAITING)</li>
</ul>
</li>
<li><strong>Terminated&#x2F;Zombie (终止&#x2F;僵尸)</strong>: 线程执行完毕或被终止，但其 TCB 可能尚未被父进程或系统完全回收（例如，等待父进程读取其退出状态）。最终会被彻底清理。 (类似 JVM TERMINATED)</li>
</ul>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentStyleType="text/css" data-diagram-type="STATE" height="487px" preserveAspectRatio="none" style="width:874px;height:487px;background:#FFFFFF;" version="1.1" viewBox="0 0 874 487" width="874px" zoomAndPan="magnify"><title>OS Thread States (Generic Model)</title><defs/><g><g class="title" data-source-line="1"><text fill="#000000" font-family="sans-serif" font-size="14" font-weight="bold" lengthAdjust="spacing" textLength="268.7207" x="295.6396" y="22.9951">OS Thread States (Generic Model)</text></g><rect fill="#F1F1F1" height="40" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="50" x="211" y="44.2969"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="30.5361" x="220.7319" y="69.1436">New</text><rect fill="#F1F1F1" height="40" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="54.0918" x="208.95" y="176.4269"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="44.0918" x="213.95" y="201.2736">Ready</text><rect fill="#F1F1F1" height="40" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="67.9961" x="445" y="308.5569"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="57.9961" x="450" y="333.4036">Running</text><rect fill="#F1F1F1" height="40" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="65.3643" x="171.32" y="440.6969"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="55.3643" x="176.32" y="465.5436">Blocked</text><rect fill="#F1F1F1" height="40" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="90.8896" x="583.56" y="440.6969"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="80.8896" x="588.56" y="465.5436">Terminated</text><ellipse cx="16" cy="64.2969" fill="#222222" rx="10" ry="10" style="stroke:#222222;stroke-width:1;"/><ellipse cx="857" cy="460.6969" fill="none" rx="11" ry="11" style="stroke:#222222;stroke-width:1;"/><ellipse cx="857" cy="460.6969" fill="#222222" rx="6" ry="6" style="stroke:#222222;stroke-width:1;"/><g class="entity" data-entity="GMN2" data-source-line="26" data-uid="ent0003" id="entity_GMN2"><path d="M297.64,176.2969 L297.64,192.4269 L263.52,196.4269 L297.64,200.4269 L297.64,216.5625 A0,0 0 0 0 297.64,216.5625 L560.3588,216.5625 A0,0 0 0 0 560.3588,216.5625 L560.3588,186.2969 L550.3588,176.2969 L297.64,176.2969 A0,0 0 0 0 297.64,176.2969" fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M550.3588,176.2969 L550.3588,186.2969 L560.3588,186.2969 L550.3588,176.2969" fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="241.7188" x="303.64" y="193.3638">JVM's RUNNABLE state often maps to</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="209.5615" x="303.64" y="208.4966">OS Ready or OS Running states.</text></g><g class="entity" data-entity="GMN5" data-source-line="27" data-uid="ent0006" id="entity_GMN5"><path d="M285.64,440.5569 L285.64,480.8225 A0,0 0 0 0 285.64,480.8225 L548.3588,480.8225 A0,0 0 0 0 548.3588,480.8225 L548.3588,450.5569 L538.3588,440.5569 L430.35,440.5569 L469.72,349.0469 L422.35,440.5569 L285.64,440.5569 A0,0 0 0 0 285.64,440.5569" fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M538.3588,440.5569 L538.3588,450.5569 L548.3588,450.5569 L538.3588,440.5569" fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="241.7188" x="291.64" y="457.6238">JVM's RUNNABLE state often maps to</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="209.5615" x="291.64" y="472.7566">OS Ready or OS Running states.</text></g><!--link *start* to New--><g class="link" data-entity-1=".start." data-entity-2="New" data-source-line="9" data-uid="lnk3" id="link_.start._New"><path d="M26.32,64.2969 C59.28,64.2969 156.7,64.2969 204.86,64.2969" fill="none" id="*start*-to-New" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="210.86,64.2969,201.86,60.2969,205.86,64.2969,201.86,68.2969,210.86,64.2969" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="149.3159" x="44" y="57.3638">Process creates thread</text></g><!--link New to Ready--><g class="link" data-entity-1="New" data-entity-2="Ready" data-source-line="10" data-uid="lnk4" id="link_New_Ready"><path d="M236,84.7769 C236,109.4569 236,145.7069 236,170.2369" fill="none" id="New-to-Ready" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="236,176.2369,240,167.2369,236,171.2369,232,167.2369,236,176.2369" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="116.4414" x="237" y="127.3638">Thread initialized,</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="80.3931" x="255.0242" y="142.4966">ready to run</text></g><!--link Ready to Running--><g class="link" data-entity-1="Ready" data-entity-2="Running" data-source-line="12" data-uid="lnk5" id="link_Ready_Running"><path d="M263.09,210.3669 C268.6,212.6669 274.42,214.8669 280,216.5569 C351.75,238.3169 387.77,199.3369 446,246.5569 C464.87,261.8669 471.9428,283.778 475.4228,302.488" fill="none" id="Ready-to-Running" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="476.52,308.3869,478.8068,298.8072,475.6057,303.4712,470.9417,300.2701,476.52,308.3869" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="139.3247" x="468" y="259.6238">Scheduler dispatches</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="98.5728" x="488.376" y="274.7566">(CPU assigned)</text></g><!--link Running to Ready--><g class="link" data-entity-1="Running" data-entity-2="Ready" data-source-line="14" data-uid="lnk6" id="link_Running_Ready"><path d="M444.72,315.9269 C436.07,313.2569 426.75,310.6069 418,308.5569 C376.59,298.8769 256.61,310.9069 229,278.5569 C214.59,261.6769 218.4064,240.6135 225.1164,222.4935" fill="none" id="Running-to-Ready" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="227.2,216.8669,220.3236,223.9177,225.4637,221.5557,227.8257,226.6958,227.2,216.8669" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="207.2383" x="230" y="259.6238">Timeslice expired / Preempted /</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="31.4146" x="317.9119" y="274.7566">Yield</text></g><!--link Running to Blocked--><g class="link" data-entity-1="Running" data-entity-2="Blocked" data-source-line="15" data-uid="lnk7" id="link_Running_Blocked"><path d="M444.62,340.7969 C435.97,343.4769 426.68,346.2369 418,348.5569 C359.47,364.2469 338.06,349.2969 285,378.5569 C257.11,393.9369 236.1384,417.0544 221.5484,435.7744" fill="none" id="Running-to-Blocked" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="217.86,440.5069,226.5475,435.8671,220.9336,436.5632,220.2376,430.9493,217.86,440.5069" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="145.2471" x="286" y="391.6238">Waiting for I/O / Lock /</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="112.4678" x="302.3896" y="406.7566">Event / Sleep call</text></g><!--link Blocked to Ready--><g class="link" data-entity-1="Blocked" data-entity-2="Ready" data-source-line="17" data-uid="lnk8" id="link_Blocked_Ready"><path d="M200.71,440.5169 C196.28,411.7269 189.66,355.6969 196,308.5569 C199.81,280.2469 203.13,273.3769 213,246.5569 C216.71,236.4869 219.0476,231.0286 223.4076,222.0986" fill="none" id="Blocked-to-Ready" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="226.04,216.7069,218.4969,223.0394,223.8463,221.1999,225.6858,226.5494,226.04,216.7069" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="195.2095" x="214.5068" y="325.6238">Event occurs / I/O completes /</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="230.2231" x="197" y="340.7566">Lock acquired / Sleep timer expires</text></g><!--link Running to Terminated--><g class="link" data-entity-1="Running" data-entity-2="Terminated" data-source-line="19" data-uid="lnk9" id="link_Running_Terminated"><path d="M501.46,349.0469 C529.9,373.7169 574.0683,412.0345 602.3483,436.5745" fill="none" id="Running-to-Terminated" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="606.88,440.5069,602.704,431.5872,603.1036,437.2299,597.4609,437.6294,606.88,440.5069" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="176.3188" x="572" y="391.6238">Thread finishes execution /</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="79.644" x="620.3374" y="406.7566">Exits / Killed</text></g><!--link Terminated to *end*--><g class="link" data-entity-1="Terminated" data-entity-2=".end." data-source-line="24" data-uid="lnk11" id="link_Terminated_.end."><path d="M674.86,460.6969 C728.96,460.6969 809.39,460.6969 839.9,460.6969" fill="none" id="Terminated-to-*end*" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="845.9,460.6969,836.9,456.6969,840.9,460.6969,836.9,464.6969,845.9,460.6969" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="135.9858" x="692.72" y="453.7638">Resources reclaimed</text></g><!--SRC=[fLDDJnmn3BtdL_YsK9Lovu1KAbIrNHR4GYl4SaWJxwxLJ3B4dXRww-jaib-zLRqva_UUNvuzGX8GhkTmjyveFSp52Z8SVSI8cHnS9O_XsAp98s3NoojuP9Uf5qhHS47337-rwbObNZVr42F5LJjTXEH-e6-dEymTHQsyCOzldk3al8Z06Tpav90Pd9efFgIwCkNoH45LNs7DB4KIie5-et-xYBbUIe8yH6D6Q2MDHfGsTslqGy0CdhYteaTUnACFD_TWcMaLqHyhi-4F6bA77CXf22yzPVHmgbwn95BgHNmW3Fw0sbwiv6zMRUhNPShmwVHQgLEzAgpBdnX5p_E0s8Ep8HYpuUst7t79kI6pmek8IrqVi6IaEbNFkkUXMHlrH4tdPfWFtxKRm2xDfSR9ceWoq0rbljNY2qdf-OL2q75DO5hdaxfExxqgEm79DZ8L1fVyzyGdIcYJ-AlfPjAo-RXhKbdR6Fw9P_QmoYoxTQO6E0rPMQ1kWzLKTErYqZtCj5fhhijjq9-_NaqORkzdi_SNqqiOjpKj1IDqjY-lMqJzMKQuZhFKBTQAvNUZyFSaahgglDs-_zV-0m00]--></g></svg>

<h1 id="Java-线程的操作"><a href="#Java-线程的操作" class="headerlink" title="Java 线程的操作"></a>Java 线程的操作</h1><p>主要涉及:</p>
<ul>
<li><code>java.lang.Thread</code> 线程的核心方法</li>
<li><code>java.lang.Object</code> 中与线程协作相关的方法</li>
</ul>
<h2 id="启动与执行"><a href="#启动与执行" class="headerlink" title="启动与执行"></a>启动与执行</h2><ul>
<li><p><strong><code>void start()</code></strong></p>
<ul>
<li><strong>作用</strong>: 启动一个新线程。JVM 会为此线程分配资源（包括创建一个对应的 OS 内核线程），并使其进入<code>RUNNABLE</code>状态，等待 CPU 调度。一旦调度，新线程会自动调用该<code>Thread</code>对象的<code>run()</code>方法。</li>
<li><strong>特点</strong>: 一个<code>Thread</code>对象的<code>start()</code>方法只能被调用一次。多次调用会抛出<code>IllegalThreadStateException</code>。</li>
<li><strong>状态转换</strong>: <code>NEW</code> -&gt; <code>RUNNABLE</code></li>
</ul>
</li>
<li><p><strong><code>void run()</code></strong></p>
<ul>
<li><strong>作用</strong>: 包含了线程要执行的具体任务逻辑。这个方法本身不创建新线程。</li>
<li><strong>调用方式</strong>:<ul>
<li>由<code>start()</code>方法在新线程中隐式调用。</li>
<li>如果直接调用<code>thread.run()</code>，则任务会在当前调用线程中同步执行，不会创建新线程。</li>
</ul>
</li>
</ul>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentStyleType="text/css" data-diagram-type="SEQUENCE" height="481px" preserveAspectRatio="none" style="width:871px;height:481px;background:#FFFFFF;" version="1.1" viewBox="0 0 871 481" width="871px" zoomAndPan="magnify"><title>Thread Start vs Run</title><defs/><g><text fill="#000000" font-family="sans-serif" font-size="14" font-weight="bold" lengthAdjust="spacing" textLength="157.999" x="355.7251" y="27.9951">Thread Start vs Run</text><g><title>Thread t</title><rect fill="#FFFFFF" height="116.5313" style="stroke:#181818;stroke-width:1;" width="10" x="226.5674" y="178.8594"/></g><g><title>Thread t</title><rect fill="#FFFFFF" height="29.1328" style="stroke:#181818;stroke-width:1;" width="10" x="226.5674" y="353.6563"/></g><g><title>New Execution Thread</title><rect fill="#FFFFFF" height="58.2656" style="stroke:#181818;stroke-width:1;" width="10" x="666.5391" y="324.5234"/></g><g><title>User</title><rect fill="#000000" fill-opacity="0.00000" height="282.1953" width="8" x="19.9551" y="118.5938"/><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="23" x2="23" y1="118.5938" y2="400.7891"/></g><g><title>Thread t</title><rect fill="#000000" fill-opacity="0.00000" height="282.1953" width="8" x="227.5674" y="118.5938"/><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="230.9678" x2="230.9678" y1="118.5938" y2="400.7891"/></g><g><title>JVM</title><rect fill="#000000" fill-opacity="0.00000" height="282.1953" width="8" x="387.9893" y="118.5938"/><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="391.0967" x2="391.0967" y1="118.5938" y2="400.7891"/></g><g><title>OS</title><rect fill="#000000" fill-opacity="0.00000" height="282.1953" width="8" x="554.6719" y="118.5938"/><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="557.7188" x2="557.7188" y1="118.5938" y2="400.7891"/></g><g><title>New Execution Thread</title><rect fill="#000000" fill-opacity="0.00000" height="282.1953" width="8" x="667.5391" y="118.5938"/><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="670.625" x2="670.625" y1="118.5938" y2="400.7891"/></g><g><title>Runnable</title><rect fill="#000000" fill-opacity="0.00000" height="282.1953" width="8" x="821.2915" y="118.5938"/><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="825.1338" x2="825.1338" y1="118.5938" y2="400.7891"/></g><g class="participant participant-head" data-participant="User"><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="31.9102" x="5" y="115.292">User</text><ellipse cx="23.9551" cy="50.7969" fill="#E2E2F0" rx="8" ry="8" style="stroke:#181818;stroke-width:0.5;"/><path d="M23.9551,58.7969 L23.9551,85.7969 M10.9551,66.7969 L36.9551,66.7969 M23.9551,85.7969 L10.9551,100.7969 M23.9551,85.7969 L36.9551,100.7969" fill="none" style="stroke:#181818;stroke-width:0.5;"/></g><g class="participant participant-tail" data-participant="User"><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="31.9102" x="5" y="412.7842">User</text><ellipse cx="23.9551" cy="424.5859" fill="#E2E2F0" rx="8" ry="8" style="stroke:#181818;stroke-width:0.5;"/><path d="M23.9551,432.5859 L23.9551,459.5859 M10.9551,440.5859 L36.9551,440.5859 M23.9551,459.5859 L10.9551,474.5859 M23.9551,459.5859 L36.9551,474.5859" fill="none" style="stroke:#181818;stroke-width:0.5;"/></g><g class="participant participant-head" data-participant="T"><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="73.1992" x="194.9678" y="87.2969"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="59.1992" x="201.9678" y="107.292">Thread t</text></g><g class="participant participant-tail" data-participant="T"><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="73.1992" x="194.9678" y="399.7891"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="59.1992" x="201.9678" y="419.7842">Thread t</text></g><g class="participant participant-head" data-participant="JVM"><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="39.7852" x="372.0967" y="87.2969"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="25.7852" x="379.0967" y="107.292">JVM</text></g><g class="participant participant-tail" data-participant="JVM"><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="39.7852" x="372.0967" y="399.7891"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="25.7852" x="379.0967" y="419.7842">JVM</text></g><g class="participant participant-head" data-participant="OS"><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="33.9063" x="541.7188" y="87.2969"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="19.9063" x="548.7188" y="107.292">OS</text></g><g class="participant participant-tail" data-participant="OS"><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="33.9063" x="541.7188" y="399.7891"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="19.9063" x="548.7188" y="419.7842">OS</text></g><g class="participant participant-head" data-participant="NET"><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="171.8281" x="585.625" y="87.2969"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="157.8281" x="592.625" y="107.292">New Execution Thread</text></g><g class="participant participant-tail" data-participant="NET"><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="171.8281" x="585.625" y="399.7891"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="157.8281" x="592.625" y="419.7842">New Execution Thread</text></g><g class="participant participant-head" data-participant="Runnable"><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="80.3154" x="785.1338" y="87.2969"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="66.3154" x="792.1338" y="107.292">Runnable</text></g><g class="participant participant-tail" data-participant="Runnable"><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="80.3154" x="785.1338" y="399.7891"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="66.3154" x="792.1338" y="419.7842">Runnable</text></g><g><title>Thread t</title><rect fill="#FFFFFF" height="116.5313" style="stroke:#181818;stroke-width:1;" width="10" x="226.5674" y="178.8594"/></g><g><title>Thread t</title><rect fill="#FFFFFF" height="29.1328" style="stroke:#181818;stroke-width:1;" width="10" x="226.5674" y="353.6563"/></g><g><title>New Execution Thread</title><rect fill="#FFFFFF" height="58.2656" style="stroke:#181818;stroke-width:1;" width="10" x="666.5391" y="324.5234"/></g><g class="message" data-participant-1="User" data-participant-2="T"><polygon fill="#181818" points="219.5674,145.7266,229.5674,149.7266,219.5674,153.7266,223.5674,149.7266" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="23.9551" x2="225.5674" y1="149.7266" y2="149.7266"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="144.7773" x="30.9551" y="144.6606">new Thread(runnable)</text></g><g class="message" data-participant-1="User" data-participant-2="T"><polygon fill="#181818" points="214.5674,174.8594,224.5674,178.8594,214.5674,182.8594,218.5674,178.8594" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="23.9551" x2="220.5674" y1="178.8594" y2="178.8594"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="49.6514" x="30.9551" y="173.7935">t.start()</text></g><g class="message" data-participant-1="T" data-participant-2="JVM"><polygon fill="#181818" points="379.9893,203.9922,389.9893,207.9922,379.9893,211.9922,383.9893,207.9922" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="236.5674" x2="385.9893" y1="207.9922" y2="207.9922"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="131.4219" x="243.5674" y="202.9263">Request new thread</text></g><g class="message" data-participant-1="JVM" data-participant-2="OS"><polygon fill="#181818" points="546.6719,233.125,556.6719,237.125,546.6719,241.125,550.6719,237.125" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="391.9893" x2="552.6719" y1="237.125" y2="237.125"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="135.3638" x="398.9893" y="232.0591">Create kernel thread</text></g><g class="message" data-participant-1="OS" data-participant-2="JVM"><polygon fill="#181818" points="402.9893,262.2578,392.9893,266.2578,402.9893,270.2578,398.9893,266.2578" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;stroke-dasharray:2.0,2.0;" x1="396.9893" x2="557.6719" y1="266.2578" y2="266.2578"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="142.6826" x="408.9893" y="261.1919">Kernel thread created</text></g><g class="message" data-participant-1="JVM" data-participant-2="NET"><polygon fill="#181818" points="659.5391,291.3906,669.5391,295.3906,659.5391,299.3906,663.5391,295.3906" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="391.9893" x2="665.5391" y1="295.3906" y2="295.3906"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="97.7158" x="398.9893" y="290.3247">Execute t.run()</text></g><g class="message" data-participant-1="NET" data-participant-2="Runnable"><polygon fill="#181818" points="813.2915,320.5234,823.2915,324.5234,813.2915,328.5234,817.2915,324.5234" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="676.5391" x2="819.2915" y1="324.5234" y2="324.5234"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="129.7524" x="683.5391" y="319.4575">run() logic executes</text></g><g class="message" data-participant-1="User" data-participant-2="T"><polygon fill="#181818" points="214.5674,349.6563,224.5674,353.6563,214.5674,357.6563,218.5674,353.6563" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="23.9551" x2="220.5674" y1="353.6563" y2="353.6563"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="183.6123" x="30.9551" y="348.5903">t.run() (Direct Call Example)</text></g><g class="message" data-participant-1="T" data-participant-2="Runnable"><polygon fill="#181818" points="813.2915,378.7891,823.2915,382.7891,813.2915,386.7891,817.2915,382.7891" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="231.5674" x2="819.2915" y1="382.7891" y2="382.7891"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="244.3086" x="238.5674" y="377.7231">run() logic executes in current thread</text></g><!--SRC=[XP4nKiCm44LxdsB7bLE40r3GX3Gmn3EsGY-K7T0WP2Ej4uxFbnoCHKFbqVwdtRUoM75CjNeBh4_KYmv2vqZTvEjA6na27IE7QaJT6ZjgBmiiDUb8gimUdfzo6TyoQFjSR_koVE0BxR_OJ687JtFd31xsgghIRDhUaQ9RyY3dl0cJz_h5yQO0v2Oc_MQJnErP2qDEfHGoo3l-d3XARYIvKPK2v6sFU8SAhhnpyEn-02JRfS7ZEYAJ-QK7V87Cgp1Su0YJ4wzS4WAokze3pn2vuTKQulbg_BLFJr0kEFFDlGriX7RQEKpK7sDwYhzB_pE6h2SpXS3u2zTb2zdL0HxV]--></g></svg></li>
</ul>
<h2 id="线程暂停与让步"><a href="#线程暂停与让步" class="headerlink" title="线程暂停与让步"></a>线程暂停与让步</h2><ul>
<li><strong><code>static void sleep(long millis)</code> &#x2F; <code>static void sleep(long millis, int nanos)</code></strong><ul>
<li><strong>作用</strong>: 使<strong>当前</strong>正在执行的线程暂停指定的毫秒&#x2F;纳秒数。</li>
<li><strong>锁行为</strong>: <strong>不释放</strong>当前线程持有的任何监视器锁。</li>
<li><strong>状态转换</strong>: <code>RUNNABLE</code> -&gt; <code>TIMED_WAITING</code> -&gt; (时间到&#x2F;被中断) -&gt; <code>RUNNABLE</code></li>
<li><strong>中断</strong>: 如果在睡眠期间被中断，会抛出<code>InterruptedException</code>并清除中断状态。</li>
</ul>
</li>
<li><strong><code>static void yield()</code></strong><ul>
<li><strong>作用</strong>: 一个<strong>提示性</strong>的方法，建议线程调度器可以将 CPU 让给其他具有相同或更高优先级的线程。</li>
<li><strong>锁行为</strong>: <strong>不释放</strong>锁。</li>
<li><strong>行为保证</strong>: <strong>不保证</strong>调度器一定会采纳这个建议。线程可能立即再次被调度。</li>
<li><strong>状态转换</strong>: 可能从<code>RUNNING</code>(OS) -&gt; <code>READY</code>(OS) (仍在 JVM 的<code>RUNNABLE</code>内)。</li>
</ul>
</li>
</ul>
<h2 id="线程等待与加入"><a href="#线程等待与加入" class="headerlink" title="线程等待与加入"></a>线程等待与加入</h2><ul>
<li><strong><code>final void join()</code> &#x2F; <code>final void join(long millis)</code> &#x2F; <code>final void join(long millis, int nanos)</code></strong><ul>
<li><strong>作用</strong>: 调用<code>t.join()</code>的线程（如主线程）会等待线程<code>t</code>执行完成（即<code>t</code>进入<code>TERMINATED</code>状态）或超时。</li>
<li><strong>锁行为</strong>: 调用<code>join()</code>的线程在等待期间<strong>继续持有它自己的锁</strong>。<code>join()</code>本身不涉及锁的释放。</li>
<li><strong>状态转换 (调用者)</strong>: <code>RUNNABLE</code> -&gt; <code>WAITING</code> &#x2F; <code>TIMED_WAITING</code> -&gt; (<code>t</code>结束后) -&gt; <code>RUNNABLE</code></li>
<li><strong>中断</strong>: 如果调用<code>join()</code>的线程在等待期间被中断，<code>join()</code>方法会抛出<code>InterruptedException</code>。</li>
</ul>
</li>
</ul>
<h2 id="线程中断-Interruption"><a href="#线程中断-Interruption" class="headerlink" title="线程中断 (Interruption)"></a>线程中断 (Interruption)</h2><ul>
<li><strong><code>void interrupt()</code> (实例方法)</strong><ul>
<li><strong>作用</strong>: 设置目标线程的<strong>中断状态位</strong>为<code>true</code>。</li>
<li><strong>对阻塞线程的影响</strong>: 如果目标线程正因<code>wait()</code>, <code>join()</code>, <code>sleep()</code>而阻塞，则这些方法会立即抛出<code>InterruptedException</code>，并且 JVM 会<strong>清除</strong>该线程的中断状态。</li>
</ul>
</li>
<li><strong><code>boolean isInterrupted()</code> (实例方法)</strong><ul>
<li><strong>作用</strong>: 检查<strong>指定线程</strong>的中断状态位，返回其当前值。</li>
<li><strong>副作用</strong>: <strong>不改变</strong>中断状态位。</li>
</ul>
</li>
<li><strong><code>static boolean interrupted()</code> (静态方法)</strong><ul>
<li><strong>作用</strong>: 检查<strong>当前正在执行的线程</strong>的中断状态位，返回其当前值。</li>
<li><strong>副作用</strong>: <strong>会清除</strong>当前线程的中断状态位（如果为<code>true</code>，则返回<code>true</code>并重置为<code>false</code>）。</li>
</ul>
</li>
<li><strong>处理<code>InterruptedException</code></strong>:<ul>
<li>捕获时，中断状态已被清除。</li>
<li>最佳实践: 通常在<code>catch</code>块中调用<code>Thread.currentThread().interrupt()</code>来恢复中断状态，以便上层代码或循环能感知到中断。</li>
<li>设计可中断任务: 在循环中定期检查<code>isInterrupted()</code>或<code>Thread.interrupted()</code>，并响应中断。</li>
</ul>
</li>
</ul>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentStyleType="text/css" data-diagram-type="SEQUENCE" height="558px" preserveAspectRatio="none" style="width:744px;height:558px;background:#FFFFFF;" version="1.1" viewBox="0 0 744 558" width="744px" zoomAndPan="magnify"><defs/><g><rect fill="none" height="240.0625" style="stroke:#000000;stroke-width:1.5;" width="728.3057" x="10" y="266.0938"/><g><title>OtherThread</title><rect fill="#000000" fill-opacity="0.00000" height="486.8594" width="8" x="67.5054" y="36.2969"/><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="71" x2="71" y1="36.2969" y2="523.1563"/></g><g><title>TargetThread</title><rect fill="#000000" fill-opacity="0.00000" height="486.8594" width="8" x="205.9028" y="36.2969"/><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="209.335" x2="209.335" y1="36.2969" y2="523.1563"/></g><g><title>JVMInternals</title><rect fill="#000000" fill-opacity="0.00000" height="486.8594" width="8" x="673.665" y="36.2969"/><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="677.0244" x2="677.0244" y1="36.2969" y2="523.1563"/></g><g class="participant participant-head" data-participant="OtherThread"><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="103.0107" x="20" y="5"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="89.0107" x="27" y="24.9951">OtherThread</text></g><g class="participant participant-tail" data-participant="OtherThread"><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="103.0107" x="20" y="522.1563"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="89.0107" x="27" y="542.1514">OtherThread</text></g><g class="participant participant-head" data-participant="TargetThread"><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="109.1357" x="155.335" y="5"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="95.1357" x="162.335" y="24.9951">TargetThread</text></g><g class="participant participant-tail" data-participant="TargetThread"><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="109.1357" x="155.335" y="522.1563"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="95.1357" x="162.335" y="542.1514">TargetThread</text></g><g class="participant participant-head" data-participant="JVMInternals"><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="101.2813" x="627.0244" y="5"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="87.2813" x="634.0244" y="24.9951">JVMInternals</text></g><g class="participant participant-tail" data-participant="JVMInternals"><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="101.2813" x="627.0244" y="522.1563"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="87.2813" x="634.0244" y="542.1514">JVMInternals</text></g><g class="message" data-participant-1="OtherThread" data-participant-2="TargetThread"><line style="stroke:#181818;stroke-width:1;" x1="207.9028" x2="197.9028" y1="67.4297" y2="63.4297"/><line style="stroke:#181818;stroke-width:1;" x1="207.9028" x2="197.9028" y1="67.4297" y2="71.4297"/><line style="stroke:#181818;stroke-width:1;" x1="71.5054" x2="208.9028" y1="67.4297" y2="67.4297"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="114.3975" x="78.5054" y="62.3638">thread.interrupt()</text></g><g class="message" data-participant-1="JVMInternals" data-participant-2="TargetThread"><line style="stroke:#181818;stroke-width:1;" x1="210.9028" x2="220.9028" y1="96.5625" y2="92.5625"/><line style="stroke:#181818;stroke-width:1;" x1="210.9028" x2="220.9028" y1="96.5625" y2="100.5625"/><line style="stroke:#181818;stroke-width:1;" x1="209.9028" x2="676.665" y1="96.5625" y2="96.5625"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="174.9858" x="226.9028" y="91.4966">Set interrupt_status = true</text></g><g class="message" data-participant-1="TargetThread" data-participant-2="TargetThread"><line style="stroke:#181818;stroke-width:1;" x1="209.9028" x2="251.9028" y1="125.6953" y2="125.6953"/><line style="stroke:#181818;stroke-width:1;" x1="251.9028" x2="251.9028" y1="125.6953" y2="138.6953"/><line style="stroke:#181818;stroke-width:1;" x1="209.9028" x2="251.9028" y1="138.6953" y2="138.6953"/><line style="stroke:#181818;stroke-width:1;" x1="210.9028" x2="220.9028" y1="138.6953" y2="134.6953"/><line style="stroke:#181818;stroke-width:1;" x1="210.9028" x2="220.9028" y1="138.6953" y2="142.6953"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="256.4644" x="216.9028" y="120.6294">boolean status = thread.isInterrupted()</text></g><path d="M214,151.6953 L214,176.6953 L511,176.6953 L511,161.6953 L501,151.6953 L214,151.6953" fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M501,151.6953 L501,161.6953 L511,161.6953 L501,151.6953" fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="276.9927" x="220" y="168.7622">status=true, interrupt_status remains true</text><g class="message" data-participant-1="TargetThread" data-participant-2="TargetThread"><line style="stroke:#181818;stroke-width:1;" x1="209.9028" x2="251.9028" y1="202.9609" y2="202.9609"/><line style="stroke:#181818;stroke-width:1;" x1="251.9028" x2="251.9028" y1="202.9609" y2="215.9609"/><line style="stroke:#181818;stroke-width:1;" x1="209.9028" x2="251.9028" y1="215.9609" y2="215.9609"/><line style="stroke:#181818;stroke-width:1;" x1="210.9028" x2="220.9028" y1="215.9609" y2="211.9609"/><line style="stroke:#181818;stroke-width:1;" x1="210.9028" x2="220.9028" y1="215.9609" y2="219.9609"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="303.5195" x="216.9028" y="197.895">boolean status_cleared = Thread.interrupted()</text></g><path d="M214,228.9609 L214,253.9609 L577,253.9609 L577,238.9609 L567,228.9609 L214,228.9609" fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M567,228.9609 L567,238.9609 L577,238.9609 L567,228.9609" fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="342.2466" x="220" y="246.0278">status_cleared=true, interrupt_status becomes false</text><path d="M10,266.0938 L74.4429,266.0938 L74.4429,273.2266 L64.4429,283.2266 L10,283.2266 L10,266.0938" fill="#EEEEEE" style="stroke:#000000;stroke-width:1.5;"/><rect fill="none" height="240.0625" style="stroke:#000000;stroke-width:1.5;" width="728.3057" x="10" y="266.0938"/><text fill="#000000" font-family="sans-serif" font-size="13" font-weight="bold" lengthAdjust="spacing" textLength="19.4429" x="25" y="279.1606">alt</text><text fill="#000000" font-family="sans-serif" font-size="11" font-weight="bold" lengthAdjust="spacing" textLength="248.7783" x="89.4429" y="278.3042">[TargetThread is in sleep()/wait()/join()]</text><g class="message" data-participant-1="TargetThread" data-participant-2="JVMInternals"><line style="stroke:#181818;stroke-width:1;" x1="675.665" x2="665.665" y1="304.3594" y2="300.3594"/><line style="stroke:#181818;stroke-width:1;" x1="675.665" x2="665.665" y1="304.3594" y2="308.3594"/><line style="stroke:#181818;stroke-width:1;" x1="209.9028" x2="676.665" y1="304.3594" y2="304.3594"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="124.5474" x="216.9028" y="299.2935">sleep()/wait()/join()</text></g><g class="message" data-participant-1="OtherThread" data-participant-2="TargetThread"><line style="stroke:#181818;stroke-width:1;" x1="207.9028" x2="197.9028" y1="333.4922" y2="329.4922"/><line style="stroke:#181818;stroke-width:1;" x1="207.9028" x2="197.9028" y1="333.4922" y2="337.4922"/><line style="stroke:#181818;stroke-width:1;" x1="71.5054" x2="208.9028" y1="333.4922" y2="333.4922"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="114.3975" x="78.5054" y="328.4263">thread.interrupt()</text></g><g class="message" data-participant-1="JVMInternals" data-participant-2="TargetThread"><line style="stroke:#181818;stroke-width:1;" x1="210.9028" x2="220.9028" y1="362.625" y2="358.625"/><line style="stroke:#181818;stroke-width:1;" x1="210.9028" x2="220.9028" y1="362.625" y2="366.625"/><line style="stroke:#181818;stroke-width:1;" x1="209.9028" x2="676.665" y1="362.625" y2="362.625"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="272.105" x="226.9028" y="357.5591">Set interrupt_status = true (momentarily)</text></g><g class="message" data-participant-1="JVMInternals" data-participant-2="TargetThread"><line style="stroke:#181818;stroke-width:1;" x1="210.9028" x2="220.9028" y1="391.7578" y2="387.7578"/><line style="stroke:#181818;stroke-width:1;" x1="210.9028" x2="220.9028" y1="391.7578" y2="395.7578"/><line style="stroke:#181818;stroke-width:1;" x1="209.9028" x2="676.665" y1="391.7578" y2="391.7578"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="191.8833" x="226.9028" y="386.6919">Clear interrupt_status = false</text></g><g class="message" data-participant-1="TargetThread" data-participant-2="JVMInternals"><line style="stroke:#181818;stroke-width:1;" x1="675.665" x2="665.665" y1="420.8906" y2="416.8906"/><line style="stroke:#181818;stroke-width:1;" x1="675.665" x2="665.665" y1="420.8906" y2="424.8906"/><line style="stroke:#181818;stroke-width:1;stroke-dasharray:2.0,2.0;" x1="209.9028" x2="676.665" y1="420.8906" y2="420.8906"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="186.0752" x="216.9028" y="415.8247">throws InterruptedException</text></g><g class="message" data-participant-1="TargetThread" data-participant-2="TargetThread"><line style="stroke:#181818;stroke-width:1;" x1="209.9028" x2="251.9028" y1="450.0234" y2="450.0234"/><line style="stroke:#181818;stroke-width:1;" x1="251.9028" x2="251.9028" y1="450.0234" y2="463.0234"/><line style="stroke:#181818;stroke-width:1;" x1="209.9028" x2="251.9028" y1="463.0234" y2="463.0234"/><line style="stroke:#181818;stroke-width:1;" x1="210.9028" x2="220.9028" y1="463.0234" y2="459.0234"/><line style="stroke:#181818;stroke-width:1;" x1="210.9028" x2="220.9028" y1="463.0234" y2="467.0234"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="453.7622" x="216.9028" y="444.9575">catch(InterruptedException e) { Thread.currentThread().interrupt(); }</text></g><path d="M214,476.0234 L214,501.0234 L472,501.0234 L472,486.0234 L462,476.0234 L214,476.0234" fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M462,476.0234 L462,486.0234 L472,486.0234 L462,476.0234" fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="237.5674" x="220" y="493.0903">interrupt_status becomes true again</text><!--SRC=[lL8zJyCm4DtzAsvC9A1xKRiWXY8X1YBMwkfS6wF4ZiuN5OJuxpWj0QT92YnCaUDxxzw7QsGnsjHe1Hwa8CuA9inL7VtFa7Sa8nTtJ_ShAyGMIwzK1BzSBcFG7EJmlJBjD3Ur9AcAmOFvHnBu6bvxGMayB42u8QNYqG5ourn9QE4RyxdQhpe-oiDwwuI0pQuGS5leSnonYtRRnL06KuN6-h-BMUjmOCg3gEmaZrzAwXYcf6r8kueyR4EcGHkM_VB0-801NnBLIJhRemb5p9wTiM7xYP6udla4v9yQXwGAhgmWc_Br1vgRDg0necCaFPC3bq6pstk87ihjYwPQZBFdUzOekaZ6S40fl7LrwuOv-3YUaZGEvnhUp_O_MVKX8Do55waKsVm3]--></g></svg>

<h2 id="线程间协作-Object类的方法-必须在synchronized块中由锁对象调用"><a href="#线程间协作-Object类的方法-必须在synchronized块中由锁对象调用" class="headerlink" title="线程间协作 (Object类的方法 - 必须在synchronized块中由锁对象调用)"></a>线程间协作 (<code>Object</code>类的方法 - 必须在<code>synchronized</code>块中由锁对象调用)</h2><ul>
<li><p><strong><code>final void wait()</code> &#x2F; <code>final void wait(long timeout)</code> &#x2F; <code>final void wait(long timeout, int nanos)</code></strong></p>
<ul>
<li><strong>作用</strong>: 当前线程（必须持有该对象的锁）<strong>释放该对象的锁</strong>，并进入该对象的条件队列 (WaitSet) 中等待。</li>
<li><strong>状态转换</strong>: <code>RUNNABLE</code> -&gt; <code>WAITING</code> &#x2F; <code>TIMED_WAITING</code> -&gt; (被唤醒&#x2F;超时&#x2F;中断) -&gt; 尝试重获锁 -&gt; <code>BLOCKED</code> (若锁被占) -&gt; <code>RUNNABLE</code> (若获锁)</li>
<li><strong>中断</strong>: 如果在等待期间被中断，会抛出<code>InterruptedException</code>并清除中断状态。</li>
<li><strong>虚假唤醒</strong>: 必须在<code>while(condition)</code>循环中调用<code>wait()</code>。</li>
</ul>
</li>
<li><p><strong><code>final void notify()</code></strong></p>
<ul>
<li><strong>作用</strong>: 从该对象的条件队列中<strong>选择一个</strong>正在等待的线程并唤醒它。</li>
<li><strong>锁行为</strong>: 调用<code>notify()</code>的线程在执行完<code>notify()</code>后，并<strong>不会立即释放它持有的锁</strong>。锁在<code>synchronized</code>块结束时释放。</li>
<li><strong>唤醒的线程</strong>: 进入<code>BLOCKED</code>状态，等待获取锁。</li>
</ul>
</li>
<li><p><strong><code>final void notifyAll()</code></strong></p>
<ul>
<li><strong>作用</strong>: 唤醒该对象条件队列中<strong>所有</strong>正在等待的线程。</li>
<li><strong>锁行为</strong>: 同<code>notify()</code>。</li>
<li><strong>唤醒的线程</strong>: 全部进入<code>BLOCKED</code>状态，竞争锁。</li>
</ul>
</li>
</ul>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentStyleType="text/css" data-diagram-type="SEQUENCE" height="619px" preserveAspectRatio="none" style="width:616px;height:619px;background:#FFFFFF;" version="1.1" viewBox="0 0 616 619" width="616px" zoomAndPan="magnify"><title>Object wait()/notify() Interaction</title><defs/><g><text fill="#000000" font-family="sans-serif" font-size="14" font-weight="bold" lengthAdjust="spacing" textLength="258.918" x="177.1724" y="27.9951">Object wait()/notify() Interaction</text><g><title>LockObject</title><rect fill="#FFFFFF" height="93.3984" style="stroke:#181818;stroke-width:1;" width="10" x="348.5884" y="135.7266"/></g><g><title>LockObject</title><rect fill="#FF0000" height="128.5313" style="stroke:#181818;stroke-width:1;" width="10" x="348.5884" y="258.2578"/></g><g><title>LockObject</title><rect fill="#00FF00" height="34.1328" style="stroke:#181818;stroke-width:1;" width="10" x="348.5884" y="489.1875"/></g><g><title>ThreadA</title><rect fill="#000000" fill-opacity="0.00000" height="436.7266" width="8" x="37.4185" y="104.5938"/><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="41" x2="41" y1="104.5938" y2="541.3203"/></g><g><title>ThreadB</title><rect fill="#000000" fill-opacity="0.00000" height="436.7266" width="8" x="120.269" y="104.5938"/><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="123.8369" x2="123.8369" y1="104.5938" y2="541.3203"/></g><g><title>LockObject</title><rect fill="#000000" fill-opacity="0.00000" height="436.7266" width="8" x="349.5884" y="104.5938"/><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="352.7056" x2="352.7056" y1="104.5938" y2="541.3203"/></g><g><title>LockObject.WaitSet</title><rect fill="#000000" fill-opacity="0.00000" height="436.7266" width="8" x="526.7598" y="104.5938"/><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="530.2568" x2="530.2568" y1="104.5938" y2="541.3203"/></g><g class="participant participant-head" data-participant="TA"><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="72.8369" x="5" y="73.2969"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="58.8369" x="12" y="93.292">ThreadA</text></g><g class="participant participant-tail" data-participant="TA"><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="72.8369" x="5" y="540.3203"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="58.8369" x="12" y="560.3154">ThreadA</text></g><g class="participant participant-head" data-participant="TB"><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="72.8643" x="87.8369" y="73.2969"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="58.8643" x="94.8369" y="93.292">ThreadB</text></g><g class="participant participant-tail" data-participant="TB"><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="72.8643" x="87.8369" y="540.3203"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="58.8643" x="94.8369" y="560.3154">ThreadB</text></g><g class="participant participant-head" data-participant="Lock"><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="77.7656" x="311.7056" y="101.292">LockObject</text><path d="M335.5884,52.2969 C335.5884,42.2969 353.5884,42.2969 353.5884,42.2969 C353.5884,42.2969 371.5884,42.2969 371.5884,52.2969 L371.5884,78.2969 C371.5884,88.2969 353.5884,88.2969 353.5884,88.2969 C353.5884,88.2969 335.5884,88.2969 335.5884,78.2969 L335.5884,52.2969" fill="#E2E2F0" style="stroke:#181818;stroke-width:1.5;"/><path d="M335.5884,52.2969 C335.5884,62.2969 353.5884,62.2969 353.5884,62.2969 C353.5884,62.2969 371.5884,62.2969 371.5884,52.2969" fill="none" style="stroke:#181818;stroke-width:1.5;"/></g><g class="participant participant-tail" data-participant="Lock"><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="77.7656" x="311.7056" y="553.3154">LockObject</text><path d="M335.5884,566.6172 C335.5884,556.6172 353.5884,556.6172 353.5884,556.6172 C353.5884,556.6172 371.5884,556.6172 371.5884,566.6172 L371.5884,592.6172 C371.5884,602.6172 353.5884,602.6172 353.5884,602.6172 C353.5884,602.6172 335.5884,602.6172 335.5884,592.6172 L335.5884,566.6172" fill="#E2E2F0" style="stroke:#181818;stroke-width:1.5;"/><path d="M335.5884,566.6172 C335.5884,576.6172 353.5884,576.6172 353.5884,576.6172 C353.5884,576.6172 371.5884,576.6172 371.5884,566.6172" fill="none" style="stroke:#181818;stroke-width:1.5;"/></g><g class="participant participant-head" data-participant="WaitSet"><path d="M457.2568,78.2969 L604.2627,78.2969 C609.2627,78.2969 609.2627,91.4453 609.2627,91.4453 C609.2627,91.4453 609.2627,104.5938 604.2627,104.5938 L457.2568,104.5938 C452.2568,104.5938 452.2568,91.4453 452.2568,91.4453 C452.2568,91.4453 452.2568,78.2969 457.2568,78.2969" fill="#E2E2F0" style="stroke:#181818;stroke-width:0.5;"/><path d="M604.2627,78.2969 C599.2627,78.2969 599.2627,91.4453 599.2627,91.4453 C599.2627,104.5938 604.2627,104.5938 604.2627,104.5938" fill="none" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="137.0059" x="457.2568" y="96.292">LockObject.WaitSet</text></g><g class="participant participant-tail" data-participant="WaitSet"><path d="M457.2568,540.3203 L604.2627,540.3203 C609.2627,540.3203 609.2627,553.4688 609.2627,553.4688 C609.2627,553.4688 609.2627,566.6172 604.2627,566.6172 L457.2568,566.6172 C452.2568,566.6172 452.2568,553.4688 452.2568,553.4688 C452.2568,553.4688 452.2568,540.3203 457.2568,540.3203" fill="#E2E2F0" style="stroke:#181818;stroke-width:0.5;"/><path d="M604.2627,540.3203 C599.2627,540.3203 599.2627,553.4688 599.2627,553.4688 C599.2627,566.6172 604.2627,566.6172 604.2627,566.6172" fill="none" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="137.0059" x="457.2568" y="558.3154">LockObject.WaitSet</text></g><g><title>LockObject</title><rect fill="#FFFFFF" height="93.3984" style="stroke:#181818;stroke-width:1;" width="10" x="348.5884" y="135.7266"/></g><g><title>LockObject</title><rect fill="#FF0000" height="128.5313" style="stroke:#181818;stroke-width:1;" width="10" x="348.5884" y="258.2578"/></g><g><title>LockObject</title><rect fill="#00FF00" height="34.1328" style="stroke:#181818;stroke-width:1;" width="10" x="348.5884" y="489.1875"/></g><g class="message" data-participant-1="TA" data-participant-2="Lock"><polygon fill="#181818" points="336.5884,131.7266,346.5884,135.7266,336.5884,139.7266,340.5884,135.7266" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="41.4185" x2="342.5884" y1="135.7266" y2="135.7266"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="126.3311" x="48.4185" y="130.6606">synchronized(Lock)</text></g><g class="message" data-participant-1="TA" data-participant-2="Lock"><polygon fill="#181818" points="336.5884,160.8594,346.5884,164.8594,336.5884,168.8594,340.5884,164.8594" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="41.4185" x2="342.5884" y1="164.8594" y2="164.8594"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="214.3286" x="48.4185" y="159.7935">while(!condition) { Lock.wait(); }</text></g><path d="M46,177.8594 L46,202.8594 L263,202.8594 L263,187.8594 L253,177.8594 L46,177.8594" fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M253,177.8594 L253,187.8594 L263,187.8594 L253,177.8594" fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="196.8789" x="52" y="194.9263">Releases Lock, enters WaitSet</text><g class="message" data-participant-1="TA" data-participant-2="WaitSet"><line style="stroke:#181818;stroke-width:1;" x1="528.7598" x2="518.7598" y1="229.125" y2="225.125"/><line style="stroke:#181818;stroke-width:1;" x1="528.7598" x2="518.7598" y1="229.125" y2="233.125"/><line style="stroke:#181818;stroke-width:1;stroke-dasharray:2.0,2.0;" x1="41.4185" x2="529.7598" y1="229.125" y2="229.125"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="60.8867" x="48.4185" y="224.0591">(blocked)</text></g><g class="message" data-participant-1="TB" data-participant-2="Lock"><polygon fill="#181818" points="336.5884,254.2578,346.5884,258.2578,336.5884,262.2578,340.5884,258.2578" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="124.269" x2="342.5884" y1="258.2578" y2="258.2578"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="126.3311" x="131.269" y="253.1919">synchronized(Lock)</text></g><g class="message" data-participant-1="TB" data-participant-2="Lock"><polygon fill="#181818" points="336.5884,283.3906,346.5884,287.3906,336.5884,291.3906,340.5884,287.3906" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="124.269" x2="342.5884" y1="287.3906" y2="287.3906"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="124.9727" x="131.269" y="282.3247">// change condition</text></g><g class="message" data-participant-1="TB" data-participant-2="Lock"><polygon fill="#181818" points="336.5884,312.5234,346.5884,316.5234,336.5884,320.5234,340.5884,316.5234" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="124.269" x2="342.5884" y1="316.5234" y2="316.5234"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="200.3193" x="131.269" y="311.4575">Lock.notify() or Lock.notifyAll()</text></g><path d="M129,329.5234 L129,354.5234 L334,354.5234 L334,339.5234 L324,329.5234 L129,329.5234" fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M324,329.5234 L324,339.5234 L334,339.5234 L324,329.5234" fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="184.2788" x="135" y="346.5903">Signals one/all from WaitSet</text><g class="message" data-participant-1="Lock" data-participant-2="Lock"><line style="stroke:#181818;stroke-width:1;" x1="358.5884" x2="400.5884" y1="385.7891" y2="385.7891"/><line style="stroke:#181818;stroke-width:1;" x1="400.5884" x2="400.5884" y1="385.7891" y2="398.7891"/><line style="stroke:#181818;stroke-width:1;" x1="353.5884" x2="400.5884" y1="398.7891" y2="398.7891"/><polygon fill="#181818" points="363.5884,394.7891,353.5884,398.7891,363.5884,402.7891,359.5884,398.7891" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="143.1714" x="365.5884" y="380.7231">TB releases Lock here</text></g><g class="message" data-participant-1="WaitSet" data-participant-2="TA"><line style="stroke:#181818;stroke-width:1;" x1="42.4185" x2="52.4185" y1="422.9219" y2="418.9219"/><line style="stroke:#181818;stroke-width:1;" x1="42.4185" x2="52.4185" y1="422.9219" y2="426.9219"/><line style="stroke:#181818;stroke-width:1;stroke-dasharray:2.0,2.0;" x1="41.4185" x2="529.7598" y1="422.9219" y2="422.9219"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="76.7241" x="58.4185" y="417.856">(awakened)</text></g><g class="message" data-participant-1="TA" data-participant-2="Lock"><polygon fill="#181818" points="341.5884,448.0547,351.5884,452.0547,341.5884,456.0547,345.5884,452.0547" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="41.4185" x2="347.5884" y1="452.0547" y2="452.0547"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="181.7842" x="48.4185" y="446.9888">Attempts to re-acquire Lock</text></g><g class="message" data-participant-1="Lock" data-participant-2="Lock"><line style="stroke:#181818;stroke-width:1;" x1="353.5884" x2="400.5884" y1="476.1875" y2="476.1875"/><line style="stroke:#181818;stroke-width:1;" x1="400.5884" x2="400.5884" y1="476.1875" y2="489.1875"/><line style="stroke:#181818;stroke-width:1;" x1="359.5884" x2="400.5884" y1="489.1875" y2="489.1875"/><polygon fill="#181818" points="369.5884,485.1875,359.5884,489.1875,369.5884,493.1875,365.5884,489.1875" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="128.3369" x="365.5884" y="471.1216">TA re-acquires Lock</text></g><g class="message" data-participant-1="TA" data-participant-2="Lock"><polygon fill="#181818" points="341.5884,519.3203,351.5884,523.3203,341.5884,527.3203,345.5884,523.3203" style="stroke:#181818;stroke-width:1;"/><line style="stroke:#181818;stroke-width:1;" x1="41.4185" x2="347.5884" y1="523.3203" y2="523.3203"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="139.9976" x="48.4185" y="518.2544">// re-checks condition</text></g><!--SRC=[bLBBRi8m4Bpp5TlqaaY5SAOIKd90gbIfKa7gUN4Muc9iS9OYMlNVQpk5FA27vfJipdWU3ajM1D7Byfq4mn4bnqcg3SlLAKxWIJDP52oDZWRWdXrQbaBkK3D4Yz8I5ba4MC4Y-skVr_iyx0jaN6Bb59-DsDIgOUy_0s9_e4DdFNfpfkPKmtxV1m6wo60u3KoOG7NIehH6oqygOZzB0iQR_q2cHg33EfPIKNmdZ2waJvd0LrYDwYOUuJjmN244LgvB1hFo9qpWbHIv8BNp1o3VLEFlB3ISJiypnucNoe6fgAqLr3LNa_9_PeBxsMpidcjsce8eKQy9Bl6kGI7ivRwDRGyofUBaLlxS4UTohL5LO3Ibg1IihDbsuWU1HiYHRBioACdIpHxyxDnPA33q7UCHDwHzUJTkFsEcxOuhOEDaXYZs1sbRv_NCU783Q_rzlMh7Or_kjPohrj55IM9JzThjfVa1]--></g></svg>

<h2 id="其他辅助方法-了解即可"><a href="#其他辅助方法-了解即可" class="headerlink" title="其他辅助方法 (了解即可)"></a>其他辅助方法 (了解即可)</h2><ul>
<li><code>long getId()</code>: 获取线程的唯一 ID。</li>
<li><code>String getName()</code> &#x2F; <code>void setName(String name)</code>: 获取&#x2F;设置线程名称。</li>
<li><code>int getPriority()</code> &#x2F; <code>void setPriority(int newPriority)</code>: 获取&#x2F;设置线程优先级 (1-10, 依赖 OS, 不建议过度依赖)。</li>
<li><code>boolean isAlive()</code>: 线程是否已启动且尚未终止。</li>
<li><code>boolean isDaemon()</code> &#x2F; <code>void setDaemon(boolean on)</code>: 是否为守护线程。守护线程不阻止 JVM 退出。必须在<code>start()</code>前设置。</li>
<li><code>static Thread currentThread()</code>: 获取当前正在执行此代码的线程对象。</li>
<li><code>Thread.State getState()</code>: 获取线程当前状态 (JVM 层面)。</li>
</ul>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>底层</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Lock 接口与 ReentrantLock 深度分析</title>
    <url>/2025/05/25/Java-Threads/Lock-%E6%8E%A5%E5%8F%A3%E4%B8%8E-ReentrantLock-%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="Lock-接口与-ReentrantLock"><a href="#Lock-接口与-ReentrantLock" class="headerlink" title="Lock 接口与 ReentrantLock"></a><code>Lock</code> 接口与 <code>ReentrantLock</code></h1><h2 id="Lock-接口的设计理念与目标"><a href="#Lock-接口的设计理念与目标" class="headerlink" title="Lock 接口的设计理念与目标"></a><code>Lock</code> 接口的设计理念与目标</h2><blockquote>
<p><code>java.util.concurrent.locks</code> 包提供了一套比 <code>synchronized</code> 关键字更高级、更灵活的锁和同步机制。其核心是 <code>Lock</code> 接口和 <code>AbstractQueuedSynchronizer</code> (AQS) 框架。</p>
</blockquote>
<ul>
<li>核心方法:<ul>
<li><code>void lock()</code>: 获取锁。如果锁不可用，则当前线程将被阻塞，直到获取到锁。</li>
<li><code>void lockInterruptibly() throws InterruptedException</code>: 获取锁，但允许在等待获取锁的过程中响应中断。如果当前线程在等待时被中断，则抛出 <code>InterruptedException</code>。</li>
<li><code>boolean tryLock()</code>: 尝试非阻塞地获取锁。如果获取成功，则返回 <code>true</code>；如果锁已被其他线程持有，则立即返回 <code>false</code>，不会阻塞。</li>
<li><code>boolean tryLock(long time, TimeUnit unit) throws InterruptedException</code>: 尝试在给定的超时时间内获取锁。如果在超时时间内获取到锁，返回 true；否则返回 false。等待期间可响应中断。</li>
<li><code>void unlock()</code>: 释放锁。必须在 finally 块中调用，以确保锁一定会被释放。</li>
<li><code>Condition newCondition()</code>: 返回一个绑定到此 Lock 实例的新的 <code>Condition</code> 实例。<code>Condition</code> 提供了类似 <code>Object</code> 监视器方法（wait, notify, notifyAll）的功能，但更灵活（可以有多个条件队列）。</li>
</ul>
</li>
</ul>
<ol>
<li><p><strong>提供比<code>synchronized</code>更灵活、更可控的锁定机制</strong>:</p>
<ul>
<li><code>synchronized</code>是 Java 语言内置的关键字，其行为相对固定（例如，隐式加解锁、不可中断等待、单一条件队列）。</li>
<li><code>Lock</code>接口则将锁的获取和释放操作 API 化，允许开发者在代码层面进行更细致的控制。</li>
</ul>
</li>
<li><p><strong>分离锁的获取与释放</strong>:</p>
<ul>
<li><code>synchronized</code>的锁获取（进入同步块&#x2F;方法）和释放（退出同步块&#x2F;方法）是绑定的，并且是隐式的。</li>
<li><code>Lock</code>接口明确提供了<code>lock()</code>和<code>unlock()</code>方法，开发者需要显式调用。这带来了更大的灵活性（例如，可以在一个方法中获取锁，在另一个方法中释放锁，尽管这种跨方法长时间持有锁的做法需要非常谨慎），但也引入了手动释放锁的责任（必须在<code>finally</code>块中确保<code>unlock()</code>被调用）。</li>
</ul>
</li>
<li><p><strong>支持更丰富的锁获取语义</strong>:</p>
<ul>
<li><strong>可中断的锁获取 (<code>lockInterruptibly()</code>)</strong>: <code>synchronized</code>在等待锁时是不可中断的。<code>Lock</code>接口允许线程在等待获取锁的过程中响应中断，这对于构建可取消的任务或避免死锁非常重要。</li>
<li><strong>尝试非阻塞地获取锁 (<code>tryLock()</code>)</strong>: <code>synchronized</code>在获取不到锁时会一直阻塞。<code>Lock</code>接口允许线程尝试获取锁，如果锁不可用则立即返回，线程可以根据返回值决定下一步行为，而不是盲目等待。</li>
<li><strong>带超时的锁获取 (<code>tryLock(long time, TimeUnit unit)</code>)</strong>: 允许线程在指定时间内尝试获取锁，超时则放弃。这可以防止线程无限期地等待，提高系统的健壮性。</li>
</ul>
</li>
<li><p><strong>支持多种类型的锁 (接口的扩展性)</strong>:</p>
<ul>
<li><code>Lock</code>接口本身只定义了基本的互斥锁行为。但 JUC 包基于此理念提供了不同类型的锁实现，例如：<ul>
<li><code>ReentrantLock</code>: 可重入的互斥锁。</li>
<li><code>ReentrantReadWriteLock</code>: 读写分离锁，允许多个读线程并发，但写线程互斥。</li>
</ul>
</li>
<li>这种接口化的设计使得未来可以方便地扩展和实现更多不同语义的锁。</li>
</ul>
</li>
<li><p><strong>与<code>Condition</code>接口配合，实现更强大的线程协作</strong>:</p>
<ul>
<li><code>synchronized</code>关键字与<code>Object</code>的<code>wait()</code>, <code>notify()</code>, <code>notifyAll()</code>方法配合使用，但一个对象只有一个隐式的条件队列。</li>
<li><code>Lock</code>接口通过<code>newCondition()</code>方法可以创建多个<code>Condition</code>对象。每个<code>Condition</code>对象都可以有自己独立的等待队列，允许线程因为不同的条件在不同的队列上等待，并可以被精确地唤醒 (<code>signal()</code> &#x2F; <code>signalAll()</code>)。这大大增强了多线程协作的灵活性和效率，避免了<code>notifyAll()</code>可能带来的“惊群效应”。</li>
<li><strong>类比</strong>: <code>synchronized</code>的<code>wait/notify</code>像是一个大厅里只有一个广播，一广播所有等消息的人都被叫醒。而<code>Lock</code>+<code>Condition</code>像是大厅里有多个小房间，每个房间有自己的门铃，只叫醒对应房间里等特定消息的人。</li>
</ul>
</li>
<li><p><strong>为构建高级同步工具提供基础</strong>:</p>
<ul>
<li><code>Lock</code>接口（及其背后的 AQS 框架）是构建更高级并发工具（如<code>Semaphore</code>, <code>CountDownLatch</code>, <code>CyclicBarrier</code>等）的基础。这些工具内部通常会利用<code>Lock</code>或 AQS 来实现其同步逻辑。</li>
</ul>
</li>
<li><p><strong>性能考量 (最初的设计驱动之一)</strong>:</p>
<ul>
<li>在<code>Lock</code>接口刚被引入时 (JDK 1.5)，<code>synchronized</code>的性能在某些高竞争场景下不尽如人意。<code>Lock</code>接口的实现（特别是基于 AQS 的）旨在提供一种在这些场景下可能具有更好性能的替代方案。</li>
<li>虽然随着 JDK 版本的迭代，<code>synchronized</code>的性能得到了极大的优化（锁升级机制），但在某些特定场景和需要高级特性时，<code>Lock</code>的实现仍然可能表现更好或提供必要的功能。</li>
</ul>
</li>
</ol>
<p><strong>总结<code>Lock</code>接口的设计哲学</strong>:</p>
<ul>
<li><strong>显式化 (Explicit)</strong>: 锁的获取和释放是明确的 API 调用。</li>
<li><strong>可扩展性 (Extensible)</strong>: 接口设计易于实现不同类型的锁。</li>
<li><strong>灵活性 (Flexible)</strong>: 提供了多种锁获取方式和高级的线程协作机制。</li>
<li><strong>可控性 (Controllable)</strong>: 开发者对锁的行为有更多的控制权。</li>
</ul>
<p><strong>与<code>synchronized</code>的根本区别可以看作是“内置关键字”与“API 库”的区别</strong>：</p>
<ul>
<li><code>synchronized</code>是语言层面的特性，由 JVM 直接支持和优化，使用简单，不易出错（自动释放锁）。</li>
<li><code>Lock</code>是 Java 类库提供的一套 API，功能更强大，使用更灵活，但需要开发者更小心地管理锁的生命周期（特别是释放锁）。</li>
</ul>
<h2 id="深入-ReentrantLock-原理与应用"><a href="#深入-ReentrantLock-原理与应用" class="headerlink" title="深入 ReentrantLock 原理与应用"></a>深入 <code>ReentrantLock</code> 原理与应用</h2><p><code>ReentrantLock</code> 是 <code>java.util.concurrent.locks.Lock</code> 接口的核心实现之一，它提供了比 <code>synchronized</code> 更强大、更灵活的锁定机制。</p>
<h3 id="核心特性再强调"><a href="#核心特性再强调" class="headerlink" title="核心特性再强调"></a>核心特性再强调</h3><ul>
<li><p><strong>可重入 (Reentrant)</strong>:</p>
<ul>
<li><strong>含义</strong>: 一个已经持有锁的线程可以再次成功获取该锁，而不会被自己阻塞（即死锁）。</li>
<li><strong>实现</strong>: 锁内部会记录当前持有锁的线程（<code>exclusiveOwnerThread</code>）以及一个计数器（AQS 中的 <code>state</code>）。<ul>
<li>当一个线程首次获取锁时，如果锁是空闲的 (<code>state == 0</code>)，则该线程成为所有者，<code>state</code> 设置为 1。</li>
<li>如果同一个线程再次调用 <code>lock()</code> (或嵌套进入另一个需要此锁的同步方法)，它会发现自己已经是所有者，此时 <code>state</code> 会递增。</li>
<li>每次调用 <code>unlock()</code> 时，<code>state</code> 会递减。只有当 <code>state</code> 减到 0 时，锁才真正被释放，其他线程才能获取。</li>
</ul>
</li>
<li><strong>类比</strong>: 你已经拿到了会议室的钥匙（第一次获取锁），当你从会议室出来去拿个文件再马上回去（第二次获取锁），你不需要再和别人抢钥匙，可以直接用你手里的钥匙再次进入。</li>
</ul>
</li>
<li><p><strong>互斥 (Exclusive)</strong>:</p>
<ul>
<li>同一时刻，最多只有一个线程能够持有 <code>ReentrantLock</code>。其他尝试获取锁的线程会被阻塞，直到锁被释放。</li>
</ul>
</li>
<li><p><strong>公平性 (Fairness)</strong>:</p>
<ul>
<li><strong>构造时指定</strong>: <code>new ReentrantLock()</code> (默认，非公平) 或 <code>new ReentrantLock(true)</code> (公平)。</li>
<li><strong>非公平锁 (<code>NonfairSync</code>)</strong>:<ul>
<li><strong>优点</strong>: 通常有更高的吞吐量。当锁被释放时，如果恰好有一个线程正在尝试获取锁（通过 CAS“插队”），它可能比等待队列头部的线程更快地获取到锁，减少了线程挂起和唤醒的开销。</li>
<li><strong>缺点</strong>: 可能导致线程饥饿。等待队列中的线程可能长时间得不到 CPU，而新来的线程却能抢先获取锁。</li>
<li><strong>类比</strong>: 厕所门刚空出来，门口正好有个人想进（新请求），他就直接进去了，而不管队伍里排第一个的人（等待队列头部）。</li>
</ul>
</li>
<li><strong>公平锁 (<code>FairSync</code>)</strong>:<ul>
<li><strong>优点</strong>: 保证了获取锁的顺序性，等待时间最长的线程将优先获得锁 (FIFO)。避免了线程饥饿。</li>
<li><strong>缺点</strong>: 吞吐量通常较低。因为即使锁刚被释放，也需要检查等待队列是否有线程在等待，并可能需要唤醒队首线程，这个过程有开销。</li>
<li><strong>实现关键</strong>: 在 <code>tryAcquire</code> 时，公平锁会额外检查 <code>hasQueuedPredecessors()</code>，即判断等待队列中是否存在比当前线程更早请求的节点。如果存在，则当前线程获取失败，乖乖排队。</li>
<li><strong>类比</strong>: 厕所门空出来，管理员（锁机制）会严格按照排队顺序叫号，排在第一个的人先进。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="内部结构与-AQS-的关联"><a href="#内部结构与-AQS-的关联" class="headerlink" title="内部结构与 AQS 的关联"></a>内部结构与 AQS 的关联</h3><p><code>ReentrantLock</code> 的核心同步逻辑委托给了其内部的一个 <code>Sync</code> 对象。<code>Sync</code> 是一个继承自 <code>AbstractQueuedSynchronizer</code> (AQS) 的抽象静态内部类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ReentrantLock.java (简化结构)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync; <span class="comment">// 核心同步器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync 是 AQS 的子类</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="comment">// ... AQS 状态 (state) 被用来表示锁的持有次数 ...</span></span><br><span class="line">        <span class="comment">// ... 子类 (NonfairSync, FairSync) 实现 tryAcquire, tryRelease 等方法 ...</span></span><br><span class="line">        <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>; <span class="comment">// 加锁的具体实现由子类提供</span></span><br><span class="line">        <span class="keyword">final</span> ConditionObject <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConditionObject</span>(); <span class="comment">// ConditionObject 是 AQS 的内部类</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Thread <span class="title function_">getOwner</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">0</span> ? <span class="literal">null</span> : getExclusiveOwnerThread();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ... 其他辅助方法 ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非公平同步器</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 锁是空闲的</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123; <span class="comment">// CAS尝试获取</span></span><br><span class="line">                    setExclusiveOwnerThread(current); <span class="comment">// 成功，设置所有者</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="comment">// 锁已被当前线程持有 (重入)</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                setState(nextc); <span class="comment">// 增加重入计数</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 获取失败 (被其他线程持有)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// lock() 方法会先尝试CAS获取，失败再走AQS的acquire()</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) <span class="comment">// 非公平：先尝试CAS抢占</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>); <span class="comment">// CAS失败，走AQS标准获取流程 (排队等)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公平同步器</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 锁是空闲的</span></span><br><span class="line">                <span class="comment">// 公平关键点：先检查等待队列中是否有比我更早的等待者</span></span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123; <span class="comment">// 如果没有前驱并且CAS成功</span></span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="comment">// 重入</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// lock() 方法直接走AQS的acquire()，acquire内部会调用tryAcquire</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">            acquire(<span class="number">1</span>); <span class="comment">// 公平：直接排队</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(); <span class="comment">// 默认非公平</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lock 接口方法的实现，都是委托给 sync 对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.lock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.release(<span class="number">1</span>); <span class="comment">// release是AQS的方法，内部调用tryRelease</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... tryLock, lockInterruptibly, newCondition 等也是委托给 sync ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键点解读</strong>：</p>
<ul>
<li><strong><code>Sync</code> 继承 <code>AQS</code></strong>: <code>ReentrantLock</code> 的同步控制核心逻辑都封装在 <code>Sync</code> 类及其子类中，它们利用 AQS 的 <code>state</code> 来表示锁的持有计数和所有者。</li>
<li><strong><code>state</code> 的含义</strong>:<ul>
<li><code>state == 0</code>: 锁未被持有。</li>
<li><code>state &gt; 0</code>: 锁被某个线程持有，值为重入次数。<code>getExclusiveOwnerThread()</code> 返回持有者线程。</li>
</ul>
</li>
<li><strong><code>tryAcquire(int acquires)</code></strong>: 这是 AQS 要求子类实现的核心方法，用于尝试获取独占锁。<ul>
<li><code>NonfairSync</code> 的 <code>tryAcquire</code>：先检查锁是否空闲，如果是，CAS 尝试获取。如果锁已被当前线程持有，则增加重入计数。</li>
<li><code>FairSync</code> 的 <code>tryAcquire</code>：与<code>NonfairSync</code>类似，但在 CAS 前额外调用<code>hasQueuedPredecessors()</code>检查是否有等待队列中的前驱节点。这是实现公平性的关键。</li>
</ul>
</li>
<li><strong><code>lock()</code> 方法的实现</strong>:<ul>
<li><code>NonfairSync.lock()</code>: <strong>先尝试 CAS 抢占一次</strong>。如果成功，就直接获取了锁（插队成功）。如果失败，再调用 AQS 的<code>acquire(1)</code>方法进入标准的获取流程（可能排队、阻塞）。</li>
<li><code>FairSync.lock()</code>: <strong>直接调用 AQS 的<code>acquire(1)</code>方法</strong>。它不会尝试抢占，而是遵循 AQS 队列的公平策略。</li>
</ul>
</li>
<li><strong>AQS 的 <code>acquire(int arg)</code> 方法 (内部流程回顾)</strong>:<ol>
<li>调用 <code>tryAcquire(arg)</code> (由<code>FairSync</code>或<code>NonfairSync</code>实现)。</li>
<li>如果 <code>tryAcquire</code> 成功，方法返回。</li>
<li>如果 <code>tryAcquire</code> 失败：<ol>
<li>调用 <code>addWaiter(Node.EXCLUSIVE)</code> 将当前线程包装成一个独占模式的 Node 加入 AQS 等待队列的尾部。</li>
<li>调用 <code>acquireQueued(Node node, int arg)</code>，该方法会让节点在队列中自旋或阻塞，直到获取到锁。<ul>
<li><code>acquireQueued</code>内部会检查当前节点是否是队首的下一个节点，如果是，则再次尝试<code>tryAcquire</code>。</li>
<li>如果获取成功，则将当前节点设为新的头节点，并返回。 * 如果获取失败或不应获取（前面还有人），则通过 <code>shouldParkAfterFailedAcquire</code> 判断是否应该阻塞，并通过 <code>parkAndCheckInterrupt</code> (内部调用 <code>LockSupport.park(this)</code>) 将线程挂起。</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><strong><code>unlock()</code> 方法</strong>:<ul>
<li>调用 <code>sync.release(1)</code>。</li>
<li><code>AQS.release(int arg)</code> 内部调用 <code>tryRelease(int arg)</code> (由<code>Sync</code>的父类 AQS 中的<code>Sync</code>内部类实现，最终会调用到<code>ReentrantLock.Sync</code>中我们没展示的<code>tryRelease</code>逻辑)。</li>
<li><code>tryRelease(int releases)</code>:<ol>
<li>减少<code>state</code>的值。</li>
<li>如果<code>state</code>减到 0（表示锁完全释放），则清除<code>exclusiveOwnerThread</code>，返回<code>true</code>。</li>
<li>如果<code>state</code>仍然大于 0（只是减少了重入次数，锁未完全释放），返回<code>false</code>。</li>
</ol>
</li>
<li>如果 <code>tryRelease</code> 返回 <code>true</code> (锁已完全释放)，AQS 会查看等待队列的头节点 <code>h</code>，如果 <code>h</code> 不为 null 且其 <code>waitStatus</code> 不为 0 (通常为<code>SIGNAL</code>，表示后继节点需要被唤醒)，则调用 <code>unparkSuccessor(h)</code> 唤醒队列中头节点的下一个有效等待线程。</li>
</ul>
</li>
</ul>
<h3 id="Lock-接口提供的高级功能"><a href="#Lock-接口提供的高级功能" class="headerlink" title="Lock 接口提供的高级功能"></a><code>Lock</code> 接口提供的高级功能</h3><ul>
<li><p><strong><code>lockInterruptibly()</code></strong>:</p>
<ul>
<li><strong>作用</strong>: 在等待获取锁的过程中，如果当前线程被中断 (<code>Thread.interrupt()</code>)，此方法会抛出<code>InterruptedException</code>，从而允许线程响应中断并退出等待。</li>
<li><strong>实现</strong>: AQS 的 <code>acquireInterruptibly(int arg)</code> 方法实现了这个逻辑。在<code>parkAndCheckInterrupt</code>中，如果线程被唤醒是因为中断，它会抛出异常。</li>
<li><strong>对比 <code>synchronized</code></strong>: <code>synchronized</code>在等待锁时是不可中断的。</li>
<li><strong>类比</strong>: 你在排队等会议室，如果这时老板给你打电话说有更紧急的事，你可以选择不等了，直接离开队伍去处理急事。</li>
</ul>
</li>
<li><p><strong><code>tryLock()</code> 和 <code>tryLock(long time, TimeUnit unit)</code></strong>:</p>
<ul>
<li><strong><code>tryLock()</code></strong>: 尝试一次获取锁，如果锁不可用，立即返回<code>false</code>，不阻塞。<ul>
<li><strong>实现</strong>: <code>NonfairSync</code>和<code>FairSync</code>会分别实现一个快速路径的尝试，不涉及 AQS 队列。<code>NonfairSync</code>的<code>tryLock</code>其实就是调用了其<code>tryAcquire</code>一次。<code>FairSync</code>的<code>tryLock</code>也会检查队列。</li>
</ul>
</li>
<li><strong><code>tryLock(timeout)</code></strong>: 尝试在指定时间内获取锁。如果在超时前获取到，返回<code>true</code>；否则返回<code>false</code>。等待期间可中断。<ul>
<li><strong>实现</strong>: AQS 的 <code>tryAcquireNanos(int arg, long nanosTimeout)</code> 方法。它会计算截止时间，并在循环中尝试获取，如果超时则放弃。</li>
</ul>
</li>
<li><strong>类比 <code>tryLock()</code></strong>: 你去看一眼会议室门是不是开着，如果是就进去，如果是锁着的，你立刻就走开做别的事。</li>
<li><strong>类比 <code>tryLock(timeout)</code></strong>: 你决定在会议室门口等 5 分钟，如果 5 分钟内门开了就进去，如果 5 分钟还没开，你就走开。</li>
</ul>
</li>
<li><p><strong><code>newCondition()</code></strong>:</p>
<ul>
<li><strong>作用</strong>: 创建并返回一个绑定到此<code>ReentrantLock</code>实例的<code>Condition</code>对象。</li>
<li><strong><code>Condition</code>对象</strong>:<ul>
<li><code>await()</code>: 当前线程必须持有与此<code>Condition</code>关联的<code>ReentrantLock</code>。调用<code>await()</code>时，线程会释放该<code>Lock</code>，并进入此<code>Condition</code>的等待队列中等待。</li>
<li><code>signal()</code>: 唤醒在此<code>Condition</code>等待队列中的一个线程。被唤醒的线程需要重新获取<code>Lock</code>才能继续执行。</li>
<li><code>signalAll()</code>: 唤醒在此<code>Condition</code>等待队列中的所有线程。</li>
</ul>
</li>
<li><strong>内部实现</strong>: <code>ConditionObject</code>是 AQS 的一个内部类。每个<code>ConditionObject</code>维护自己的一个等待队列（与 AQS 的主等待队列不同）。<ul>
<li><code>await()</code>: 将当前线程加入<code>Condition</code>的等待队列，并调用<code>Lock</code>的<code>unlock()</code>（完全释放锁，即使是重入的），然后线程阻塞。</li>
<li><code>signal()</code>: 将<code>Condition</code>等待队列中的一个节点移到 AQS 的主等待队列中，使其能够参与锁的竞争。</li>
</ul>
</li>
<li><strong>与<code>Object.wait/notify</code>对比</strong>:<ul>
<li>一个<code>ReentrantLock</code>可以有多个<code>Condition</code>对象，可以为不同的等待条件创建不同的<code>Condition</code>，实现更精确的唤醒，避免了<code>Object.notifyAll()</code>可能导致的“惊群效应”和不必要的上下文切换。</li>
<li><code>Object</code>的<code>wait/notify</code>只能与对象自身的隐式监视器锁配合。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="使用ReentrantLock的注意事项"><a href="#使用ReentrantLock的注意事项" class="headerlink" title="使用ReentrantLock的注意事项"></a>使用<code>ReentrantLock</code>的注意事项</h3><ul>
<li><strong>必须在<code>finally</code>块中释放锁</strong>: 这是与<code>synchronized</code>最大的不同，也是最容易出错的地方。如果忘记在<code>finally</code>中调用<code>unlock()</code>，一旦同步代码块发生异常，锁可能永远不会被释放，导致其他线程死锁。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// critical section</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock(); <span class="comment">// Crucial!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>选择合适的公平策略</strong>: 理解公平与非公平的性能和行为差异，根据业务需求选择。</li>
<li><strong>不要滥用高级特性</strong>: 如果<code>synchronized</code>能满足需求且代码简洁，不一定非要用<code>ReentrantLock</code>。只有在确实需要其高级功能时才使用。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>ReentrantLock</code> 通过内部的 <code>Sync</code> 类（<code>NonfairSync</code> 或 <code>FairSync</code>）继承并定制了 AQS 的行为，实现了比<code>synchronized</code>更丰富功能的锁机制。它利用 AQS 的 <code>state</code> 来管理锁的持有和重入，利用 AQS 的等待队列来管理阻塞的线程，并通过 CAS 操作来实现状态的原子更新和部分无锁化的尝试。<code>Condition</code>对象则进一步增强了其线程协作的能力。</p>
<h2 id="ReentrantLock：公平性深入解析"><a href="#ReentrantLock：公平性深入解析" class="headerlink" title="ReentrantLock：公平性深入解析"></a><code>ReentrantLock</code>：公平性深入解析</h2><p><code>ReentrantLock</code> 允许在构造时选择锁的公平性策略：</p>
<ul>
<li><code>public ReentrantLock()</code>: 默认创建<strong>非公平锁</strong>。</li>
<li><code>public ReentrantLock(boolean fair)</code>: <code>fair</code> 为 <code>true</code> 时创建<strong>公平锁</strong>，为 <code>false</code> 时创建<strong>非公平锁</strong>。</li>
</ul>
<p>这两种策略的核心差异在于当锁被释放后，AQS 等待队列中的线程以及新到达的线程如何竞争获取锁。</p>
<p><strong>1. 非公平锁 (<code>NonfairSync</code>)</strong></p>
<ul>
<li><strong>核心行为</strong>: 当一个线程尝试获取锁时（调用 <code>lock()</code> 方法），<strong>它会首先尝试一次“插队”或“抢占”</strong>。如果恰好锁是空闲的，即使 AQS 等待队列中有其他线程正在等待，这个新来的线程也可能通过 CAS 操作直接获取到锁。只有当这种“抢占”失败后，它才会进入 AQS 的队列中排队等待。</li>
<li><strong><code>lock()</code> 方法的实现 (简化逻辑回顾)</strong>:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NonfairSync.java</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 尝试CAS抢占锁 (这是非公平的关键)</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread()); <span class="comment">// 抢占成功</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>); <span class="comment">// 抢占失败，进入AQS标准获取流程 (排队)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>acquire(1)</code> 内部会调用 <code>tryAcquire(1)</code>。<code>NonfairSync</code> 的 <code>tryAcquire</code> 实现如下 (简化逻辑回顾)：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NonfairSync.java</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 锁空闲</span></span><br><span class="line">        <span class="comment">// 即使锁空闲，这里仍然尝试CAS，因为可能在lock()方法中的第一次CAS之后，</span></span><br><span class="line">        <span class="comment">// 锁又被释放了，acquire()中的tryAcquire是第二次机会。</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="comment">// 重入</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 获取失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>优点</strong>:<ul>
<li><strong>高吞吐量 (Throughput)</strong>: 由于允许插队，当锁被释放的瞬间，如果恰好有线程正在尝试获取锁，它可以立即获得，避免了将该线程加入队列、挂起、然后再唤醒队首线程并使其获取锁这一系列上下文切换和调度开销。这使得在整体上，单位时间内能完成更多的工作。</li>
</ul>
</li>
<li><strong>缺点</strong>:<ul>
<li><strong>线程饥饿 (Starvation)</strong>: 等待队列中的线程可能长时间得不到锁，因为新来的线程总是有机会插队。如果系统负载很高，某些线程可能永远“饿死”。</li>
</ul>
</li>
<li><strong>适用场景</strong>:<ul>
<li>追求高吞吐量的场景。</li>
<li>对线程饥饿问题不敏感或有其他机制缓解（例如，任务本身执行时间短，竞争不持续）。</li>
<li>大多数情况下，非公平锁是默认且推荐的选择，因为它通常能提供更好的整体性能。</li>
</ul>
</li>
</ul>
<p><strong>2. 公平锁 (<code>FairSync</code>)</strong></p>
<ul>
<li><p><strong>核心行为</strong>: 严格按照线程请求锁的顺序（FIFO，先进先出）来分配锁。当一个线程尝试获取锁时，如果锁是空闲的，它会先检查 AQS 等待队列中是否有比它更早请求的线程。如果有，则当前线程不会尝试获取锁，而是会加入队列尾部排队。</p>
</li>
<li><p><strong><code>lock()</code> 方法的实现 (简化逻辑回顾)</strong>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FairSync.java</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    acquire(<span class="number">1</span>); <span class="comment">// 直接调用AQS的acquire，不尝试抢占</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>acquire(1)</code> 内部会调用 <code>tryAcquire(1)</code>。<code>FairSync</code> 的 <code>tryAcquire</code> 实现如下 (简化逻辑回顾)：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FairSync.java</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 锁空闲</span></span><br><span class="line">        <span class="comment">// 公平性关键：检查等待队列中是否有前驱节点</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; <span class="comment">// 如果队列为空或我是队首的下一个</span></span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123; <span class="comment">// 并且CAS成功</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="comment">// 重入</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 获取失败 (锁被占，或有前驱等待者)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>hasQueuedPredecessors()</code>: 这是 AQS 提供的方法，用于判断当前线程是否有等待队列中的前驱节点。它的逻辑大致是：检查队列的头节点 <code>h</code> 和尾节点 <code>t</code>。如果 <code>h != t</code> (队列不为空或不只包含一个虚拟头节点)，并且 (队列的第二个节点 <code>s = h.next</code> 不是 null，且 <code>s.thread != Thread.currentThread()</code>)，则认为有前驱。这个判断本身也需要考虑一些并发细节，但核心思想是检查队列中是否有其他线程排在前面。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>优点</strong>:</p>
<ul>
<li><strong>公平性保证</strong>: 所有线程都有机会获取锁，避免了饥饿现象。获取锁的顺序是可预测的。</li>
</ul>
</li>
<li><p><strong>缺点</strong>:</p>
<ul>
<li><strong>较低的吞吐量</strong>: 即使锁刚被释放，如果队列中有等待者，新尝试获取锁的线程也必须排队。这导致了更多的线程挂起和唤醒，以及上下文切换，从而降低了整体性能。</li>
</ul>
</li>
<li><p><strong>适用场景</strong>:</p>
<ul>
<li>对公平性有严格要求的业务场景，例如需要保证先到先服务的资源分配。</li>
<li>能够容忍较低吞吐量以换取公平性的情况。</li>
</ul>
</li>
</ul>
<p><strong>3. 行为差异的图示对比 (概念性)</strong></p>
<p>假设锁刚被线程 T0 释放，此时等待队列中有 T1, T2，同时新线程 T3 尝试<code>lock()</code>。</p>
<p><strong>非公平锁 (<code>NonfairSync</code>)</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant T0 as &quot;T0 (Releases Lock)&quot;</span><br><span class="line">    participant LockState as &quot;Lock (State=0)&quot;</span><br><span class="line">    participant T3 as &quot;T3 (Newcomer)&quot;</span><br><span class="line">    participant AQS_Queue as &quot;AQS Queue (T1, T2 waiting)&quot;</span><br><span class="line">    participant T1 as &quot;T1 (Head of Queue)&quot;</span><br><span class="line"></span><br><span class="line">    T0 -&gt;&gt; LockState: unlock() -&gt; state becomes 0</span><br><span class="line">    T3 -&gt;&gt; LockState: lock() - attempts CAS抢占</span><br><span class="line">    alt CAS抢占成功 (T3 is lucky)</span><br><span class="line">        LockState --&gt;&gt; T3: Lock Acquired (state=1, owner=T3)</span><br><span class="line">        T3 --&gt;&gt; T3: Executes Critical Section</span><br><span class="line">    else CAS抢占失败 (e.g., T1 also trying or other races)</span><br><span class="line">        T3 -&gt;&gt; AQS_Queue: Enters Queue</span><br><span class="line">        LockState -&gt;&gt; T1: (AQS eventually wakes T1)</span><br><span class="line">        T1 -&gt;&gt; LockState: tryAcquire() -&gt; Lock Acquired</span><br><span class="line">    end</span><br><span class="line">    note over AQS_Queue, T1: T1, T2 might wait longer if T3插队成功</span><br></pre></td></tr></table></figure>

<p><strong>公平锁 (<code>FairSync</code>)</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant T0 as &quot;T0 (Releases Lock)&quot;</span><br><span class="line">    participant LockState as &quot;Lock (State=0)&quot;</span><br><span class="line">    participant T3 as &quot;T3 (Newcomer)&quot;</span><br><span class="line">    participant AQS_Queue as &quot;AQS Queue (T1, T2 waiting)&quot;</span><br><span class="line">    participant T1 as &quot;T1 (Head of Queue)&quot;</span><br><span class="line"></span><br><span class="line">    T0 -&gt;&gt; LockState: unlock() -&gt; state becomes 0</span><br><span class="line">    T3 -&gt;&gt; LockState: lock() -&gt; calls acquire(1)</span><br><span class="line">    LockState -&gt;&gt; AQS_Queue: T3&#x27;s tryAcquire() checks hasQueuedPredecessors()</span><br><span class="line">    alt hasQueuedPredecessors() is true (T1 is waiting)</span><br><span class="line">        AQS_Queue --&gt;&gt; T3: tryAcquire() returns false</span><br><span class="line">        T3 -&gt;&gt; AQS_Queue: Enters Queue (behind T2)</span><br><span class="line">        LockState -&gt;&gt; T1: (AQS eventually wakes T1)</span><br><span class="line">        T1 -&gt;&gt; LockState: tryAcquire() -&gt; Lock Acquired</span><br><span class="line">    else hasQueuedPredecessors() is false (Queue was empty just before T3 check - less likely if T1/T2 exist)</span><br><span class="line">        T3 -&gt;&gt; LockState: tryAcquire() attempts CAS</span><br><span class="line">        alt CAS成功</span><br><span class="line">             LockState --&gt;&gt; T3: Lock Acquired</span><br><span class="line">        else CAS失败</span><br><span class="line">             T3 -&gt;&gt; AQS_Queue: Enters Queue</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    note over AQS_Queue, T1: T1 (if waiting) will get the lock before T3</span><br></pre></td></tr></table></figure>

<p><strong>4. <code>tryLock()</code> 方法的公平性</strong></p>
<ul>
<li><p><code>boolean tryLock()</code>:</p>
<ul>
<li><strong>非公平锁 (<code>NonfairSync</code>)</strong>: <code>tryLock()</code> 会尝试一次非公平的获取（类似<code>lock()</code>方法开始的 CAS 抢占）。如果成功则返回<code>true</code>，否则返回<code>false</code>。它<strong>不考虑等待队列</strong>。</li>
<li><strong>公平锁 (<code>FairSync</code>)</strong>: <code>tryLock()</code> 仍然会首先检查<code>hasQueuedPredecessors()</code>。如果队列中有等待者，它会直接返回<code>false</code>，<strong>即使锁当前是可用的</strong>。只有当队列为空且锁可用时，它才会尝试 CAS 获取。这维持了公平性原则。</li>
</ul>
<p>这意味着，对于公平锁，即使锁是空闲的，如果队列里有线程在等，<code>tryLock()</code> 也会失败。这可能与某些人的直觉（<code>tryLock</code> 应该只要锁空闲就成功）相悖，但这是为了维护公平性。</p>
</li>
</ul>
<p><strong>5. 性能权衡</strong></p>
<ul>
<li><strong>非公平锁的优势</strong>: 减少了 CPU 密集型操作中线程的挂起和恢复，因为线程可以在锁可用时立即获取它，而不是等待队列中的其他线程被唤醒。上下文切换是昂贵的。</li>
<li><strong>公平锁的代价</strong>: 保证公平性需要额外的开销（如检查队列状态）并可能导致更多的上下文切换。</li>
</ul>
<p><strong>总结与选择建议</strong></p>
<ul>
<li><strong>默认情况下，使用非公平锁 (<code>new ReentrantLock()</code>)</strong>，因为它通常能提供更好的整体性能（更高的吞吐量）。</li>
<li><strong>仅在确实需要保证线程获取锁的顺序性，以避免线程饥饿，并且能够接受潜在的性能下降时，才使用公平锁 (<code>new ReentrantLock(true)</code>)</strong>。</li>
<li>对于<code>tryLock()</code>的行为，要特别注意其在公平锁和非公平锁下的不同表现。</li>
</ul>
<p>理解公平与非公平的差异，不仅仅是知道它们的定义，更重要的是理解它们在 AQS 层面的实现机制（尤其是<code>tryAcquire</code>和<code>hasQueuedPredecessors()</code>的交互）以及由此带来的性能和行为上的影响。</p>
<p>这次对<code>ReentrantLock</code>公平性和非公平性的详细解析，你觉得理解得怎么样？有没有觉得哪个机制的细节（比如<code>hasQueuedPredecessors</code>的具体判断逻辑，或者非公平锁插队成功的概率问题）还想再挖深一点？或者我们继续看<code>ReentrantReadWriteLock</code>？</p>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Volatile 与 Synchronized</title>
    <url>/2025/05/23/Java-Threads/volatile-%E4%B8%8E-synchronized/</url>
    <content><![CDATA[<h1 id="Volatile-与-Synchronized-深度对比"><a href="#Volatile-与-Synchronized-深度对比" class="headerlink" title="Volatile 与 Synchronized 深度对比"></a><code>Volatile</code> 与 <code>Synchronized</code> 深度对比</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在前面的文章中，我们深入学习了<a href="/2025/05/17/Java-Threads/Java%E7%9A%84%E7%BA%BF%E7%A8%8B/" title="Java的线程">Java线程机制</a>和<a href="/2025/05/19/Java-Threads/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-JMM/" title="Java 内存模型(JMM)">Java内存模型</a>的理论基础。现在是时候将理论与实践结合，深入对比两个最重要的并发关键字：<code>volatile</code> 和 <code>synchronized</code>。</p>
<p>在日常开发和技术面试中，这两个关键字的使用场景和区别是被问得最多的话题之一。很多开发者容易混淆它们的作用范围，甚至误以为 <code>volatile</code> 能够保证原子性。</p>
<blockquote>
<p><strong>实际案例</strong>：在优化一个配置热更新模块时，最初使用了 <code>volatile boolean configChanged</code> 来标识配置变更。但在高并发场景下发现，多个线程同时处理配置更新时出现了数据不一致问题。后来分析发现，<code>volatile</code> 只能保证可见性，而配置更新是一个复合操作，需要使用 <code>synchronized</code> 来保证原子性。这个经历让我深刻理解了两者的根本区别。</p>
</blockquote>
<ul>
<li>🎯 <strong>精通底层原理</strong>：理解 volatile 和 synchronized 的实现机制</li>
<li>🔍 <strong>准确识别场景</strong>：知道何时使用哪个关键字</li>
<li>⚖️ <strong>权衡性能影响</strong>：理解两者的性能差异和优化策略</li>
<li>💡 <strong>避免常见陷阱</strong>：掌握正确的使用方式，避免常见错误</li>
</ul>
<span id="more"></span>

<h2 id="为什么要深入对比这两个关键字？"><a href="#为什么要深入对比这两个关键字？" class="headerlink" title="为什么要深入对比这两个关键字？"></a>为什么要深入对比这两个关键字？</h2><p>基于 JMM 的三大特性（可见性、原子性、有序性），<code>volatile</code> 和 <code>synchronized</code> 提供了不同层次的保证：</p>
<ul>
<li><strong>volatile</strong>：轻量级同步，主要解决可见性和有序性问题</li>
<li><strong>synchronized</strong>：重量级同步，全面解决三大特性问题</li>
</ul>
<p>理解它们的差异，有助于：</p>
<ul>
<li><strong>编写正确的并发代码</strong>：避免线程安全问题</li>
<li><strong>优化程序性能</strong>：选择合适的同步机制</li>
<li><strong>提升技术面试表现</strong>：这是面试官最爱考查的知识点</li>
</ul>
<p><code>volatile</code> 和 <code>synchronized</code> 都是 Java 中用于保证多线程环境下共享变量线程安全的关键字，但它们在实现机制、保证的特性范围以及使用场景上有显著差异。</p>
<h2 id="volatile-关键字原理与应用场景"><a href="#volatile-关键字原理与应用场景" class="headerlink" title="volatile 关键字原理与应用场景"></a><code>volatile</code> 关键字原理与应用场景</h2><h3 id="原理核心-基于-JMM"><a href="#原理核心-基于-JMM" class="headerlink" title="原理核心 (基于 JMM):"></a>原理核心 (基于 JMM):</h3><ul>
<li><strong>保证可见性</strong>:<ul>
<li>当一个线程修改了被<code>volatile</code>修饰的变量的值，JMM 会确保这个修改立即被刷新到主内存。</li>
<li>当另一个线程读取这个<code>volatile</code>变量时，JMM 会确保该线程的工作内存中此变量的副本失效，并从主内存重新加载最新值。</li>
<li><strong>实现机制</strong>: 主要通过在读写<code>volatile</code>变量时插入特定类型的<strong>内存屏障 (Memory Barrier&#x2F;Fence)</strong> 来实现。<ul>
<li>写<code>volatile</code>变量：在其之前插入<code>StoreStore</code>屏障（保证之前的普通写不被重排序到<code>volatile</code>写之后，并对其他处理器可见），在其之后插入<code>StoreLoad</code>屏障（保证<code>volatile</code>写对其他处理器可见，并防止后续的<code>volatile</code>读&#x2F;写被重排序到当前<code>volatile</code>写之前）。</li>
<li>读<code>volatile</code>变量：在其之后插入<code>LoadLoad</code>屏障和<code>LoadStore</code>屏障（防止后续的普通读&#x2F;写被重排序到当前<code>volatile</code>读之前，并确保读到的是最新值）。</li>
</ul>
</li>
<li><strong>底层 CPU 指令</strong>: 在某些 CPU 架构（如 x86）上，写<code>volatile</code>可能通过带有<code>lock</code>前缀的指令（如<code>lock addl $0,0(%%rsp)</code>，它本身有内存屏障效果并能使其他 CPU 缓存失效）或<code>mfence</code>指令来实现内存屏障效果。</li>
</ul>
</li>
<li><strong>保证有序性 (部分)</strong>:<ul>
<li><code>volatile</code>关键字能禁止特定类型的指令重排序，确保<code>volatile</code>写操作之前的操作不会被重排序到其后，<code>volatile</code>读操作之后的操作不会被重排序到其前。</li>
<li>它提供了一种”happen-before”关系：对一个<code>volatile</code>变量的写操作 <code>happens-before</code> 后续对这个变量的读操作。</li>
</ul>
</li>
<li><strong>不保证原子性</strong>:<ul>
<li><code>volatile</code>关键字<strong>不能保证复合操作的原子性</strong>。例如，<code>volatile int count; count++;</code> 这个操作不是原子的。它包含读-改-写三个步骤，在多线程环境下，这三个步骤之间可能被其他线程打断。</li>
</ul>
</li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景:"></a>应用场景:</h3><ul>
<li><strong>状态标志 (Status Flags)</strong>: 当一个线程修改一个<code>volatile</code>布尔标志，另一个线程通过检查这个标志来决定是否继续执行或停止。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">running</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stopThread</span><span class="params">()</span> &#123;</span><br><span class="line">    running = <span class="literal">false</span>; <span class="comment">// volatile写，对其他线程可见</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (running) &#123; <span class="comment">// volatile读，能看到最新的running值</span></span><br><span class="line">        <span class="comment">// ... do work ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>一次性安全发布 (Safe Publication - 结合 final)</strong>: 当对象的引用是<code>volatile</code>的，并且对象的字段是<code>final</code>的（且构造函数无<code>this</code>逸出），可以用来安全地将对象发布给其他线程。但更常见的是使用<code>final</code>字段本身的保证。</li>
<li><strong>双重检查锁定 (Double-Checked Locking - DCL) 中的实例字段</strong>: 在实现线程安全的单例模式时，单例实例字段需要用<code>volatile</code>修饰，以防止指令重排序导致其他线程拿到未完全初始化的对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance; <span class="comment">// volatile修饰</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123; <span class="comment">// 第一次检查</span></span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123; <span class="comment">// 第二次检查</span></span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>(); <span class="comment">// new操作不是原子性的</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>volatile</code>主要是为了禁止<code>instance = new Singleton()</code>中可能发生的指令重排序（分配内存 -&gt; 初始化对象 -&gt; instance 指向内存地址，后两步可能重排）。</p>
<ol>
<li><strong>开销较低的读多写少场景</strong>: 当一个变量被一个线程修改，但被多个线程频繁读取时，如果不需要复合操作的原子性，<code>volatile</code>可以提供比<code>synchronized</code>更轻量级的可见性保证。</li>
<li><strong>作为实现其他并发机制的基础</strong>: <code>volatile</code>常被用于实现更高级的并发工具，例如在 AQS 的<code>state</code>字段，以及<code>Atomic*</code>类中的<code>value</code>字段。</li>
</ol>
<h2 id="synchronized-关键字实现机制与应用"><a href="#synchronized-关键字实现机制与应用" class="headerlink" title="synchronized 关键字实现机制与应用"></a><code>synchronized</code> 关键字实现机制与应用</h2><h3 id="synchronized-的基本用法与锁定对象"><a href="#synchronized-的基本用法与锁定对象" class="headerlink" title="synchronized 的基本用法与锁定对象"></a><code>synchronized</code> 的基本用法与锁定对象</h3><ul>
<li><p><strong>修饰实例方法</strong>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">instanceMethod</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>锁定对象</strong>: 当前实例对象 (<code>this</code>)。</li>
<li><strong>作用</strong>: 同一时刻，只有一个线程能执行该实例的任何一个<code>synchronized</code>实例方法。不同实例之间互不影响。</li>
</ul>
</li>
<li><p><strong>修饰静态方法</strong>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>锁定对象</strong>: 当前类的 <code>Class</code> 对象 (<code>YourClassName.class</code>)。</li>
<li><strong>作用</strong>: 同一时刻，只有一个线程能执行该类的任何一个<code>synchronized</code>静态方法，无论有多少个实例或没有实例。</li>
</ul>
</li>
<li><p><strong>修饰代码块</strong>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ... non-critical section ...</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">customLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 或者使用 this, YourClassName.class</span></span><br><span class="line">    <span class="keyword">synchronized</span> (customLock) &#123; <span class="comment">// 明确指定锁对象</span></span><br><span class="line">        <span class="comment">// ... critical section ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... non-critical section ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>锁定对象</strong>: <code>synchronized</code>关键字后面括号中指定的对象。</li>
<li><strong>灵活性</strong>: 提供了最细粒度的锁控制。推荐使用私有的、<code>final</code>的、专门用于锁定的对象实例。</li>
</ul>
</li>
</ul>
<h3 id="synchronized-的核心作用"><a href="#synchronized-的核心作用" class="headerlink" title="synchronized 的核心作用"></a><code>synchronized</code> 的核心作用</h3><p>通过 JMM 的管程锁定规则和内存交互操作，<code>synchronized</code>保证了其同步代码块的：</p>
<ul>
<li><strong>原子性</strong>: 同步代码块在执行期间不可被其他线程中断，表现为一个原子操作。</li>
<li><strong>可见性</strong>:<ul>
<li>线程获取锁时（进入同步块），会使工作内存中共享变量副本失效，从主内存重新加载。</li>
<li>线程释放锁时（退出同步块），会将工作内存中对共享变量的修改刷新到主内存。</li>
</ul>
</li>
<li><strong>有序性</strong>: 虽然<code>synchronized</code>本身不直接禁止指令重排序，但由于”同一时刻只有一个线程持有锁”的特性，以及”一个<code>unlock</code>操作 <code>happens-before</code> 后续对同一个锁的<code>lock</code>操作”的规则，使得在持有同一个锁的多个线程看来，同步块内部的操作是有序的。</li>
</ul>
<h3 id="synchronized-的底层原理-基于对象监视器-Monitor"><a href="#synchronized-的底层原理-基于对象监视器-Monitor" class="headerlink" title="synchronized 的底层原理 (基于对象监视器 Monitor)"></a><code>synchronized</code> 的底层原理 (基于对象监视器 Monitor)</h3><ul>
<li><p><strong>对象头 (Mark Word)</strong>: Java 对象的头部（在 HotSpot 中称为 Mark Word）用于存储对象的运行时数据，其中一部分用于存储锁状态信息、持有锁的线程 ID、GC 年龄、哈希码等。锁的状态（无锁、偏向锁、轻量级锁、重量级锁）就记录在这里。</p>
</li>
<li><p><strong>Monitor (监视器)</strong>:</p>
<ul>
<li>每个 Java 对象都可以关联一个 Monitor 对象（也称为”管程”或”监视器锁”）。这个 Monitor 是在对象第一次被加锁时由 JVM 创建并关联的。</li>
<li>Monitor 内部主要结构 (HotSpot C++层面 <code>ObjectMonitor</code>):<ul>
<li><code>_owner</code>: 指向当前持有该 Monitor 的线程。</li>
<li><code>_count</code> (或 <code>_recursions</code>): 记录锁的重入次数。</li>
<li><code>_EntryList</code>: 一个队列，存储尝试获取锁失败而被阻塞的线程 (BLOCKED 状态)。</li>
<li><code>_WaitSet</code>: 一个队列，存储调用了该对象<code>wait()</code>方法而进入等待状态的线程 (WAITING&#x2F;TIMED_WAITING 状态)。</li>
</ul>
</li>
<li><strong>类比 Monitor</strong>: <strong>一个带有会议室、等候区和休息室的办公室。</strong><ul>
<li><strong>会议室 (<code>_owner</code> + <code>_count</code>)</strong>: 同一时间只能一个团队（线程）使用。如果团队负责人（线程）已经在了，他的组员（同一线程的重入）可以直接进入。</li>
<li><strong>等候区 (<code>_EntryList</code>)</strong>: 想用会议室但发现里面有人（锁被占用）的团队，在这里排队等候。</li>
<li><strong>休息室 (<code>_WaitSet</code>)</strong>: 进了会议室但发现条件不满足（比如投影仪坏了），于是主动去休息室等待（调用<code>wait()</code>），并把会议室让出来。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>字节码指令</strong>:</p>
<ul>
<li>对于同步代码块: JVM 使用 <code>monitorenter</code> 和 <code>monitorexit</code> 指令。<ul>
<li><code>monitorenter</code>: 尝试获取对象关联 Monitor 的所有权。成功则<code>_count</code>+1，线程成为<code>_owner</code>。失败则阻塞并进入<code>_EntryList</code>。</li>
<li><code>monitorexit</code>: <code>_count</code>-1。如果<code>_count</code>为 0，则释放 Monitor，唤醒<code>_EntryList</code>中的等待线程。编译器会确保即使发生异常，<code>monitorexit</code>也会被执行（通过<code>try-finally</code>）。</li>
</ul>
</li>
<li>对于同步方法: 方法的访问标志 (<code>flags</code>) 中会设置 <code>ACC_SYNCHRONIZED</code>。JVM 在调用方法时会检查此标志，并隐式执行类似<code>monitorenter</code>的操作；方法返回（正常或异常）时执行类似<code>monitorexit</code>的操作。</li>
</ul>
</li>
</ul>
<h3 id="锁的优化与升级-HotSpot-JVM"><a href="#锁的优化与升级-HotSpot-JVM" class="headerlink" title="锁的优化与升级 (HotSpot JVM)"></a>锁的优化与升级 (HotSpot JVM)</h3><p>为了减少重量级锁（依赖 OS 互斥量，开销大）的使用，JVM 对<code>synchronized</code>引入了锁升级机制，锁的状态会根据竞争情况动态调整。</p>
<ul>
<li><strong>无锁状态</strong>: 对象刚创建，或锁已释放且无竞争。</li>
<li><strong>偏向锁 (Biased Locking)</strong><ul>
<li><strong>目的</strong>: 优化只有一个线程反复获取同一个锁的场景。</li>
<li><strong>机制</strong>: 当锁对象第一次被线程获取时，Mark Word 记录下该线程 ID（偏向线程），并将锁状态置为偏向锁。之后该线程再进入同步块，只需检查 Mark Word 的线程 ID 是否是自己，无需 CAS 或更重操作。</li>
<li><strong>类比</strong>: <strong>会议室的”专属预约牌”</strong>。如果总是张三用，就一直挂着张三的名字，张三来去自如，不用每次都去前台登记。</li>
<li><strong>撤销</strong>: 当有其他线程尝试获取该偏向锁时，偏向锁撤销。如果原偏向线程已退出同步块，锁恢复到无锁或重新偏向新线程；如果仍在同步块内，则升级为轻量级锁。撤销过程可能需要全局安全点。</li>
</ul>
</li>
<li><strong>轻量级锁 (Lightweight Locking)</strong><ul>
<li><strong>目的</strong>: 在多个线程交替获取锁，但几乎没有同时竞争的情况下，通过 CAS 避免重量级锁。</li>
<li><strong>机制</strong>:<ol>
<li>线程在栈帧中创建锁记录(Lock Record)，拷贝对象 Mark Word (Displaced Mark Word)。</li>
<li>通过<strong>CAS</strong>尝试将对象 Mark Word 更新为指向此锁记录的指针。</li>
<li>成功则获取轻量级锁。失败则<strong>自旋 (Spinning)</strong> 尝试一小段时间。</li>
</ol>
</li>
<li><strong>类比</strong>: <strong>会议室门口的”快速登记本”</strong>。没人用时，想用的人尝试在登记本上快速写下自己名字（CAS）。写上了就用。如果几个人同时想写，就可能需要排队或找管理员。</li>
<li><strong>自旋 (Spinning)</strong>: CAS 失败后不立即阻塞，而是执行空循环尝试再次 CAS。<ul>
<li><strong>类比</strong>: 在卫生间门口稍微等一下，而不是立刻走开再回来。</li>
<li><strong>自适应自旋</strong>: 自旋次数和时间根据上次自旋情况和锁持有者状态动态调整。</li>
</ul>
</li>
<li><strong>升级</strong>: 自旋失败或有其他线程也 CAS 失败，或持有轻量级锁时调用<code>wait()</code>，则膨胀为重量级锁。</li>
</ul>
</li>
<li><strong>重量级锁 (Heavyweight Locking)</strong><ul>
<li><strong>目的</strong>: 处理激烈的锁竞争。</li>
<li><strong>机制</strong>: 依赖操作系统互斥量（Mutex Lock），通过之前提到的 Monitor 对象 (<code>ObjectMonitor</code>) 实现。线程获取失败会被阻塞并放入<code>_EntryList</code>。</li>
<li><strong>类比</strong>: <strong>会议室需要专门的管理员（Monitor&#x2F;OS 互斥量）</strong> 来协调使用和排队。</li>
<li><strong>开销</strong>: 涉及用户态与内核态切换，性能开销最大。</li>
</ul>
</li>
</ul>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentStyleType="text/css" data-diagram-type="STATE" height="994px" preserveAspectRatio="none" style="width:591px;height:994px;background:#FFFFFF;" version="1.1" viewBox="0 0 591 994" width="591px" zoomAndPan="magnify"><title>Mark Word &#29366;&#24577;&#27969;&#36716;</title><defs/><g><g class="title" data-source-line="4"><text fill="#000000" font-family="sans-serif" font-size="14" font-weight="bold" lengthAdjust="spacing" textLength="147.3279" x="215.2985" y="22.9951">Mark Word &#29366;&#24577;&#27969;&#36716;</text></g><g class="entity" data-entity="N1" data-source-line="5" data-uid="ent0002" id="entity_N1"><path d="M6,43.2969 L6,68.4297 L202.424,68.4297 L202.424,53.2969 L192.424,43.2969 L6,43.2969" fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M192.424,43.2969 L192.424,53.2969 L202.424,53.2969 L192.424,43.2969" fill="#FEFFDD" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="175.424" x="12" y="60.3638">T1&#21644;T2&#34920;&#31034;&#20026;&#20004;&#20010;&#29420;&#31435;&#30340;&#32447;&#31243;</text></g><rect fill="#F1F1F1" height="40" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="50" x="222.21" y="129.4269"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="27.9999" x="233.2101" y="154.2736">&#26080;&#38145;</text><rect fill="#F1F1F1" height="40" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="73.909" x="172.26" y="246.4269"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="63.909" x="177.26" y="271.2736">&#20559;&#21521;&#38145; T1</text><rect fill="#F1F1F1" height="40" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="79.9997" x="130.21" y="363.4269"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="69.9997" x="135.21" y="388.2736">&#25764;&#38144;&#20559;&#21521;&#38145;</text><rect fill="#F1F1F1" height="40" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="65.9998" x="251.21" y="480.4269"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="55.9998" x="256.21" y="505.2736">&#36731;&#37327;&#32423;&#38145;</text><rect fill="#F1F1F1" height="40" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="131.2828" x="434.57" y="597.4269"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="121.2828" x="439.57" y="622.2736">&#36731;&#37327;&#32423;&#38145; (T1 &#25345;&#26377;)</text><rect fill="#F1F1F1" height="40" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="65.9998" x="245.21" y="714.4269"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="55.9998" x="250.21" y="739.2736">&#37325;&#37327;&#32423;&#38145;</text><rect fill="#F1F1F1" height="40" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="131.2828" x="212.57" y="831.4269"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="121.2828" x="217.57" y="856.2736">&#37325;&#37327;&#32423;&#38145; (T1 &#25345;&#26377;)</text><rect fill="#F1F1F1" height="40" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="194.7886" x="180.82" y="948.4269"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="184.7886" x="185.82" y="973.2736">&#26080;&#38145; / &#21796;&#37266;_EntryList &#20013;&#32447;&#31243;</text><ellipse cx="247.21" cy="55.8569" fill="#222222" rx="10" ry="10" style="stroke:#222222;stroke-width:1;"/><!--link *start* to A--><g class="link" data-entity-1=".start." data-entity-2="A" data-source-line="20" data-uid="lnk3" id="link_.start._A"><path d="M247.21,66.3169 C247.21,81.0269 247.21,103.7069 247.21,122.9769" fill="none" id="*start*-to-A" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="247.21,128.9769,251.21,119.9769,247.21,123.9769,243.21,119.9769,247.21,128.9769" style="stroke:#181818;stroke-width:1;"/></g><!--link A to B--><g class="link" data-entity-1="A" data-entity-2="B" data-source-line="23" data-uid="lnk4" id="link_A_B"><path d="M221.72,159.5269 C204.34,167.2369 182.65,180.1369 172.21,199.4269 C163.65,215.2569 170.7518,228.6645 183.0118,241.7745" fill="none" id="A-to-B" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="187.11,246.1569,183.8843,236.8513,183.6948,242.5049,178.0412,242.3155,187.11,246.1569" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="119.609" x="173.21" y="212.4938">T1 &#39318;&#27425;&#35775;&#38382;, &#26080;&#31454;&#20105;</text></g><!--link B to C--><g class="link" data-entity-1="B" data-entity-2="C" data-source-line="24" data-uid="lnk5" id="link_B_C"><path d="M202.68,286.6769 C195.49,307.9069 185.8978,336.185 178.6878,357.435" fill="none" id="B-to-C" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="176.76,363.1169,183.4396,355.8793,178.3665,358.382,175.8638,353.3089,176.76,363.1169" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="72.3443" x="193.21" y="329.4938">T2 &#23581;&#35797;&#33719;&#21462;</text></g><!--link C to A--><g class="link" data-entity-1="C" data-entity-2="A" data-source-line="25" data-uid="lnk6" id="link_C_A"><path d="M129.91,364.1569 C81.95,339.7569 11.94,294.0369 42.21,246.4269 C82.49,183.0869 170.855,161.7727 216.145,154.5427" fill="none" id="C-to-A" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="222.07,153.5969,212.552,151.0657,217.1325,154.3851,213.8131,158.9656,222.07,153.5969" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="111.3443" x="43.21" y="270.9938">T1 &#24050;&#36864;&#20986;&#25110;&#26080;&#31454;&#20105;</text></g><!--link C to D--><g class="link" data-entity-1="C" data-entity-2="D" data-source-line="26" data-uid="lnk7" id="link_C_D"><path d="M163.66,403.6669 C160.13,417.7769 158.13,436.7669 167.21,450.4269 C185.69,478.2069 217.3845,489.1519 244.9845,494.3719" fill="none" id="C-to-D" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="250.88,495.4869,242.7801,489.884,245.9671,494.5577,241.2934,497.7447,250.88,495.4869" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="124.3444" x="168.21" y="446.4938">T1 &#20173;&#22312;&#25110;&#26377;&#20854;&#20182;&#31454;&#20105;</text></g><!--link A to D--><g class="link" data-entity-1="A" data-entity-2="D" data-source-line="27" data-uid="lnk8" id="link_A_D"><path d="M272.66,168.2569 C282.25,176.5169 292.08,187.2169 297.21,199.4269 C318.82,250.8469 304.42,395.1169 297.21,450.4269 C295.91,460.3769 294.8732,465.4178 292.2632,474.3478" fill="none" id="A-to-D" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="290.58,480.1069,296.9442,472.5904,291.9827,475.3077,289.2655,470.3461,290.58,480.1069" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="156.0002" x="310.21" y="329.4938">&#20851;&#38381;&#20559;&#21521;&#38145;&#25110;&#21021;&#22987;&#21363;&#26377;&#31454;&#20105;</text></g><!--link D to D_Held--><g class="link" data-entity-1="D" data-entity-2="D_Held" data-source-line="29" data-uid="lnk9" id="link_D_D_Held"><path d="M317.49,519.1469 C357.01,540.1869 417.4335,572.3578 458.3535,594.1378" fill="none" id="D-to-D_Held" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="463.65,596.9569,457.5847,589.1972,459.2363,594.6076,453.8259,596.2592,463.65,596.9569" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="56.3545" x="406.21" y="563.4938">CAS &#25104;&#21151;</text></g><!--link D_Held to A--><g class="link" data-entity-1="D_Held" data-entity-2="A" data-source-line="30" data-uid="lnk10" id="link_D_Held_A"><path d="M500.21,597.2969 C500.21,574.4769 500.21,535.1669 500.21,501.4269 C500.21,265.4269 500.21,265.4269 500.21,265.4269 C500.21,166.0369 342.388,152.2906 278.398,150.6506" fill="none" id="D_Held-to-A" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="272.4,150.4969,281.2946,154.7261,277.3984,150.625,281.4995,146.7288,272.4,150.4969" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="82.3546" x="501.21" y="387.9938">CAS &#37322;&#25918;&#25104;&#21151;</text></g><!--link D to E--><g class="link" data-entity-1="D" data-entity-2="E" data-source-line="31" data-uid="lnk11" id="link_D_E"><path d="M279.75,520.7869 C275.55,540.0769 269.57,570.6169 267.21,597.4269 C263.56,638.9569 269.1298,681.7508 273.5898,708.1308" fill="none" id="D-to-E" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="274.59,714.0469,277.0337,704.506,273.7565,709.1168,269.1457,705.8396,274.59,714.0469" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="148.6305" x="268.21" y="621.9938">CAS &#22833;&#36133; (&#33258;&#26059;&#21518;&#20173;&#22833;&#36133;)</text></g><!--link D_Held to E--><g class="link" data-entity-1="D_Held" data-entity-2="E" data-source-line="32" data-uid="lnk12" id="link_D_Held_E"><path d="M462.8,637.8069 C420.42,659.7569 357.3077,692.4572 316.7477,713.4672" fill="none" id="D_Held-to-E" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="311.42,716.2269,321.2513,715.6391,315.8597,713.9271,317.5717,708.5355,311.42,716.2269" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="179.715" x="404.21" y="680.4938">&#37322;&#25918;&#26102; CAS &#22833;&#36133; / &#35843;&#29992; wait()</text></g><!--link E to E_Held--><g class="link" data-entity-1="E" data-entity-2="E_Held" data-source-line="34" data-uid="lnk13" id="link_E_E_Held"><path d="M278.21,754.6769 C278.21,775.9069 278.21,803.8669 278.21,825.1169" fill="none" id="E-to-E_Held" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="278.21,831.1169,282.21,822.1169,278.21,826.1169,274.21,822.1169,278.21,831.1169" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="109.6812" x="279.21" y="797.4938">&#33719;&#21462; Monitor &#25104;&#21151;</text></g><!--link E_Held to A_Or_Wake--><g class="link" data-entity-1="E_Held" data-entity-2="A_Or_Wake" data-source-line="35" data-uid="lnk14" id="link_E_Held_A_Or_Wake"><path d="M278.21,871.6769 C278.21,892.9069 278.21,920.8669 278.21,942.1169" fill="none" id="E_Held-to-A_Or_Wake" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="278.21,948.1169,282.21,939.1169,278.21,943.1169,274.21,939.1169,278.21,948.1169" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="79.5489" x="279.21" y="914.4938">&#37322;&#25918; Monitor</text></g><!--SRC=[RPDTJnf158RlvrUSU5De90OlUz44WQGNjRsGn8kc8QCxmCHbX-oC8Tn1Mek8tw6GDDhMX5RYLsrjrM2iVuRPZt_HsLsMOckoDtFUvvnvvptP0jK8a699L40ZVD6a9K6PWT0Zo52X4yWn4qI1W4PntiJ5IU2qI7MiYWpuyeAgbGfWu291mkTdiRa4yypKm5wxjAerwrVDkJr11XC49Z9nkRkUcNOEUdQtFxXMNtTmVMGtJ-pZfltXhTs_itlD2S0SNiILWxdbV9vmmG63Jd8Y9bZCfFc201rNsBA0dCxAIB2IvsM12S6AogP95iCNf4YE6iItpmKMX4EPYe9tfkRuQzK5XWPOfvWJZdmK9gpEPxTLyyqamfgiRSdj7LM6JDnNPaRqRjTjLKUwBoP3qRczSUjRTlymL58FAH39nC5QhrbxZMX0PPyHNGjHjxvnVqZw8UM_8UbxGu97mHJ8LjTzjvjD6yAiFATSmE3wT2p-HFQbcPt7I-IV6Ab11SLw42TwzVWrn69FLJxtAM5YWzCWsGKYoeGO3onWaHbQ04rXVsKS9VnnC_14vGlkrxPrSk2StRcTiqbGpktZZuD-0ytuKDA3fa6UxplVtZkRLtAhZPA1cw1TNlrmgrLPxrkhxR_D0P8AaC7DXjphUVfUGwvS3cxQGoenekJAXTiv7UrLiN9rNnusvSQ5QXhYA1NmVjIgAPcO0sjrMwvzGiDQwCjJtFgQrVeTwhwK7ago-ztv-GKYJlt8wZJbzgRdqAz5noTv-71AvtAySGgSypTsgmTbJ4KaYb0wu4DZGKumozGQrNyzz90UynZkVNH32Fy1]--></g></svg>

<h3 id="synchronized-的可重入性"><a href="#synchronized-的可重入性" class="headerlink" title="synchronized 的可重入性"></a><code>synchronized</code> 的可重入性</h3><ul>
<li><strong>定义</strong>: 同一个线程可以多次获取它已经持有的锁，而不会导致死锁。</li>
<li><strong>实现</strong>: Monitor 内部的<code>_owner</code>记录持有线程，<code>_count</code>记录重入次数。每次重入，<code>_count</code>++；每次退出同步块，<code>_count</code>–。只有当<code>_count</code>减为 0 时，锁才真正释放。</li>
<li><strong>例子</strong>: 一个<code>synchronized</code>方法调用了同一个对象的另一个<code>synchronized</code>方法。</li>
</ul>
<h3 id="this引用逸出"><a href="#this引用逸出" class="headerlink" title="this引用逸出"></a><code>this</code>引用逸出</h3><ul>
<li><strong>危险</strong>: 在构造函数完成前，<code>this</code>引用被其他线程获取，可能导致访问到未完全初始化的对象状态，破坏<code>final</code>字段语义。</li>
<li><strong>类比</strong>: <strong>房子还没盖完，就把钥匙给了别人。</strong></li>
<li><strong>避免</strong>: 不在构造器中启动依赖当前对象状态的线程、注册监听器、调用可被子类覆盖的非 final 方法。使用工厂方法或在构造完成后再进行这些操作。</li>
</ul>
<h3 id="Object的wait-notify-notifyAll-回顾，与synchronized强关联"><a href="#Object的wait-notify-notifyAll-回顾，与synchronized强关联" class="headerlink" title="Object的wait(), notify(), notifyAll() (回顾，与synchronized强关联)"></a><code>Object</code>的<code>wait()</code>, <code>notify()</code>, <code>notifyAll()</code> (回顾，与<code>synchronized</code>强关联)</h3><ul>
<li>必须在<code>synchronized(obj)</code>代码块中由<code>obj</code>调用。</li>
<li><code>wait()</code>: 释放<code>obj</code>的锁，线程进入<code>obj</code>的<code>_WaitSet</code>等待。</li>
<li><code>notify()/notifyAll()</code>: 唤醒<code>_WaitSet</code>中一个&#x2F;所有线程，被唤醒线程需重新竞争<code>obj</code>的锁。</li>
<li><strong>类比</strong>: <strong>办公室里的会议室（锁）、休息室（_WaitSet）和广播系统（notify&#x2F;notifyAll）。</strong></li>
</ul>
<h2 id="两者在可见性、原子性、有序性上的差异"><a href="#两者在可见性、原子性、有序性上的差异" class="headerlink" title="两者在可见性、原子性、有序性上的差异"></a>两者在可见性、原子性、有序性上的差异</h2><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>volatile</code></th>
<th align="left"><code>synchronized</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>可见性</strong></td>
<td align="left"><strong>保证</strong>。对<code>volatile</code>变量的修改对其他线程立即可见。</td>
<td align="left"><strong>保证</strong>。进入同步块前从主内存读，退出同步块后写回主内存。</td>
</tr>
<tr>
<td align="left"><strong>原子性</strong></td>
<td align="left"><strong>不保证</strong>复合操作的原子性。仅保证对单个<code>volatile</code>变量的读&#x2F;写操作本身是原子的。</td>
<td align="left"><strong>保证</strong>。同步代码块内的所有操作作为一个原子单元执行，不被其他线程干扰。</td>
</tr>
<tr>
<td align="left"><strong>有序性</strong></td>
<td align="left"><strong>部分保证</strong>。禁止特定类型的指令重排序，保证<code>volatile</code>读写操作的相对顺序。</td>
<td align="left"><strong>保证</strong>。通过”一个时刻只有一个线程执行同步代码”和”管程锁定 happen-before 规则”间接保证了同步块内操作对其他线程的有序性（看起来像是串行执行）。</td>
</tr>
</tbody></table>
<p><strong>图示对比 (概念层面)</strong></p>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentStyleType="text/css" data-diagram-type="DESCRIPTION" height="570px" preserveAspectRatio="none" style="width:1279px;height:570px;background:#FFFFFF;" version="1.1" viewBox="0 0 1279 570" width="1279px" zoomAndPan="magnify"><defs/><g><!--cluster Volatile ??--><g class="cluster" data-entity="Volatile .." data-source-line="3" data-uid="ent0002" id="cluster_Volatile .."><path d="M8.5,6 L102.8583,6 A3.75,3.75 0 0 1 105.3583,8.5 L112.3583,28.2969 L277.5,28.2969 A2.5,2.5 0 0 1 280,30.7969 L280,445.68 A2.5,2.5 0 0 1 277.5,448.18 L8.5,448.18 A2.5,2.5 0 0 1 6,445.68 L6,8.5 A2.5,2.5 0 0 1 8.5,6" fill="none" style="stroke:#000000;stroke-width:1.5;"/><line style="stroke:#000000;stroke-width:1.5;" x1="6" x2="112.3583" y1="28.2969" y2="28.2969"/><text fill="#000000" font-family="sans-serif" font-size="14" font-weight="bold" lengthAdjust="spacing" textLength="93.3583" x="10" y="20.9951">Volatile &#26426;&#21046;</text></g><!--cluster Synchronized ??--><g class="cluster" data-entity="Synchronized .." data-source-line="10" data-uid="ent0007" id="cluster_Synchronized .."><path d="M637.5,6 L777.7684,6 A3.75,3.75 0 0 1 780.2684,8.5 L787.2684,28.2969 L852.5,28.2969 A2.5,2.5 0 0 1 855,30.7969 L855,560.98 A2.5,2.5 0 0 1 852.5,563.48 L637.5,563.48 A2.5,2.5 0 0 1 635,560.98 L635,8.5 A2.5,2.5 0 0 1 637.5,6" fill="none" style="stroke:#000000;stroke-width:1.5;"/><line style="stroke:#000000;stroke-width:1.5;" x1="635" x2="787.2684" y1="28.2969" y2="28.2969"/><text fill="#000000" font-family="sans-serif" font-size="14" font-weight="bold" lengthAdjust="spacing" textLength="139.2684" x="639" y="20.9951">Synchronized &#26426;&#21046;</text></g><!--entity ThreadA_V--><g class="entity" data-entity="ThreadA_V" data-source-line="4" data-uid="ent0003" id="entity_ThreadA_V"><rect fill="#F1F1F1" height="36.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="163.199" x="99.4" y="41"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="143.199" x="109.4" y="63.9951">&#32447;&#31243; A &#20889; volatile var</text></g><!--entity MainMemory_V--><g class="entity" data-entity="MainMemory_V" data-source-line="5" data-uid="ent0004" id="entity_MainMemory_V"><rect fill="#F1F1F1" height="36.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="61.9998" x="93" y="282.59"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="41.9998" x="103" y="305.5851">&#20027;&#20869;&#23384;</text></g><!--entity ThreadB_V--><g class="entity" data-entity="ThreadB_V" data-source-line="6" data-uid="ent0005" id="entity_ThreadB_V"><rect fill="#F1F1F1" height="36.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="163.2264" x="42.39" y="395.89"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="143.2264" x="52.39" y="418.8851">&#32447;&#31243; B &#35835; volatile var</text></g><!--entity NoReorder_V--><g class="entity" data-entity="NoReorder_V" data-source-line="7" data-uid="ent0006" id="entity_NoReorder_V"><rect fill="#F1F1F1" height="36.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="117.9996" x="146" y="169.29"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="97.9996" x="156" y="192.2851">&#31105;&#27490;&#37325;&#25490;&#24207;&#23631;&#38556;</text></g><!--entity ThreadA_S--><g class="entity" data-entity="ThreadA_S" data-source-line="11" data-uid="ent0008" id="entity_ThreadA_S"><rect fill="#F1F1F1" height="36.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="187.4324" x="651.28" y="41"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="167.4324" x="661.28" y="63.9951">&#32447;&#31243;A &#36827;&#20837; synchronized</text></g><!--entity MainMemory_S1--><g class="entity" data-entity="MainMemory_S1" data-source-line="12" data-uid="ent0009" id="entity_MainMemory_S1"><rect fill="#F1F1F1" height="36.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="96.9997" x="694.5" y="169.29"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="76.9997" x="704.5" y="192.2851">&#20027;&#20869;&#23384;_&#21152;&#36733;</text></g><!--entity CriticalSection_A--><g class="entity" data-entity="CriticalSection_A" data-source-line="13" data-uid="ent0010" id="entity_CriticalSection_A"><rect fill="#F1F1F1" height="36.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="161.3735" x="654.31" y="282.59"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="141.3735" x="664.31" y="305.5851">&#20020;&#30028;&#21306;&#20195;&#30721; (&#21407;&#23376;&#25191;&#34892;)</text></g><!--entity MainMemory_S2--><g class="entity" data-entity="MainMemory_S2" data-source-line="14" data-uid="ent0011" id="entity_MainMemory_S2"><rect fill="#F1F1F1" height="36.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="96.9997" x="667.5" y="395.89"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="76.9997" x="677.5" y="418.8851">&#20027;&#20869;&#23384;_&#21047;&#26032;</text></g><!--entity ThreadB_S--><g class="entity" data-entity="ThreadB_S" data-source-line="15" data-uid="ent0012" id="entity_ThreadB_S"><rect fill="#F1F1F1" height="36.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="187.4597" x="651.27" y="511.18"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="167.4597" x="661.27" y="534.1751">&#32447;&#31243;B &#36827;&#20837; synchronized</text></g><g class="entity" data-entity="GMN21" data-source-line="31" data-uid="ent0022" id="entity_GMN21"><path d="M297.34,46.58 L297.34,55.14 L262.94,59.14 L297.34,63.14 L297.34,71.7128 A0,0 0 0 0 297.34,71.7128 L616.661,71.7128 A0,0 0 0 0 616.661,71.7128 L616.661,56.58 L606.661,46.58 L297.34,46.58 A0,0 0 0 0 297.34,46.58" fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M606.661,46.58 L606.661,56.58 L616.661,56.58 L606.661,46.58" fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="298.321" x="303.34" y="63.6469">volatile: &#36731;&#37327;&#32423;&#21516;&#27493;, &#20027;&#35201;&#20445;&#35777;&#21487;&#35265;&#24615;&#21644;&#37096;&#20998;&#26377;&#24207;&#24615;</text></g><g class="entity" data-entity="GMN24" data-source-line="35" data-uid="ent0025" id="entity_GMN24"><path d="M873.82,46.58 L873.82,55.14 L839.17,59.14 L873.82,63.14 L873.82,71.7128 A0,0 0 0 0 873.82,71.7128 L1272.1883,71.7128 A0,0 0 0 0 1272.1883,71.7128 L1272.1883,56.58 L1262.1883,46.58 L873.82,46.58 A0,0 0 0 0 873.82,46.58" fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M1262.1883,46.58 L1262.1883,56.58 L1272.1883,56.58 L1262.1883,46.58" fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="377.3683" x="879.82" y="63.6469">synchronized: &#37325;&#37327;&#32423;&#21516;&#27493; (&#30456;&#23545;), &#20445;&#35777;&#21407;&#23376;&#24615;&#12289;&#21487;&#35265;&#24615;&#12289;&#26377;&#24207;&#24615;</text></g><!--link ThreadA_V to MainMemory_V--><g class="link" data-entity-1="ThreadA_V" data-entity-2="MainMemory_V" data-source-line="19" data-uid="lnk13" id="link_ThreadA_V_MainMemory_V"><path d="M155.13,77.45 C129.26,96.46 91.09,129.64 75,169.29 C58.72,209.42 85.446,252.4976 105.236,277.6076" fill="none" id="ThreadA_V-to-MainMemory_V" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="108.95,282.32,106.5206,272.7755,105.855,278.393,100.2375,277.7274,108.95,282.32" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="52.0001" x="76" y="192.0069">&#31435;&#21363;&#21047;&#26032;</text></g><!--link MainMemory_V to ThreadB_V--><g class="link" data-entity-1="MainMemory_V" data-entity-2="ThreadB_V" data-source-line="20" data-uid="lnk14" id="link_MainMemory_V_ThreadB_V"><path d="M124,319.13 C124,339.91 124,368.5 124,389.4" fill="none" id="MainMemory_V-to-ThreadB_V" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="124,395.4,128,386.4,124,390.4,120,386.4,124,395.4" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="117.0001" x="125" y="361.9569">&#31435;&#21363;&#23545;&#20854;&#20182;&#32447;&#31243;&#21487;&#35265;</text></g><!--link ThreadA_V to NoReorder_V--><g class="link" data-entity-1="ThreadA_V" data-entity-2="NoReorder_V" data-source-line="21" data-uid="lnk15" id="link_ThreadA_V_NoReorder_V"><path d="M184.34,77.71 C188.92,101.83 195.9999,139.0855 200.5699,163.1355" fill="none" id="ThreadA_V-to-NoReorder_V" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="201.69,169.03,203.9396,159.4415,200.7566,164.1179,196.0802,160.9349,201.69,169.03" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="65.0001" x="196" y="127.8569">&#31105;&#27490;&#37325;&#25490;&#24207;</text></g><!--link NoReorder_V to MainMemory_V--><g class="link" data-entity-1="NoReorder_V" data-entity-2="MainMemory_V" data-source-line="22" data-uid="lnk16" id="link_NoReorder_V_MainMemory_V"><path d="M192.34,205.83 C177.22,226.62 155.5717,256.3595 140.3617,277.2495" fill="none" id="NoReorder_V-to-MainMemory_V" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="136.83,282.1,145.3612,277.1787,139.773,278.0579,138.8938,272.4698,136.83,282.1" style="stroke:#181818;stroke-width:1;"/></g><!--link ThreadA_S to MainMemory_S1--><g class="link" data-entity-1="ThreadA_S" data-entity-2="MainMemory_S1" data-source-line="25" data-uid="lnk17" id="link_ThreadA_S_MainMemory_S1"><path d="M744.72,77.71 C744.34,101.83 743.7548,138.9807 743.3748,163.0307" fill="none" id="ThreadA_S-to-MainMemory_S1" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="743.28,169.03,747.4217,160.0943,743.359,164.0306,739.4227,159.9679,743.28,169.03" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="78.0001" x="745" y="120.3569">&#28165;&#31354;&#24037;&#20316;&#20869;&#23384;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="78.0001" x="745" y="135.4897">&#20174;&#20027;&#20869;&#23384;&#21152;&#36733;</text></g><!--link MainMemory_S1 to CriticalSection_A--><g class="link" data-entity-1="MainMemory_S1" data-entity-2="CriticalSection_A" data-source-line="26" data-uid="lnk18" id="link_MainMemory_S1_CriticalSection_A"><path d="M741.75,205.83 C740.26,226.62 738.1997,255.2254 736.6997,276.1154" fill="none" id="MainMemory_S1-to-CriticalSection_A" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="736.27,282.1,740.9043,273.4096,736.6281,277.1128,732.9249,272.8366,736.27,282.1" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="78.0001" x="740" y="248.6569">&#25191;&#34892;&#21516;&#27493;&#20195;&#30721;</text></g><!--link CriticalSection_A to MainMemory_S2--><g class="link" data-entity-1="CriticalSection_A" data-entity-2="MainMemory_S2" data-source-line="27" data-uid="lnk19" id="link_CriticalSection_A_MainMemory_S2"><path d="M732.03,319.13 C728.48,339.91 723.5902,368.5857 720.0202,389.4857" fill="none" id="CriticalSection_A-to-MainMemory_S2" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="719.01,395.4,724.4683,387.202,719.8519,390.4714,716.5825,385.855,719.01,395.4" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="104.0001" x="727" y="361.9569">&#20462;&#25913;&#21047;&#26032;&#21040;&#20027;&#20869;&#23384;</text></g><!--link MainMemory_S2 to ThreadB_S--><g class="link" data-entity-1="MainMemory_S2" data-entity-2="ThreadB_S" data-source-line="28" data-uid="lnk20" id="link_MainMemory_S2_ThreadB_S"><path d="M720.4,432.24 C725.86,453.54 733.5922,483.7774 739.0622,505.1474" fill="none" id="MainMemory_S2-to-ThreadB_S" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="740.55,510.96,742.1933,501.2492,739.3101,506.1162,734.4432,503.233,740.55,510.96" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="143.0002" x="733" y="477.2469">&#37322;&#25918;&#38145;&#21518;&#23545;&#20854;&#20182;&#32447;&#31243;&#21487;&#35265;</text></g><!--SRC=[XLFBRjD05DtxAwwwePNeebrsWPIm3WkCkW4KZPoXiPgC8yUg511IB9H7sxnKfHNG80eeJH4AAGfgKriX7uF7ZxzWd6aJssd4pffxxZddtkERtvL93gae2vAIpIa44qtK2XaCAfOqH7OoM11oIDf5EnXMjfKCqcHMj3i6hLwjm1i1uBbZJ9oBGuW1BN-0lJl87b9V0ih3ixIAKIgMtFQXriYavHBjlv-M4aWc2PnLr0AltXB5mHsOouZYjz1ptUv_zIfrkt54ZIRzrVG-TgQm9yfJhAWfh3BWsu1tiK2ajAeG-JLEtUS_1kxab9Qwa0y0GnE8eGcIzE3C7O-ZWuWR7FNREQxHcc6Ptvmp7LPfupFjj-pzdlkbjZRjUQpAcYoXZCZsB2ia6OkmLw_jayi5zisvuVX_3CUPORQ01p1BBO6bD29oFWkqD7I6fZ3B1jRN7uNYW2rmVXpI-f3x448r7pnBOuuStD3IbMMUS7kqEN1xUaGY48xV5mvH25QZXln1GX4k7KQCzeeRJCiUbPpl1htkMkCEN_4BOfcDsS9vcaAupITQoCadc-P8MpMxt-K92ukmg8jDrcXDVjhj6xvJMhsSgGjXO7318clpAWTs-u_NrcchSV-Q1Q9ex6RbdRG6oglGqTqTqXQuOzEhD1sZnvq_1ARldklMv9Cxq3cHNUpHevhtxe9MotPddwN2NWHCKk0BB9FnBoFu5_gEwq4fM7LEHypv6jFaQlmUYhs_nRao-rxK_0S0]--></g></svg>

<h2 id="性能对比与选择指南"><a href="#性能对比与选择指南" class="headerlink" title="性能对比与选择指南"></a>性能对比与选择指南</h2><ul>
<li><p><strong><code>volatile</code></strong>:</p>
<ul>
<li><strong>性能开销</strong>: 通常比<code>synchronized</code>的重量级锁小。它不涉及线程的阻塞和唤醒，主要开销在于内存屏障的插入和缓存一致性协议的执行。</li>
<li><strong>特点</strong>: 是 JVM 提供的最轻量级的同步机制。</li>
</ul>
</li>
<li><p><strong><code>synchronized</code></strong>:</p>
<ul>
<li><strong>性能开销</strong>:<ul>
<li><strong>无竞争或偏向锁&#x2F;轻量级锁</strong>: 开销很小，可能接近甚至优于<code>volatile</code>（因为<code>volatile</code>每次读写都有屏障）。</li>
<li><strong>重量级锁</strong>: 开销较大，涉及到线程阻塞、唤醒、用户态&#x2F;内核态切换。</li>
</ul>
</li>
<li><strong>优化</strong>: JVM 在 JDK 1.6 后对<code>synchronized</code>做了大量优化（锁升级），使其在很多场景下性能不再是瓶颈。</li>
</ul>
</li>
<li><p><strong>选择指南</strong>:</p>
</li>
</ul>
<ol>
<li><strong>功能需求优先</strong>:<ul>
<li>如果需要保证<strong>复合操作的原子性</strong>（例如计数器递增、检查并更新等），必须使用<code>synchronized</code>（或<code>Lock</code>，或<code>Atomic*</code>类）。<code>volatile</code>无法满足。</li>
<li>如果只是需要保证<strong>单个变量的可见性</strong>，并且对该变量的操作不依赖于其当前值（或者原子性由其他方式保证），那么<code>volatile</code>是一个更轻量级的选择。</li>
</ul>
</li>
<li><strong>锁的粒度</strong>:<ul>
<li><code>synchronized</code>可以锁定整个方法或代码块，保护多个操作。</li>
<li><code>volatile</code>只能修饰变量，作用于变量级别的读写。</li>
</ul>
</li>
<li><strong>性能考量 (在功能满足前提下)</strong>:<ul>
<li>如果锁竞争不激烈，或者同步代码块执行非常快，JVM 对<code>synchronized</code>的优化可能使其性能良好。</li>
<li>如果只是需要可见性，<code>volatile</code>通常开销更小。</li>
<li>在高竞争情况下，如果<code>synchronized</code>膨胀为重量级锁，其开销会显著增加。此时如果能用<code>Atomic*</code>类或 JUC <code>Lock</code>的特定优化（如分段锁）可能会更好。</li>
</ul>
</li>
<li><strong>代码可读性与简洁性</strong>:<ul>
<li><code>synchronized</code>用法相对简单直观，不易出错（自动释放锁）。</li>
<li><code>volatile</code>的正确使用需要对 JMM 有更深的理解，以避免误用（比如期望它保证原子性）。</li>
</ul>
</li>
</ol>
<p><strong>一句话总结选择</strong>:</p>
<ul>
<li>用<code>volatile</code>保证<strong>变量可见性</strong>和<strong>禁止指令重排</strong>（如状态标志、DCL）。</li>
<li>用<code>synchronized</code>保证<strong>代码块原子性</strong>和<strong>相关变量的可见性与有序性</strong>。</li>
</ul>
<h2 id="实际代码示例对比"><a href="#实际代码示例对比" class="headerlink" title="实际代码示例对比"></a>实际代码示例对比</h2><h3 id="示例-1：计数器实现"><a href="#示例-1：计数器实现" class="headerlink" title="示例 1：计数器实现"></a>示例 1：计数器实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 错误用法：volatile无法保证复合操作原子性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;  <span class="comment">// 这不是原子操作！</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确用法1：使用synchronized</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;  <span class="comment">// 原子性得到保证</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确用法2：使用原子类（推荐）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count.incrementAndGet();  <span class="comment">// CAS实现，性能更好</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="示例-2：单例模式中的应用"><a href="#示例-2：单例模式中的应用" class="headerlink" title="示例 2：单例模式中的应用"></a>示例 2：单例模式中的应用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ✅ volatile在双重检查锁定中的正确使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;  <span class="comment">// 必须使用volatile</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;  <span class="comment">// 第一次检查</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;  <span class="comment">// 第二次检查</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();  <span class="comment">// 防止指令重排序</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为什么需要volatile？</span></span><br><span class="line"><span class="comment">// new Singleton()分为三步：</span></span><br><span class="line"><span class="comment">// 1. 分配内存空间</span></span><br><span class="line"><span class="comment">// 2. 初始化对象</span></span><br><span class="line"><span class="comment">// 3. instance指向内存地址</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 可能的重排序：1 -&gt; 3 -&gt; 2</span></span><br><span class="line"><span class="comment">// 没有volatile时，其他线程可能看到未初始化完成的对象</span></span><br></pre></td></tr></table></figure>

<h3 id="示例-3：生产者-消费者模式"><a href="#示例-3：生产者-消费者模式" class="headerlink" title="示例 3：生产者-消费者模式"></a>示例 3：生产者-消费者模式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// volatile适用场景：简单的状态标志</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">running</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产者线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">producer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (running) &#123;  <span class="comment">// volatile读，能及时看到停止信号</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="string">&quot;data-&quot;</span> + System.currentTimeMillis());</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费者线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (running || !queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> queue.poll(<span class="number">100</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">                <span class="keyword">if</span> (data != <span class="literal">null</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Consumed: &quot;</span> + data);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        running = <span class="literal">false</span>;  <span class="comment">// volatile写，立即对所有线程可见</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试高频问题总结"><a href="#面试高频问题总结" class="headerlink" title="面试高频问题总结"></a>面试高频问题总结</h2><h3 id="⭐⭐⭐-超高频问题"><a href="#⭐⭐⭐-超高频问题" class="headerlink" title="⭐⭐⭐ 超高频问题"></a>⭐⭐⭐ 超高频问题</h3><ol>
<li><p><strong>volatile 和 synchronized 的区别是什么？</strong></p>
<ul>
<li><strong>volatile</strong>：轻量级，保证可见性和有序性，不保证原子性</li>
<li><strong>synchronized</strong>：重量级，保证原子性、可见性、有序性</li>
</ul>
</li>
<li><p><strong>volatile 能否保证原子性？为什么？</strong></p>
<ul>
<li><strong>不能</strong>。volatile 只保证读写操作本身的原子性，不保证复合操作（如 i++）的原子性</li>
<li>i++包含：读取 i 的值 → 计算 i+1 → 写回 i，三个操作在多线程下可能被打断</li>
</ul>
</li>
<li><p><strong>什么情况下使用 volatile？</strong></p>
<ul>
<li>状态标志（如停止标志）</li>
<li>双重检查锁定中的实例变量</li>
<li>读多写少的共享变量</li>
<li>不依赖当前值的变量更新</li>
</ul>
</li>
</ol>
<h3 id="⭐⭐-高频问题"><a href="#⭐⭐-高频问题" class="headerlink" title="⭐⭐ 高频问题"></a>⭐⭐ 高频问题</h3><ol start="4">
<li><p><strong>synchronized 的锁优化有哪些？</strong></p>
<ul>
<li>偏向锁 → 轻量级锁 → 重量级锁</li>
<li>自旋锁、自适应自旋</li>
<li>锁粗化、锁消除</li>
</ul>
</li>
<li><p><strong>volatile 的实现原理是什么？</strong></p>
<ul>
<li>内存屏障：LoadLoad、LoadStore、StoreLoad、StoreStore</li>
<li>缓存一致性协议（MESI）</li>
<li>CPU 的 lock 前缀指令</li>
</ul>
</li>
<li><p><strong>synchronized 和 ReentrantLock 的区别？</strong></p>
<ul>
<li>synchronized：JVM 内置、自动释放、不可中断</li>
<li>ReentrantLock：API 级别、手动释放、可中断、支持公平锁</li>
</ul>
</li>
</ol>
<h3 id="⭐-进阶问题"><a href="#⭐-进阶问题" class="headerlink" title="⭐ 进阶问题"></a>⭐ 进阶问题</h3><ol start="7">
<li><p><strong>happen-before 规则中 volatile 的作用？</strong></p>
<ul>
<li>volatile 写 happen-before 后续的 volatile 读</li>
<li>建立内存可见性的偏序关系</li>
</ul>
</li>
<li><p><strong>synchronized 在字节码层面如何实现？</strong></p>
<ul>
<li>同步代码块：monitorenter + monitorexit</li>
<li>同步方法：ACC_SYNCHRONIZED 标志</li>
</ul>
</li>
</ol>
<h2 id="最佳实践指南"><a href="#最佳实践指南" class="headerlink" title="最佳实践指南"></a>最佳实践指南</h2><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><ol>
<li><p><strong>最小化同步范围</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 不好的做法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">processData</span><span class="params">(List&lt;Data&gt; dataList)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Data data : dataList) &#123;</span><br><span class="line">        <span class="comment">// 大量非关键计算</span></span><br><span class="line">        calculate(data);</span><br><span class="line">        <span class="comment">// 真正需要同步的操作</span></span><br><span class="line">        updateSharedResource(data.getResult());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 好的做法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processData</span><span class="params">(List&lt;Data&gt; dataList)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Data data : dataList) &#123;</span><br><span class="line">        <span class="comment">// 非关键计算放在同步块外</span></span><br><span class="line">        <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> calculate(data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只同步关键操作</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            updateSharedResource(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>选择合适的锁对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankAccount</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">balanceLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();  <span class="comment">// ✅ 专用锁对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">double</span> balance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(<span class="type">double</span> amount)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (balanceLock) &#123;  <span class="comment">// 而不是synchronized(this)</span></span><br><span class="line">            <span class="keyword">if</span> (balance &gt;= amount) &#123;</span><br><span class="line">                balance -= amount;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优先使用并发工具类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ✅ 推荐使用AtomicReference</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;Config&gt; config = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 而不是</span></span><br><span class="line"><span class="comment">// private volatile Config config;</span></span><br><span class="line"><span class="comment">// public synchronized void updateConfig(Config newConfig) &#123;...&#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="性能优化建议"><a href="#性能优化建议" class="headerlink" title="性能优化建议"></a>性能优化建议</h3><ol>
<li><p><strong>减少锁竞争</strong></p>
<ul>
<li>使用 ThreadLocal 避免共享</li>
<li>使用分段锁（如 ConcurrentHashMap）</li>
<li>使用无锁数据结构</li>
</ul>
</li>
<li><p><strong>合理使用 volatile</strong></p>
<ul>
<li>避免过度使用 volatile（每次访问都有内存屏障开销）</li>
<li>读多写少场景优先考虑 volatile</li>
</ul>
</li>
<li><p><strong>监控锁竞争情况</strong></p>
<ul>
<li>使用 JProfiler、VisualVM 等工具</li>
<li>关注线程 dump 中的 BLOCKED 状态</li>
</ul>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本文的深入分析，我们全面对比了<code>volatile</code>和<code>synchronized</code>两个关键字：</p>
<h3 id="🎯-核心要点回顾"><a href="#🎯-核心要点回顾" class="headerlink" title="🎯 核心要点回顾"></a>🎯 核心要点回顾</h3><ol>
<li><p><strong>功能定位不同</strong>：</p>
<ul>
<li><code>volatile</code>：轻量级同步，解决可见性和有序性</li>
<li><code>synchronized</code>：完整同步方案，解决原子性、可见性、有序性</li>
</ul>
</li>
<li><p><strong>适用场景不同</strong>：</p>
<ul>
<li><code>volatile</code>：状态标志、DCL、读多写少</li>
<li><code>synchronized</code>：复合操作、临界区保护、完整的同步需求</li>
</ul>
</li>
<li><p><strong>性能特征不同</strong>：</p>
<ul>
<li><code>volatile</code>：无锁，开销小但功能有限</li>
<li><code>synchronized</code>：有锁优化，功能全面但开销相对较大</li>
</ul>
</li>
</ol>
<h3 id="🚀-实际应用建议"><a href="#🚀-实际应用建议" class="headerlink" title="🚀 实际应用建议"></a>🚀 实际应用建议</h3><ol>
<li><p><strong>优先级顺序</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">并发工具类 &gt; synchronized &gt; volatile &gt; 无同步</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>选择决策树</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">需要原子性？</span><br><span class="line">├── 是 → 使用synchronized或Lock或Atomic类</span><br><span class="line">└── 否 → 需要可见性？</span><br><span class="line">    ├── 是 → 考虑volatile</span><br><span class="line">    └── 否 → 无需同步</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>性能测试验证</strong>：</p>
<ul>
<li>不要凭感觉选择，通过基准测试验证</li>
<li>关注实际的并发场景和数据量</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>一个*号引发的“血案”：从replaceFirst的陷阱看代码质量</title>
    <url>/2025/06/15/bug-fixes-report/replaceFirst%E6%96%B9%E6%B3%95%E5%B8%A6%E6%9D%A5%E7%9A%84%E4%B8%80%E6%AC%A1%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>最近，我们接手了一个看似“人畜无害”的小需求：给返回数据中的实控人姓名做脱敏。</p>
<p>规则非常直白：</p>
<ul>
<li>姓名长度为 2 或 3 时，脱敏第一个字。例如：“张三” -&gt; “*三”。</li>
<li>姓名长度大于 3 时，脱敏前两个字。例如：“易烊千玺” -&gt; “**千玺”。</li>
</ul>
<p>这个需求交给了组里的一位年轻同事，他很快便提交了代码，核心逻辑大致如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 伪代码，示意同事的实现思路</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> user.getControllerName();</span><br><span class="line"><span class="keyword">if</span> (name.length() &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> name.substring(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 使用replaceFirst进行替换</span></span><br><span class="line">    <span class="keyword">return</span> name.replaceFirst(sub, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> name.substring(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 使用replaceFirst进行替换</span></span><br><span class="line">    <span class="keyword">return</span> name.replaceFirst(sub, <span class="string">&quot;**&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码 CR（Code Review）时，大家觉得逻辑虽然有点绕，但似乎也能实现功能，便合并发布了。然而，谁也没想到，一个“定时炸弹”就此埋下。</p>
<p>上线后的验证阶段就发现了异常，大量查询接口返回 500 <code>Internal Server Error</code>。我们紧急排查，发现只要查询的某些公司有关联的实控人信息，服务就会崩溃。一个原本为了“锦上添花”的脱敏功能，却成了整个核心查询链路的“断路器”。</p>
<h3 id="探案：追踪那个“Dangling-meta-character”"><a href="#探案：追踪那个“Dangling-meta-character”" class="headerlink" title="探案：追踪那个“Dangling meta character”"></a>探案：追踪那个“Dangling meta character”</h3><p>日志中的异常栈为我们指明了方向：<br><code>java.util.regex.PatternSyntaxException: Dangling meta character &#39;*&#39; near index 0</code></p>
<p>“Dangling meta character”——悬挂的元字符。熟悉正则表达式的同学立刻就警觉起来：这是典型的正则表达式语法错误。</p>
<p>可我们的代码里并没有显式地写正则表达式啊？问题出在哪？</p>
<p>我们立刻去生产数据库里捞取导致异常的数据。真相浮出水面：由于数据来自多个上游系统，其中一些系统在数据入库前，已经做了一轮脱敏。因此，我们拿到的<code>name</code>字段，其原始值可能就是“*徐坤”。</p>
<p>当同事的代码处理这个值时，<code>name.substring(0, 1)</code>截取到的恰好就是<code>*</code>。于是，代码执行变成了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;*徐坤&quot;</span>.replaceFirst(<span class="string">&quot;*&quot;</span>, <span class="string">&quot;*&quot;</span>); <span class="comment">// 灾难的开始</span></span><br></pre></td></tr></table></figure>

<p><strong><code>String.replaceFirst()</code>的第一个参数，并非普通字符串，而是一个正则表达式！</strong></p>
<p>在正则表达式的世界里，<code>*</code>是一个特殊的“元字符”，代表“匹配前面的元素零次或多次”。当它孤独地出现在开头时，前面没有任何可供它匹配的元素，它就成了一个语法不正确的、“悬挂”的元字符。正则引擎在编译这个非法的表达式时，果断抛出了异常。</p>
<blockquote>
<p><strong>临时处置：</strong> 为了快速恢复服务，我们采取了紧急措施。由于回滚流程繁琐，我们选择在数据源头动手，暂时将提供给搜索引擎的数据中的<code>*</code>替换为不影响业务的英文字母<code>x</code>，为代码修复争取了宝贵的时间。</p>
</blockquote>
<h3 id="结案：从“止血”到“根治”的两种方案"><a href="#结案：从“止血”到“根治”的两种方案" class="headerlink" title="结案：从“止血”到“根治”的两种方案"></a>结案：从“止血”到“根治”的两种方案</h3><p>问题找到了，如何修复？我们讨论了两种方案。</p>
<h4 id="方案一：最小改动，给正则打上“补丁”"><a href="#方案一：最小改动，给正则打上“补丁”" class="headerlink" title="方案一：最小改动，给正则打上“补丁”"></a>方案一：最小改动，给正则打上“补丁”</h4><p>既然问题出在特殊字符上，那我们只要告诉正则引擎：“别多想，我给你的就是个普通字符串，不要按你的语法来解析。”</p>
<p><code>java.util.regex.Pattern.quote()</code>方法正是为此而生，它能将任意字符串包裹起来，使其在正则表达式中被当作字面量处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修复方案一：使用Pattern.quote()</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> name.substring(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> name.replaceFirst(Pattern.quote(sub), <span class="string">&quot;*&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong> 改动极小，能快速修复问题。<br><strong>缺点：</strong> 治标不治本。为了一个简单的字符串替换，却动用了重量级的正则引擎，就像用牛刀来切苹果，不仅性能有损耗，代码的意图也不够清晰。</p>
<h4 id="方案二：回归本心，大道至简"><a href="#方案二：回归本心，大道至简" class="headerlink" title="方案二：回归本心，大道至简"></a>方案二：回归本心，大道至简</h4><p>我们退后一步，重新审视需求：“替换第一个&#x2F;前两个字符”，这真的需要“替换”吗？</p>
<p>它的本质，其实是**“生成一个新字符串”**，这个新字符串由<code>*</code>和原始字符串的剩余部分拼接而成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修复方案二：使用字符串拼接</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">desensitizeName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 防御性编程，处理边界情况</span></span><br><span class="line">    <span class="keyword">if</span> (name == <span class="literal">null</span> || name.length() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 核心逻辑，清晰直接</span></span><br><span class="line">    <span class="keyword">if</span> (name.length() &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;*&quot;</span> + name.substring(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;**&quot;</span> + name.substring(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方案的优势是压倒性的：</p>
<ol>
<li><strong>清晰易懂：</strong> 代码即文档，任何水平的开发者都能秒懂。</li>
<li><strong>绝对健壮：</strong> 彻底告别了正则表达式的“陷阱”，无论输入什么都不会抛出语法异常。</li>
<li><strong>性能更优：</strong> 避免了正则表达式编译和匹配的开销，执行效率更高。</li>
</ol>
<p>最终，我们选择了方案二，对代码进行了重构。</p>
<h3 id="复盘：比实现功能更重要的三件事"><a href="#复盘：比实现功能更重要的三件事" class="headerlink" title="复盘：比实现功能更重要的三件事"></a>复盘：比实现功能更重要的三件事</h3><p>一个本不该发生的低级错误，却给了我们团队一次深刻的教训。我们复盘总结，认为比“完成功能”更重要的，是以下三点：</p>
<h4 id="1-API-敬畏心：不调用“没把握”的-API"><a href="#1-API-敬畏心：不调用“没把握”的-API" class="headerlink" title="1. API 敬畏心：不调用“没把握”的 API"></a>1. API 敬畏心：不调用“没把握”的 API</h4><p><code>replace()</code>, <code>replaceFirst()</code>, <code>replaceAll()</code>这三兄弟长得很像，脾气却大不相同：</p>
<ul>
<li><code>replace()</code>: 执行<strong>字面量替换</strong>，所见即所得。</li>
<li><code>replaceFirst()</code>&#x2F;<code>replaceAll()</code>: 执行<strong>正则表达式替换</strong>，威力强大，但也暗藏杀机。</li>
</ul>
<p>在使用任何 API 前，花 30 秒按住<code>Ctrl/Cmd</code>点击方法名，看一下它的文档注释，是成本最低、收益最高的习惯。</p>
<h4 id="2-防御性编程：工程师的“肌肉记忆”"><a href="#2-防御性编程：工程师的“肌肉记忆”" class="headerlink" title="2. 防御性编程：工程师的“肌肉记忆”"></a>2. 防御性编程：工程师的“肌肉记忆”</h4><p>我们的代码不应只为“理想数据”服务。生产环境的数据永远比你想象的更“脏”。</p>
<ul>
<li><strong>处理边界：</strong> 对<code>null</code>、空字符串、以及各种预期之外的输入进行处理。</li>
<li><strong>异常捕获：</strong> 在一些非核心但又可能出错的链路上（如本次的脱敏），增加<code>try-catch</code>，记录日志并返回一个安全的默认值（如原始字符串），可以避免因为一个“小意外”而导致整个主流程崩溃。</li>
</ul>
<h4 id="3-需求理解力：拒绝成为“翻译机器”"><a href="#3-需求理解力：拒绝成为“翻译机器”" class="headerlink" title="3. 需求理解力：拒绝成为“翻译机器”"></a>3. 需求理解力：拒绝成为“翻译机器”</h4><p>“将需求文档翻译成代码”，是初级程序员的工作。而高级程序员，则会思考<strong>需求的本质</strong>。</p>
<ul>
<li><strong>分析本质：</strong> “替换”需求的本质是“拼接”。看透这一点，就能选择最简单的实现路径。</li>
<li><strong>思考周全：</strong> 在动工前，多问自己几个问题：数据来源是什么？会有哪些异常值？性能要求高吗？这几分钟的思考，能避免未来几小时甚至几天的 Debug。</li>
</ul>
<h3 id="尾声：一个关于replace的历史小故事"><a href="#尾声：一个关于replace的历史小故事" class="headerlink" title="尾声：一个关于replace的历史小故事"></a>尾声：一个关于<code>replace</code>的历史小故事</h3><p>你可能会好奇，为什么 Java 要把这几个替换方法设计得如此“混乱”？这其实是软件工程中“向后兼容”与“功能扩展”之间妥协的产物。</p>
<p>最早的<code>replace()</code>为了简单易用，只做字面量替换。后来，为了支持更强大的正则功能，又不能破坏已有<code>replace()</code>的行为（否则老代码就全挂了），于是就新增了<code>replaceFirst()</code>和<code>replaceAll()</code>。</p>
<p>理解这一点，我们不仅能记住它们的区别，更能体会到软件设计背后的严谨与权衡。</p>
]]></content>
      <categories>
        <category>生产问题</category>
        <category>代码质量</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 003: 无重复字符的最长子串 (Longest Substring Without Repeating Characters)</title>
    <url>/2025/05/25/algorithms/Leetcode-003-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<ul>
<li><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">题目地址</a></li>
</ul>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度。</p>
<p>示例 1:</p>
<p>输入: s &#x3D; “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:</p>
<p>输入: s &#x3D; “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:</p>
<p>输入: s &#x3D; “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p>
<p>提示：</p>
<p>0 &lt;&#x3D; s.length &lt;&#x3D; 5 * 104<br>s 由英文字母、数字、符号和空格组成</p>
<span id="more"></span>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><ul>
<li>使用 <strong>左右双指针</strong> 维护一个滑动窗口</li>
<li>使用 <strong>HashSet</strong> 记录当前窗口中的字符</li>
<li><strong>右指针</strong>扩展窗口，<strong>左指针</strong>收缩窗口</li>
<li>维护一个 <strong>maxLength</strong> 记录最长无重复子串的长度</li>
</ul>
<h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><ol>
<li><strong>初始化</strong>：左指针 <code>left = 0</code>，右指针 <code>right = 0</code>，空的 HashSet，<code>maxLength = 0</code></li>
<li><strong>右指针右移</strong>：<ul>
<li>如果 <code>s[right]</code> 不在 set 中，将其加入 set，更新 maxLength，右指针继续右移</li>
</ul>
</li>
<li><strong>左指针右移</strong>：<ul>
<li>如果 <code>s[right]</code> 已在 set 中，说明有重复，移动左指针并移除 <code>s[left]</code>，直到窗口中没有重复字符</li>
</ul>
</li>
<li><strong>重复步骤 2-3</strong> 直到右指针遍历完整个字符串</li>
</ol>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li><strong>时间复杂度</strong>：O(n)，每个字符最多被访问两次（一次加入，一次移除）</li>
<li><strong>空间复杂度</strong>：O(min(m,n))，其中 m 是字符集大小</li>
</ul>
<hr>
<p>然后我就没想出来更好的了，这样的解法只能击败 67% 的用户</p>
<hr>
<h3 id="优化思想（阅读题解后）"><a href="#优化思想（阅读题解后）" class="headerlink" title="优化思想（阅读题解后）"></a>优化思想（阅读题解后）</h3><p>利用 <code>HashMap</code> 优化左指针的移动，现在的<code>Set</code>逻辑左指针需要一次次右移，通过<code>HashMap</code> 记录每个值出现的最大位置，然后让左指针实现跳跃移动，也就是尽可能靠近右指针的位置。</p>
<blockquote>
<p>结果只击败了 83% 的用户，剩下的应该就是很基础的优化了。</p>
</blockquote>
<p>可以看我的究极优化版，居然还是只击败了 95.92 % 到底是为什么！ 我不理解。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="Java-实现"><a href="#Java-实现" class="headerlink" title="Java 实现"></a>Java 实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 求无重复字符的最长子串长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 输入字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 最长无重复子串的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理空字符串情况</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化滑动窗口的左右指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 记录最长无重复子串的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max_length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 使用HashSet存储当前窗口中的字符</span></span><br><span class="line">        Set&lt;Character&gt; cache = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右指针遍历整个字符串</span></span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">            <span class="keyword">if</span> (cache.contains(c)) &#123;</span><br><span class="line">                <span class="comment">// 如果当前字符已存在，移除左指针指向的字符，左指针右移</span></span><br><span class="line">                cache.remove(s.charAt(left));</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果当前字符不存在，加入集合，右指针右移</span></span><br><span class="line">                cache.add(c);</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新最大长度</span></span><br><span class="line">            max_length = Math.max(max_length, cache.size());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优化版本（使用-HashMap-记录字符位置）"><a href="#优化版本（使用-HashMap-记录字符位置）" class="headerlink" title="优化版本（使用 HashMap 记录字符位置）"></a>优化版本（使用 HashMap 记录字符位置）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 求无重复字符的最长子串长度</span></span><br><span class="line"><span class="comment">     * 使用HashMap优化滑动窗口，实现左指针的跳跃移动</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 输入字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 最长无重复子串的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理空字符串情况</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化滑动窗口的左边界和最大长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max_length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 使用HashMap记录每个字符最后出现的位置</span></span><br><span class="line">        Map&lt;Character, Integer&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历字符串，right作为滑动窗口的右边界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; s.length(); right++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">            <span class="comment">// 如果当前字符已存在且位置在left之后，更新left到重复字符的下一个位置</span></span><br><span class="line">            <span class="keyword">if</span> (cache.containsKey(c) &amp;&amp; cache.get(c) &gt;= left) &#123;</span><br><span class="line">                left = cache.get(c) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新当前字符的位置</span></span><br><span class="line">            cache.put(c, right);</span><br><span class="line">            <span class="comment">// 更新最大长度</span></span><br><span class="line">            max_length = Math.max(max_length, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="究极优化版-（我的极限）"><a href="#究极优化版-（我的极限）" class="headerlink" title="究极优化版 （我的极限）"></a>究极优化版 （我的极限）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 求无重复字符的最长子串长度</span></span><br><span class="line"><span class="comment">     * 使用数组优化滑动窗口，实现O(1)时间复杂度的字符位置查找</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 输入字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 最长无重复子串的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理空字符串情况</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将字符串转换为字符数组，避免重复调用charAt()</span></span><br><span class="line">        <span class="type">char</span>[] cs = s.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化滑动窗口的左边界和最大长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max_length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用数组记录每个字符最后出现的位置，初始值设为-1</span></span><br><span class="line">        <span class="comment">// 数组大小为128，覆盖ASCII字符集</span></span><br><span class="line">        <span class="type">int</span>[] cache = &#123;</span><br><span class="line">            -<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,</span><br><span class="line">            -<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,</span><br><span class="line">            -<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,</span><br><span class="line">            -<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历字符串，right作为滑动窗口的右边界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; cs.length; right++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> cs[right];</span><br><span class="line">            <span class="comment">// 如果当前字符已存在且位置在left之后，更新left到重复字符的下一个位置</span></span><br><span class="line">            <span class="keyword">if</span> (cache[c] &gt; -<span class="number">1</span> &amp;&amp; cache[c] &gt;= left) &#123;</span><br><span class="line">                left = cache[c] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新当前字符的位置</span></span><br><span class="line">            cache[c] = right;</span><br><span class="line">            <span class="comment">// 更新最大长度</span></span><br><span class="line">            max_length = Math.max(max_length, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="算法复杂度分析"><a href="#算法复杂度分析" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h2><table>
<thead>
<tr>
<th>方法</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>优缺点</th>
</tr>
</thead>
<tbody><tr>
<td>HashSet 版</td>
<td>O(n)</td>
<td>O(min(m,n))</td>
<td>逻辑清晰，易理解</td>
</tr>
<tr>
<td>HashMap 版</td>
<td>O(n)</td>
<td>O(min(m,n))</td>
<td>更优化，左指针可以跳跃式移动</td>
</tr>
</tbody></table>
<h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Solution</span> <span class="variable">solution</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试用例1</span></span><br><span class="line">        System.out.println(solution.lengthOfLongestSubstring(<span class="string">&quot;abcabcbb&quot;</span>)); <span class="comment">// 输出: 3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试用例2</span></span><br><span class="line">        System.out.println(solution.lengthOfLongestSubstring(<span class="string">&quot;bbbbb&quot;</span>));   <span class="comment">// 输出: 1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试用例3</span></span><br><span class="line">        System.out.println(solution.lengthOfLongestSubstring(<span class="string">&quot;pwwkew&quot;</span>));  <span class="comment">// 输出: 3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 边界用例</span></span><br><span class="line">        System.out.println(solution.lengthOfLongestSubstring(<span class="string">&quot;&quot;</span>));        <span class="comment">// 输出: 0</span></span><br><span class="line">        System.out.println(solution.lengthOfLongestSubstring(<span class="string">&quot;a&quot;</span>));       <span class="comment">// 输出: 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关键要点"><a href="#关键要点" class="headerlink" title="关键要点"></a>关键要点</h2><ol>
<li><strong>滑动窗口思想</strong>：维护一个动态大小的窗口，保证窗口内无重复字符</li>
<li><strong>双指针协作</strong>：右指针扩展，左指针收缩，避免暴力枚举</li>
<li><strong>哈希表优化</strong>：使用 Set 检查重复，使用 Map 记录位置实现跳跃</li>
<li><strong>边界处理</strong>：注意空字符串和单字符的情况</li>
</ol>
<h2 id="想到的内容（极限优化中对自动装箱的理解）"><a href="#想到的内容（极限优化中对自动装箱的理解）" class="headerlink" title="想到的内容（极限优化中对自动装箱的理解）"></a>想到的内容（极限优化中对自动装箱的理解）</h2><ul>
<li>自动装箱&#x2F;拆箱 (Autoboxing&#x2F;Unboxing)： 比如 Integer i &#x3D; 100; (装箱) 和 int j &#x3D; i; (拆箱)，虽然方便，但确实会创建额外的对象或进行方法调用，在高频循环中可能累积成不可忽视的性能开销。</li>
<li>数组 vs. <code>HashMap&lt;Character, Integer&gt;</code>：<ul>
<li><code>HashMap&lt;Character, Integer&gt;</code> 中的 Character 和 Integer 都是包装类。当你频繁 put(char, int) 时，char 会自动装箱成 Character，int 会自动装箱成 Integer。频繁的 get(char) 返回 Integer，如果需要 int 值，还需要拆箱。这些都涉及对象创建和方法调用。<code>int[] cache = new int[128]; cache[c] = right;</code> 这里 c (char)可以直接作为（或转换为）数组索引，right (int) 是基本类型。整个过程几乎没有对象创建和装箱拆箱的开销。</li>
</ul>
</li>
</ul>
<h2 id="相似题目"><a href="#相似题目" class="headerlink" title="相似题目"></a>相似题目</h2><ul>
<li><a href="https://leetcode-cn.com/problems/minimum-window-substring/">LeetCode 076: 最小覆盖子串</a></li>
<li><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">LeetCode 438: 找到字符串中所有字母异位词</a></li>
<li><a href="https://leetcode-cn.com/problems/permutation-in-string/">LeetCode 567: 字符串的排列</a></li>
</ul>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>中等</tag>
        <tag>滑动窗口</tag>
        <tag>双指针</tag>
        <tag>HashSet</tag>
        <tag>CodeTop</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 146: LRU 缓存 (LRU Cache)</title>
    <url>/2025/05/25/algorithms/Leetcode-146-LRU%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<ul>
<li><a href="https://leetcode.cn/problems/lru-cache/description/">题目地址</a></li>
</ul>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请你设计并实现一个满足 LRU (最近最少使用) 缓存 约束的数据结构。</p>
<p>实现 <code>LRUCache</code> 类：</p>
<ul>
<li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量 <code>capacity</code> 初始化 LRU 缓存</li>
<li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code>。</li>
<li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 <strong>逐出</strong> 最近最少使用的关键字。</li>
</ul>
<p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]</span><br><span class="line">[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, 1, null, -1, null, -1, 3, 4]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">LRUCache lRUCache = new LRUCache(2);</span><br><span class="line">lRUCache.put(1, 1); // 缓存是 &#123;1=1&#125;</span><br><span class="line">lRUCache.put(2, 2); // 缓存是 &#123;1=1, 2=2&#125;</span><br><span class="line">lRUCache.get(1);    // 返回 1</span><br><span class="line">lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;</span><br><span class="line">lRUCache.get(2);    // 返回 -1 (未找到)</span><br><span class="line">lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;</span><br><span class="line">lRUCache.get(1);    // 返回 -1 (未找到)</span><br><span class="line">lRUCache.get(3);    // 返回 3</span><br><span class="line">lRUCache.get(4);    // 返回 4</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= capacity &lt;= 3000</code></li>
<li><code>0 &lt;= key &lt;= 10000</code></li>
<li><code>0 &lt;= value &lt;= 10^5</code></li>
<li>最多调用 <code>2 * 10^5</code> 次 <code>get</code> 和 <code>put</code></li>
</ul>
<span id="more"></span>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>分析题目，我想到的第一点是 FIFO 的队列结构，但是仔细一看呢感觉如果要把最近一次使用的找到并且移动队列的内容物可能效率非常的低下。<br>那么我觉得需要回到 cache 的本质，我以前有在工作中实现过简单的 jvm 缓存，就是一个 ConcurrentHashMap，所以我觉得对于这个题目也该是用 Map 存储。<br>然后该如何实现快速找到头尾，我记得 array list 是坐标查找最快，linkedList 好像是插入速度最快。<br>那我该怎么用链表实现头尾呢？我大概感觉是新的头插，满了把尾巴移走。如果 get map 有数呢就把它重新移动到头上。<br>那移走之后原先位置的那个元素怎么办呢，哦 remove 方法吧。大概明白了，开搞。</p>
<hr>
<p>居然速度只击败了 5%。。。看来要问问 ai 了</p>
<blockquote>
<p>你的 HashMap 保证了根据 key 查找 value 是快的。但是，维护访问顺序的 LinkedList<Integer> list 出了问题：<br>get(int key) 方法中：<br>list.remove(integerKey); 这一步是性能杀手。LinkedList 要删除一个特定值的元素，它不知道这个元素在哪里，所以它必须从头到尾遍历链表来找到这个 integerKey，然后才能删除它。这个操作的时间复杂度是 O(N)，N 是链表当前的长度（即缓存中的元素数量）。<br>list.addFirst(integerKey); 这是 O(1) 的。<br>put(int key, int value) 方法中：<br>if (this.cache.containsKey(integerKey)) { this.list.remove(integerKey); … } 同样，如果 key 已存在，这里的 list.remove(integerKey) 也是 O(N) 的。<br>淘汰机制中 this.list.removeLast(); 是 O(1) 的，这部分没问题。<br>this.list.addFirst(integerKey); 是 O(1) 的。<br>由于 get 和 put 操作中都可能涉及到 O(N) 的链表元素查找和删除，导致整体性能大幅下降。</p>
</blockquote>
<hr>
<p>…</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>5 % 击败</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 第一版实现（性能较差，仅击败5%）</span></span><br><span class="line"><span class="comment"> * 使用 HashMap + LinkedList 的组合</span></span><br><span class="line"><span class="comment"> * 主要问题在于 LinkedList 的 remove 操作需要 O(n) 的时间复杂度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">cacheCapacity</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cacheCapacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integerKey</span> <span class="operator">=</span> Integer.valueOf(key);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.cache.containsKey(integerKey)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        list.remove(integerKey);  <span class="comment">// O(n) 操作，性能瓶颈</span></span><br><span class="line">        list.addFirst(integerKey);</span><br><span class="line">        <span class="keyword">return</span> cache.get(integerKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integerKey</span> <span class="operator">=</span> Integer.valueOf(key);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.cache.containsKey(integerKey)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.list.remove(integerKey);  <span class="comment">// O(n) 操作，性能瓶颈</span></span><br><span class="line">            <span class="built_in">this</span>.cache.remove(integerKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.cache.size() &gt;= cacheCapacity)&#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">lastKey</span> <span class="operator">=</span> <span class="built_in">this</span>.list.getLast();</span><br><span class="line">            <span class="built_in">this</span>.list.removeLast();</span><br><span class="line">            <span class="built_in">this</span>.cache.remove(lastKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.list.addFirst(integerKey);</span><br><span class="line">        <span class="built_in">this</span>.cache.put(integerKey, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 优化版本（性能提升至击败60%）</span></span><br><span class="line"><span class="comment"> * 使用 HashMap + 双向链表 的组合</span></span><br><span class="line"><span class="comment"> * 通过自定义双向链表实现 O(1) 的插入和删除操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">cacheCapacity</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Node&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双向链表节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Integer key;</span><br><span class="line">        <span class="keyword">private</span> Integer value;</span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line">        <span class="keyword">private</span> Node prev;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虚拟头尾节点，简化边界处理</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Node</span> <span class="variable">tail</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cacheCapacity = capacity;</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integerKey</span> <span class="operator">=</span> Integer.valueOf(key);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.cache.containsKey(integerKey)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>.cache.get(integerKey);</span><br><span class="line">        <span class="built_in">this</span>.moveToHead(node);  <span class="comment">// O(1) 操作</span></span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integerKey</span> <span class="operator">=</span> Integer.valueOf(key);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.cache.containsKey(integerKey)) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>.cache.get(integerKey);</span><br><span class="line">            node.value = value;</span><br><span class="line">            <span class="built_in">this</span>.moveToHead(node);  <span class="comment">// O(1) 操作</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">            node.key = key;</span><br><span class="line">            node.value = value;</span><br><span class="line">            <span class="built_in">this</span>.cache.put(key, node);</span><br><span class="line">            <span class="built_in">this</span>.addToHead(node);  <span class="comment">// O(1) 操作</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.cache.size() &gt; <span class="built_in">this</span>.cacheCapacity) &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">tail</span> <span class="operator">=</span> <span class="built_in">this</span>.removeTail();  <span class="comment">// O(1) 操作</span></span><br><span class="line">                <span class="built_in">this</span>.cache.remove(tail.key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将节点添加到链表头部</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addToHead</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        node.prev = <span class="built_in">this</span>.head;</span><br><span class="line">        node.next = <span class="built_in">this</span>.head.next;</span><br><span class="line">        <span class="built_in">this</span>.head.next.prev = node;</span><br><span class="line">        <span class="built_in">this</span>.head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将节点移动到链表头部</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">moveToHead</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.removeNode(node);</span><br><span class="line">        <span class="built_in">this</span>.addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从链表中移除节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除链表尾部节点</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">removeTail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>.tail.prev;</span><br><span class="line">        <span class="built_in">this</span>.removeNode(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>…</p>
<h2 id="算法复杂度分析"><a href="#算法复杂度分析" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h2><h3 id="第一版实现（HashMap-LinkedList）"><a href="#第一版实现（HashMap-LinkedList）" class="headerlink" title="第一版实现（HashMap + LinkedList）"></a>第一版实现（HashMap + LinkedList）</h3><ul>
<li><strong>时间复杂度：</strong><ul>
<li><code>get(key)</code>: O(n) - 由于 LinkedList 的 remove 操作需要遍历链表</li>
<li><code>put(key, value)</code>: O(n) - 同样因为 remove 操作</li>
</ul>
</li>
<li><strong>空间复杂度：</strong> O(capacity) - 存储最多 capacity 个键值对</li>
</ul>
<h3 id="优化版实现（HashMap-双向链表）"><a href="#优化版实现（HashMap-双向链表）" class="headerlink" title="优化版实现（HashMap + 双向链表）"></a>优化版实现（HashMap + 双向链表）</h3><ul>
<li><strong>时间复杂度：</strong><ul>
<li><code>get(key)</code>: O(1) - HashMap 查找 + 双向链表节点移动都是常数时间</li>
<li><code>put(key, value)</code>: O(1) - 所有操作都是常数时间</li>
</ul>
</li>
<li><strong>空间复杂度：</strong> O(capacity) - 存储最多 capacity 个键值对和对应的链表节点</li>
</ul>
<h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRUCacheTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 基本功能测试</span></span><br><span class="line">        <span class="type">LRUCache</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LRUCache</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试用例1：基本的put和get操作</span></span><br><span class="line">        cache.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        cache.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">assert</span> cache.get(<span class="number">1</span>) == <span class="number">1</span>; <span class="comment">// 返回 1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试用例2：容量满时的淘汰机制</span></span><br><span class="line">        cache.put(<span class="number">3</span>, <span class="number">3</span>); <span class="comment">// 淘汰 key 2</span></span><br><span class="line">        <span class="keyword">assert</span> cache.get(<span class="number">2</span>) == -<span class="number">1</span>; <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试用例3：更新已存在的key</span></span><br><span class="line">        cache.put(<span class="number">4</span>, <span class="number">4</span>); <span class="comment">// 淘汰 key 1</span></span><br><span class="line">        <span class="keyword">assert</span> cache.get(<span class="number">1</span>) == -<span class="number">1</span>; <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">        <span class="keyword">assert</span> cache.get(<span class="number">3</span>) == <span class="number">3</span>; <span class="comment">// 返回 3</span></span><br><span class="line">        <span class="keyword">assert</span> cache.get(<span class="number">4</span>) == <span class="number">4</span>; <span class="comment">// 返回 4</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试用例4：边界情况</span></span><br><span class="line">        <span class="type">LRUCache</span> <span class="variable">cache2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LRUCache</span>(<span class="number">1</span>);</span><br><span class="line">        cache2.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        cache2.put(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// 淘汰 key 1</span></span><br><span class="line">        <span class="keyword">assert</span> cache2.get(<span class="number">1</span>) == -<span class="number">1</span>; <span class="comment">// 返回 -1</span></span><br><span class="line">        <span class="keyword">assert</span> cache2.get(<span class="number">2</span>) == <span class="number">2</span>; <span class="comment">// 返回 2</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;所有测试用例通过！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关键要点"><a href="#关键要点" class="headerlink" title="关键要点"></a>关键要点</h2><h3 id="1-核心思想"><a href="#1-核心思想" class="headerlink" title="1. 核心思想"></a>1. 核心思想</h3><ul>
<li><strong>LRU (Least Recently Used)</strong> 缓存需要同时支持快速查找和维护访问顺序</li>
<li>使用 <strong>HashMap + 双向链表</strong> 的组合是最优解决方案</li>
</ul>
<h3 id="2-数据结构选择"><a href="#2-数据结构选择" class="headerlink" title="2. 数据结构选择"></a>2. 数据结构选择</h3><ul>
<li><strong>HashMap</strong>: 提供 O(1) 的查找、插入、删除操作</li>
<li><strong>双向链表</strong>: 提供 O(1) 的节点移动、插入、删除操作</li>
<li><strong>避免使用 LinkedList</strong>: 其 <code>remove(Object)</code> 方法是 O(n) 的</li>
</ul>
<h3 id="3-设计技巧"><a href="#3-设计技巧" class="headerlink" title="3. 设计技巧"></a>3. 设计技巧</h3><ul>
<li><strong>虚拟头尾节点</strong>: 简化边界情况的处理，避免空指针判断</li>
<li><strong>HashMap 存储节点引用</strong>: 直接存储链表节点，而不是值，便于快速定位和移动</li>
</ul>
<h3 id="4-操作流程"><a href="#4-操作流程" class="headerlink" title="4. 操作流程"></a>4. 操作流程</h3><ul>
<li><strong>get 操作</strong>:<ol>
<li>在 HashMap 中查找节点</li>
<li>如果存在，将节点移动到链表头部</li>
<li>返回节点值</li>
</ol>
</li>
<li><strong>put 操作</strong>:<ol>
<li>如果 key 已存在，更新值并移动到头部</li>
<li>如果 key 不存在，创建新节点并添加到头部</li>
<li>如果超出容量，删除尾部节点</li>
</ol>
</li>
</ul>
<h3 id="5-性能优化要点"><a href="#5-性能优化要点" class="headerlink" title="5. 性能优化要点"></a>5. 性能优化要点</h3><ul>
<li>所有操作必须是 O(1) 时间复杂度</li>
<li>避免在链表中进行线性搜索</li>
<li>使用节点引用而不是值进行 HashMap 存储</li>
</ul>
<h2 id="相似题目"><a href="#相似题目" class="headerlink" title="相似题目"></a>相似题目</h2><ul>
<li><a href="https://leetcode-cn.com/problems/lfu-cache/">LeetCode 460: LFU 缓存</a></li>
<li><a href="https://leetcode-cn.com/problems/design-linked-list/">LeetCode 707: 设计链表</a></li>
<li><a href="https://leetcode-cn.com/problems/all-oone-data-structure/">LeetCode 432: 全 O(1) 的数据结构</a></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>中等</tag>
        <tag>CodeTop</tag>
        <tag>设计</tag>
        <tag>哈希表</tag>
        <tag>链表</tag>
        <tag>双向链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 206: 反转链表 (Reverse Linked List)</title>
    <url>/2025/05/25/algorithms/Leetcode-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<ul>
<li><a href="https://leetcode.cn/problems/reverse-linked-list/description/">题目地址</a></li>
</ul>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p>
<p>示例 1:</p>
<p>输入：head &#x3D; [1,2,3,4,5]<br>输出：[5,4,3,2,1]</p>
<p>示例 2:</p>
<p>输入：head &#x3D; [1,2]<br>输出：[2,1]</p>
<p>示例 3:</p>
<p>输入：head &#x3D; []<br>输出：[]</p>
<p>提示：</p>
<ul>
<li>链表中节点的数目范围是 [0, 5000]</li>
<li>-5000 &lt;&#x3D; Node.val &lt;&#x3D; 5000</li>
</ul>
<p><strong>进阶：</strong> 链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p>
<span id="more"></span>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>反转链表是链表操作的经典问题，主要有两种解法：</p>
<ul>
<li><strong>迭代法（递推法）</strong>：使用三个指针遍历链表，逐个反转节点指向</li>
<li><strong>递归法</strong>：利用递归栈的特性，从链表尾部开始反转</li>
</ul>
<h3 id="方法一：迭代法（推荐）"><a href="#方法一：迭代法（推荐）" class="headerlink" title="方法一：迭代法（推荐）"></a>方法一：迭代法（推荐）</h3><h4 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h4><ol>
<li><strong>三指针技巧</strong>：维护 <code>prev</code>、<code>curr</code>、<code>next</code> 三个指针</li>
<li><strong>逐个反转</strong>：将当前节点的 <code>next</code> 指向前一个节点</li>
<li><strong>指针移动</strong>：三个指针同时向前移动一位</li>
<li><strong>边界处理</strong>：处理空链表和单节点情况</li>
</ol>
<h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><ol>
<li><strong>初始化</strong>：<code>prev = null</code>，<code>curr = head</code></li>
<li><strong>遍历链表</strong>：<ul>
<li>保存下一个节点：<code>next = curr.next</code></li>
<li>反转当前节点：<code>curr.next = prev</code></li>
<li>移动指针：<code>prev = curr</code>，<code>curr = next</code></li>
</ul>
</li>
<li><strong>返回结果</strong>：<code>prev</code> 就是新的头节点</li>
</ol>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul>
<li><strong>时间复杂度</strong>：O(n)，需要遍历链表一次</li>
<li><strong>空间复杂度</strong>：O(1)，只使用常数个额外变量</li>
</ul>
<h3 id="方法二：递归法"><a href="#方法二：递归法" class="headerlink" title="方法二：递归法"></a>方法二：递归法</h3><h4 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h4><ol>
<li><strong>递归终止条件</strong>：到达链表尾部或空节点</li>
<li><strong>递归调用</strong>：先递归到链表尾部</li>
<li><strong>回溯反转</strong>：在回溯过程中逐个反转节点指向</li>
<li><strong>返回新头</strong>：递归过程中传递新的头节点</li>
</ol>
<h4 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h4><ol>
<li><strong>递归终止</strong>：如果 <code>head</code> 为空或 <code>head.next</code> 为空，返回 <code>head</code></li>
<li><strong>递归调用</strong>：<code>newHead = reverseList(head.next)</code></li>
<li><strong>反转操作</strong>：<code>head.next.next = head</code>，<code>head.next = null</code></li>
<li><strong>返回结果</strong>：返回 <code>newHead</code></li>
</ol>
<h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul>
<li><strong>时间复杂度</strong>：O(n)，需要递归访问每个节点</li>
<li><strong>空间复杂度</strong>：O(n)，递归调用栈的深度</li>
</ul>
<hr>
<h3 id="算法对比"><a href="#算法对比" class="headerlink" title="算法对比"></a>算法对比</h3><p>迭代法在空间复杂度上更优，但递归法代码更简洁，思路更清晰。</p>
<hr>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="Java-实现"><a href="#Java-实现" class="headerlink" title="Java 实现"></a>Java 实现</h3><h4 id="方法一：迭代法"><a href="#方法一：迭代法" class="headerlink" title="方法一：迭代法"></a>方法一：迭代法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反转链表 - 迭代法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head 链表头节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 反转后的链表头节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// 迭代法实现</span></span><br><span class="line">        <span class="comment">// 核心思路：使用三个指针逐个反转节点指向</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 初始化三个指针</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="comment">// 2. 遍历链表并反转指向</span></span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">            temp = curr.next;</span><br><span class="line">            curr.next = curr;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 返回新的头节点</span></span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法二：递归法-1"><a href="#方法二：递归法-1" class="headerlink" title="方法二：递归法"></a>方法二：递归法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反转链表 - 递归法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head 链表头节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 反转后的链表头节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// 递归法实现</span></span><br><span class="line">        <span class="comment">// 核心思路：递归到尾部，在回溯过程中反转指向</span></span><br><span class="line">        <span class="comment">// 1. 递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 递归调用</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line">        <span class="comment">// 3. 反转当前节点</span></span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 4. 返回新头节点</span></span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="算法复杂度分析"><a href="#算法复杂度分析" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h2><table>
<thead>
<tr>
<th>方法</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>优缺点</th>
</tr>
</thead>
<tbody><tr>
<td>迭代法</td>
<td>O(n)</td>
<td>O(1)</td>
<td>空间效率高，逻辑直观</td>
</tr>
<tr>
<td>递归法</td>
<td>O(n)</td>
<td>O(n)</td>
<td>代码简洁，但占用递归栈</td>
</tr>
</tbody></table>
<h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Solution</span> <span class="variable">solution</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试用例1：正常链表</span></span><br><span class="line">        <span class="comment">// 输入: [1,2,3,4,5]</span></span><br><span class="line">        <span class="comment">// 输出: [5,4,3,2,1]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试用例2：两个节点</span></span><br><span class="line">        <span class="comment">// 输入: [1,2]</span></span><br><span class="line">        <span class="comment">// 输出: [2,1]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试用例3：单个节点</span></span><br><span class="line">        <span class="comment">// 输入: [1]</span></span><br><span class="line">        <span class="comment">// 输出: [1]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 边界用例：空链表</span></span><br><span class="line">        <span class="comment">// 输入: []</span></span><br><span class="line">        <span class="comment">// 输出: []</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关键要点"><a href="#关键要点" class="headerlink" title="关键要点"></a>关键要点</h2><ol>
<li><strong>三指针技巧</strong>：迭代法的核心是维护三个指针的正确移动</li>
<li><strong>递归思维</strong>：递归法需要理解”先递归到尾，再回溯反转”的过程</li>
<li><strong>边界处理</strong>：注意空链表和单节点的特殊情况</li>
<li><strong>指针操作</strong>：小心处理指针的赋值顺序，避免丢失节点</li>
<li><strong>空间权衡</strong>：根据实际需求选择迭代或递归实现</li>
</ol>
<h2 id="进阶思考"><a href="#进阶思考" class="headerlink" title="进阶思考"></a>进阶思考</h2><ol>
<li><strong>尾递归优化</strong>：能否将递归法改写为尾递归形式？</li>
<li><strong>链表分段反转</strong>：如何实现反转链表的前 K 个节点？</li>
<li><strong>双向链表</strong>：双向链表的反转有什么不同？</li>
</ol>
<h2 id="相似题目"><a href="#相似题目" class="headerlink" title="相似题目"></a>相似题目</h2><ul>
<li><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">LeetCode 092: 反转链表 II</a></li>
<li><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">LeetCode 025: K 个一组翻转链表</a></li>
<li><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">LeetCode 024: 两两交换链表中的节点</a></li>
<li><a href="https://leetcode-cn.com/problems/reorder-list/">LeetCode 143: 重排链表</a></li>
</ul>
]]></content>
      <categories>
        <category>算法题解</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>CodeTop</tag>
        <tag>链表</tag>
        <tag>简单</tag>
        <tag>递归</tag>
        <tag>迭代</tag>
      </tags>
  </entry>
</search>

<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"makotogu.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Volatile 与 Synchronized 深度对比写在前面在前面的文章中，我们深入学习了Java线程机制和Java内存模型的理论基础。现在是时候将理论与实践结合，深入对比两个最重要的并发关键字：volatile 和 synchronized。 在日常开发和技术面试中，这两个关键字的使用场景和区别是被问得最多的话题之一。很多开发者容易混淆它们的作用范围，甚至误以为 volatile 能够保证原">
<meta property="og:type" content="article">
<meta property="og:title" content="Volatile 与 Synchronized">
<meta property="og:url" content="https://makotogu.github.io/2025/05/23/Java-Threads/volatile-%E4%B8%8E-synchronized/index.html">
<meta property="og:site_name" content="makotogu的小博客">
<meta property="og:description" content="Volatile 与 Synchronized 深度对比写在前面在前面的文章中，我们深入学习了Java线程机制和Java内存模型的理论基础。现在是时候将理论与实践结合，深入对比两个最重要的并发关键字：volatile 和 synchronized。 在日常开发和技术面试中，这两个关键字的使用场景和区别是被问得最多的话题之一。很多开发者容易混淆它们的作用范围，甚至误以为 volatile 能够保证原">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-05-23T07:58:43.000Z">
<meta property="article:modified_time" content="2025-05-26T14:49:16.679Z">
<meta property="article:author" content="makotogu">
<meta property="article:tag" content="线程">
<meta property="article:tag" content="并发编程">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://makotogu.github.io/2025/05/23/Java-Threads/volatile-%E4%B8%8E-synchronized/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Volatile 与 Synchronized | makotogu的小博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">makotogu的小博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录生活，记录技术</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/makotogu" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://makotogu.github.io/2025/05/23/Java-Threads/volatile-%E4%B8%8E-synchronized/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="makotogu">
      <meta itemprop="description" content="Java|数据库|分布式|架构<br>分享我的学习之路">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="makotogu的小博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Volatile 与 Synchronized
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-05-23 15:58:43" itemprop="dateCreated datePublished" datetime="2025-05-23T15:58:43+08:00">2025-05-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-05-26 22:49:16" itemprop="dateModified" datetime="2025-05-26T22:49:16+08:00">2025-05-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">技术分享</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Volatile-与-Synchronized-深度对比"><a href="#Volatile-与-Synchronized-深度对比" class="headerlink" title="Volatile 与 Synchronized 深度对比"></a><code>Volatile</code> 与 <code>Synchronized</code> 深度对比</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在前面的文章中，我们深入学习了<a href="/2025/05/17/Java-Threads/Java%E7%9A%84%E7%BA%BF%E7%A8%8B/" title="Java的线程">Java线程机制</a>和<a href="/2025/05/19/Java-Threads/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-JMM/" title="Java 内存模型(JMM)">Java内存模型</a>的理论基础。现在是时候将理论与实践结合，深入对比两个最重要的并发关键字：<code>volatile</code> 和 <code>synchronized</code>。</p>
<p>在日常开发和技术面试中，这两个关键字的使用场景和区别是被问得最多的话题之一。很多开发者容易混淆它们的作用范围，甚至误以为 <code>volatile</code> 能够保证原子性。</p>
<blockquote>
<p><strong>实际案例</strong>：在优化一个配置热更新模块时，最初使用了 <code>volatile boolean configChanged</code> 来标识配置变更。但在高并发场景下发现，多个线程同时处理配置更新时出现了数据不一致问题。后来分析发现，<code>volatile</code> 只能保证可见性，而配置更新是一个复合操作，需要使用 <code>synchronized</code> 来保证原子性。这个经历让我深刻理解了两者的根本区别。</p>
</blockquote>
<ul>
<li>🎯 <strong>精通底层原理</strong>：理解 volatile 和 synchronized 的实现机制</li>
<li>🔍 <strong>准确识别场景</strong>：知道何时使用哪个关键字</li>
<li>⚖️ <strong>权衡性能影响</strong>：理解两者的性能差异和优化策略</li>
<li>💡 <strong>避免常见陷阱</strong>：掌握正确的使用方式，避免常见错误</li>
</ul>
<span id="more"></span>

<h2 id="为什么要深入对比这两个关键字？"><a href="#为什么要深入对比这两个关键字？" class="headerlink" title="为什么要深入对比这两个关键字？"></a>为什么要深入对比这两个关键字？</h2><p>基于 JMM 的三大特性（可见性、原子性、有序性），<code>volatile</code> 和 <code>synchronized</code> 提供了不同层次的保证：</p>
<ul>
<li><strong>volatile</strong>：轻量级同步，主要解决可见性和有序性问题</li>
<li><strong>synchronized</strong>：重量级同步，全面解决三大特性问题</li>
</ul>
<p>理解它们的差异，有助于：</p>
<ul>
<li><strong>编写正确的并发代码</strong>：避免线程安全问题</li>
<li><strong>优化程序性能</strong>：选择合适的同步机制</li>
<li><strong>提升技术面试表现</strong>：这是面试官最爱考查的知识点</li>
</ul>
<p><code>volatile</code> 和 <code>synchronized</code> 都是 Java 中用于保证多线程环境下共享变量线程安全的关键字，但它们在实现机制、保证的特性范围以及使用场景上有显著差异。</p>
<h2 id="volatile-关键字原理与应用场景"><a href="#volatile-关键字原理与应用场景" class="headerlink" title="volatile 关键字原理与应用场景"></a><code>volatile</code> 关键字原理与应用场景</h2><h3 id="原理核心-基于-JMM"><a href="#原理核心-基于-JMM" class="headerlink" title="原理核心 (基于 JMM):"></a>原理核心 (基于 JMM):</h3><ul>
<li><strong>保证可见性</strong>:<ul>
<li>当一个线程修改了被<code>volatile</code>修饰的变量的值，JMM 会确保这个修改立即被刷新到主内存。</li>
<li>当另一个线程读取这个<code>volatile</code>变量时，JMM 会确保该线程的工作内存中此变量的副本失效，并从主内存重新加载最新值。</li>
<li><strong>实现机制</strong>: 主要通过在读写<code>volatile</code>变量时插入特定类型的<strong>内存屏障 (Memory Barrier&#x2F;Fence)</strong> 来实现。<ul>
<li>写<code>volatile</code>变量：在其之前插入<code>StoreStore</code>屏障（保证之前的普通写不被重排序到<code>volatile</code>写之后，并对其他处理器可见），在其之后插入<code>StoreLoad</code>屏障（保证<code>volatile</code>写对其他处理器可见，并防止后续的<code>volatile</code>读&#x2F;写被重排序到当前<code>volatile</code>写之前）。</li>
<li>读<code>volatile</code>变量：在其之后插入<code>LoadLoad</code>屏障和<code>LoadStore</code>屏障（防止后续的普通读&#x2F;写被重排序到当前<code>volatile</code>读之前，并确保读到的是最新值）。</li>
</ul>
</li>
<li><strong>底层 CPU 指令</strong>: 在某些 CPU 架构（如 x86）上，写<code>volatile</code>可能通过带有<code>lock</code>前缀的指令（如<code>lock addl $0,0(%%rsp)</code>，它本身有内存屏障效果并能使其他 CPU 缓存失效）或<code>mfence</code>指令来实现内存屏障效果。</li>
</ul>
</li>
<li><strong>保证有序性 (部分)</strong>:<ul>
<li><code>volatile</code>关键字能禁止特定类型的指令重排序，确保<code>volatile</code>写操作之前的操作不会被重排序到其后，<code>volatile</code>读操作之后的操作不会被重排序到其前。</li>
<li>它提供了一种”happen-before”关系：对一个<code>volatile</code>变量的写操作 <code>happens-before</code> 后续对这个变量的读操作。</li>
</ul>
</li>
<li><strong>不保证原子性</strong>:<ul>
<li><code>volatile</code>关键字<strong>不能保证复合操作的原子性</strong>。例如，<code>volatile int count; count++;</code> 这个操作不是原子的。它包含读-改-写三个步骤，在多线程环境下，这三个步骤之间可能被其他线程打断。</li>
</ul>
</li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景:"></a>应用场景:</h3><ul>
<li><strong>状态标志 (Status Flags)</strong>: 当一个线程修改一个<code>volatile</code>布尔标志，另一个线程通过检查这个标志来决定是否继续执行或停止。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">running</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stopThread</span><span class="params">()</span> &#123;</span><br><span class="line">    running = <span class="literal">false</span>; <span class="comment">// volatile写，对其他线程可见</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (running) &#123; <span class="comment">// volatile读，能看到最新的running值</span></span><br><span class="line">        <span class="comment">// ... do work ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>一次性安全发布 (Safe Publication - 结合 final)</strong>: 当对象的引用是<code>volatile</code>的，并且对象的字段是<code>final</code>的（且构造函数无<code>this</code>逸出），可以用来安全地将对象发布给其他线程。但更常见的是使用<code>final</code>字段本身的保证。</li>
<li><strong>双重检查锁定 (Double-Checked Locking - DCL) 中的实例字段</strong>: 在实现线程安全的单例模式时，单例实例字段需要用<code>volatile</code>修饰，以防止指令重排序导致其他线程拿到未完全初始化的对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance; <span class="comment">// volatile修饰</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123; <span class="comment">// 第一次检查</span></span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123; <span class="comment">// 第二次检查</span></span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>(); <span class="comment">// new操作不是原子性的</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>volatile</code>主要是为了禁止<code>instance = new Singleton()</code>中可能发生的指令重排序（分配内存 -&gt; 初始化对象 -&gt; instance 指向内存地址，后两步可能重排）。</p>
<ol>
<li><strong>开销较低的读多写少场景</strong>: 当一个变量被一个线程修改，但被多个线程频繁读取时，如果不需要复合操作的原子性，<code>volatile</code>可以提供比<code>synchronized</code>更轻量级的可见性保证。</li>
<li><strong>作为实现其他并发机制的基础</strong>: <code>volatile</code>常被用于实现更高级的并发工具，例如在 AQS 的<code>state</code>字段，以及<code>Atomic*</code>类中的<code>value</code>字段。</li>
</ol>
<h2 id="synchronized-关键字实现机制与应用"><a href="#synchronized-关键字实现机制与应用" class="headerlink" title="synchronized 关键字实现机制与应用"></a><code>synchronized</code> 关键字实现机制与应用</h2><h3 id="synchronized-的基本用法与锁定对象"><a href="#synchronized-的基本用法与锁定对象" class="headerlink" title="synchronized 的基本用法与锁定对象"></a><code>synchronized</code> 的基本用法与锁定对象</h3><ul>
<li><p><strong>修饰实例方法</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">instanceMethod</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>锁定对象</strong>: 当前实例对象 (<code>this</code>)。</li>
<li><strong>作用</strong>: 同一时刻，只有一个线程能执行该实例的任何一个<code>synchronized</code>实例方法。不同实例之间互不影响。</li>
</ul>
</li>
<li><p><strong>修饰静态方法</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>锁定对象</strong>: 当前类的 <code>Class</code> 对象 (<code>YourClassName.class</code>)。</li>
<li><strong>作用</strong>: 同一时刻，只有一个线程能执行该类的任何一个<code>synchronized</code>静态方法，无论有多少个实例或没有实例。</li>
</ul>
</li>
<li><p><strong>修饰代码块</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ... non-critical section ...</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">customLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 或者使用 this, YourClassName.class</span></span><br><span class="line">    <span class="keyword">synchronized</span> (customLock) &#123; <span class="comment">// 明确指定锁对象</span></span><br><span class="line">        <span class="comment">// ... critical section ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... non-critical section ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>锁定对象</strong>: <code>synchronized</code>关键字后面括号中指定的对象。</li>
<li><strong>灵活性</strong>: 提供了最细粒度的锁控制。推荐使用私有的、<code>final</code>的、专门用于锁定的对象实例。</li>
</ul>
</li>
</ul>
<h3 id="synchronized-的核心作用"><a href="#synchronized-的核心作用" class="headerlink" title="synchronized 的核心作用"></a><code>synchronized</code> 的核心作用</h3><p>通过 JMM 的管程锁定规则和内存交互操作，<code>synchronized</code>保证了其同步代码块的：</p>
<ul>
<li><strong>原子性</strong>: 同步代码块在执行期间不可被其他线程中断，表现为一个原子操作。</li>
<li><strong>可见性</strong>:<ul>
<li>线程获取锁时（进入同步块），会使工作内存中共享变量副本失效，从主内存重新加载。</li>
<li>线程释放锁时（退出同步块），会将工作内存中对共享变量的修改刷新到主内存。</li>
</ul>
</li>
<li><strong>有序性</strong>: 虽然<code>synchronized</code>本身不直接禁止指令重排序，但由于”同一时刻只有一个线程持有锁”的特性，以及”一个<code>unlock</code>操作 <code>happens-before</code> 后续对同一个锁的<code>lock</code>操作”的规则，使得在持有同一个锁的多个线程看来，同步块内部的操作是有序的。</li>
</ul>
<h3 id="synchronized-的底层原理-基于对象监视器-Monitor"><a href="#synchronized-的底层原理-基于对象监视器-Monitor" class="headerlink" title="synchronized 的底层原理 (基于对象监视器 Monitor)"></a><code>synchronized</code> 的底层原理 (基于对象监视器 Monitor)</h3><ul>
<li><p><strong>对象头 (Mark Word)</strong>: Java 对象的头部（在 HotSpot 中称为 Mark Word）用于存储对象的运行时数据，其中一部分用于存储锁状态信息、持有锁的线程 ID、GC 年龄、哈希码等。锁的状态（无锁、偏向锁、轻量级锁、重量级锁）就记录在这里。</p>
</li>
<li><p><strong>Monitor (监视器)</strong>:</p>
<ul>
<li>每个 Java 对象都可以关联一个 Monitor 对象（也称为”管程”或”监视器锁”）。这个 Monitor 是在对象第一次被加锁时由 JVM 创建并关联的。</li>
<li>Monitor 内部主要结构 (HotSpot C++层面 <code>ObjectMonitor</code>):<ul>
<li><code>_owner</code>: 指向当前持有该 Monitor 的线程。</li>
<li><code>_count</code> (或 <code>_recursions</code>): 记录锁的重入次数。</li>
<li><code>_EntryList</code>: 一个队列，存储尝试获取锁失败而被阻塞的线程 (BLOCKED 状态)。</li>
<li><code>_WaitSet</code>: 一个队列，存储调用了该对象<code>wait()</code>方法而进入等待状态的线程 (WAITING&#x2F;TIMED_WAITING 状态)。</li>
</ul>
</li>
<li><strong>类比 Monitor</strong>: <strong>一个带有会议室、等候区和休息室的办公室。</strong><ul>
<li><strong>会议室 (<code>_owner</code> + <code>_count</code>)</strong>: 同一时间只能一个团队（线程）使用。如果团队负责人（线程）已经在了，他的组员（同一线程的重入）可以直接进入。</li>
<li><strong>等候区 (<code>_EntryList</code>)</strong>: 想用会议室但发现里面有人（锁被占用）的团队，在这里排队等候。</li>
<li><strong>休息室 (<code>_WaitSet</code>)</strong>: 进了会议室但发现条件不满足（比如投影仪坏了），于是主动去休息室等待（调用<code>wait()</code>），并把会议室让出来。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>字节码指令</strong>:</p>
<ul>
<li>对于同步代码块: JVM 使用 <code>monitorenter</code> 和 <code>monitorexit</code> 指令。<ul>
<li><code>monitorenter</code>: 尝试获取对象关联 Monitor 的所有权。成功则<code>_count</code>+1，线程成为<code>_owner</code>。失败则阻塞并进入<code>_EntryList</code>。</li>
<li><code>monitorexit</code>: <code>_count</code>-1。如果<code>_count</code>为 0，则释放 Monitor，唤醒<code>_EntryList</code>中的等待线程。编译器会确保即使发生异常，<code>monitorexit</code>也会被执行（通过<code>try-finally</code>）。</li>
</ul>
</li>
<li>对于同步方法: 方法的访问标志 (<code>flags</code>) 中会设置 <code>ACC_SYNCHRONIZED</code>。JVM 在调用方法时会检查此标志，并隐式执行类似<code>monitorenter</code>的操作；方法返回（正常或异常）时执行类似<code>monitorexit</code>的操作。</li>
</ul>
</li>
</ul>
<h3 id="锁的优化与升级-HotSpot-JVM"><a href="#锁的优化与升级-HotSpot-JVM" class="headerlink" title="锁的优化与升级 (HotSpot JVM)"></a>锁的优化与升级 (HotSpot JVM)</h3><p>为了减少重量级锁（依赖 OS 互斥量，开销大）的使用，JVM 对<code>synchronized</code>引入了锁升级机制，锁的状态会根据竞争情况动态调整。</p>
<ul>
<li><strong>无锁状态</strong>: 对象刚创建，或锁已释放且无竞争。</li>
<li><strong>偏向锁 (Biased Locking)</strong><ul>
<li><strong>目的</strong>: 优化只有一个线程反复获取同一个锁的场景。</li>
<li><strong>机制</strong>: 当锁对象第一次被线程获取时，Mark Word 记录下该线程 ID（偏向线程），并将锁状态置为偏向锁。之后该线程再进入同步块，只需检查 Mark Word 的线程 ID 是否是自己，无需 CAS 或更重操作。</li>
<li><strong>类比</strong>: <strong>会议室的”专属预约牌”</strong>。如果总是张三用，就一直挂着张三的名字，张三来去自如，不用每次都去前台登记。</li>
<li><strong>撤销</strong>: 当有其他线程尝试获取该偏向锁时，偏向锁撤销。如果原偏向线程已退出同步块，锁恢复到无锁或重新偏向新线程；如果仍在同步块内，则升级为轻量级锁。撤销过程可能需要全局安全点。</li>
</ul>
</li>
<li><strong>轻量级锁 (Lightweight Locking)</strong><ul>
<li><strong>目的</strong>: 在多个线程交替获取锁，但几乎没有同时竞争的情况下，通过 CAS 避免重量级锁。</li>
<li><strong>机制</strong>:<ol>
<li>线程在栈帧中创建锁记录(Lock Record)，拷贝对象 Mark Word (Displaced Mark Word)。</li>
<li>通过<strong>CAS</strong>尝试将对象 Mark Word 更新为指向此锁记录的指针。</li>
<li>成功则获取轻量级锁。失败则<strong>自旋 (Spinning)</strong> 尝试一小段时间。</li>
</ol>
</li>
<li><strong>类比</strong>: <strong>会议室门口的”快速登记本”</strong>。没人用时，想用的人尝试在登记本上快速写下自己名字（CAS）。写上了就用。如果几个人同时想写，就可能需要排队或找管理员。</li>
<li><strong>自旋 (Spinning)</strong>: CAS 失败后不立即阻塞，而是执行空循环尝试再次 CAS。<ul>
<li><strong>类比</strong>: 在卫生间门口稍微等一下，而不是立刻走开再回来。</li>
<li><strong>自适应自旋</strong>: 自旋次数和时间根据上次自旋情况和锁持有者状态动态调整。</li>
</ul>
</li>
<li><strong>升级</strong>: 自旋失败或有其他线程也 CAS 失败，或持有轻量级锁时调用<code>wait()</code>，则膨胀为重量级锁。</li>
</ul>
</li>
<li><strong>重量级锁 (Heavyweight Locking)</strong><ul>
<li><strong>目的</strong>: 处理激烈的锁竞争。</li>
<li><strong>机制</strong>: 依赖操作系统互斥量（Mutex Lock），通过之前提到的 Monitor 对象 (<code>ObjectMonitor</code>) 实现。线程获取失败会被阻塞并放入<code>_EntryList</code>。</li>
<li><strong>类比</strong>: <strong>会议室需要专门的管理员（Monitor&#x2F;OS 互斥量）</strong> 来协调使用和排队。</li>
<li><strong>开销</strong>: 涉及用户态与内核态切换，性能开销最大。</li>
</ul>
</li>
</ul>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentStyleType="text/css" data-diagram-type="STATE" height="994px" preserveAspectRatio="none" style="width:591px;height:994px;background:#FFFFFF;" version="1.1" viewBox="0 0 591 994" width="591px" zoomAndPan="magnify"><title>Mark Word &#29366;&#24577;&#27969;&#36716;</title><defs/><g><g class="title" data-source-line="4"><text fill="#000000" font-family="sans-serif" font-size="14" font-weight="bold" lengthAdjust="spacing" textLength="147.3279" x="215.2985" y="22.9951">Mark Word &#29366;&#24577;&#27969;&#36716;</text></g><g class="entity" data-entity="N1" data-source-line="5" data-uid="ent0002" id="entity_N1"><path d="M6,43.2969 L6,68.4297 L202.424,68.4297 L202.424,53.2969 L192.424,43.2969 L6,43.2969" fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M192.424,43.2969 L192.424,53.2969 L202.424,53.2969 L192.424,43.2969" fill="#FEFFDD" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="175.424" x="12" y="60.3638">T1&#21644;T2&#34920;&#31034;&#20026;&#20004;&#20010;&#29420;&#31435;&#30340;&#32447;&#31243;</text></g><rect fill="#F1F1F1" height="40" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="50" x="222.21" y="129.4269"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="27.9999" x="233.2101" y="154.2736">&#26080;&#38145;</text><rect fill="#F1F1F1" height="40" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="73.909" x="172.26" y="246.4269"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="63.909" x="177.26" y="271.2736">&#20559;&#21521;&#38145; T1</text><rect fill="#F1F1F1" height="40" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="79.9997" x="130.21" y="363.4269"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="69.9997" x="135.21" y="388.2736">&#25764;&#38144;&#20559;&#21521;&#38145;</text><rect fill="#F1F1F1" height="40" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="65.9998" x="251.21" y="480.4269"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="55.9998" x="256.21" y="505.2736">&#36731;&#37327;&#32423;&#38145;</text><rect fill="#F1F1F1" height="40" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="131.2828" x="434.57" y="597.4269"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="121.2828" x="439.57" y="622.2736">&#36731;&#37327;&#32423;&#38145; (T1 &#25345;&#26377;)</text><rect fill="#F1F1F1" height="40" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="65.9998" x="245.21" y="714.4269"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="55.9998" x="250.21" y="739.2736">&#37325;&#37327;&#32423;&#38145;</text><rect fill="#F1F1F1" height="40" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="131.2828" x="212.57" y="831.4269"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="121.2828" x="217.57" y="856.2736">&#37325;&#37327;&#32423;&#38145; (T1 &#25345;&#26377;)</text><rect fill="#F1F1F1" height="40" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:0.5;" width="194.7886" x="180.82" y="948.4269"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="184.7886" x="185.82" y="973.2736">&#26080;&#38145; / &#21796;&#37266;_EntryList &#20013;&#32447;&#31243;</text><ellipse cx="247.21" cy="55.8569" fill="#222222" rx="10" ry="10" style="stroke:#222222;stroke-width:1;"/><!--link *start* to A--><g class="link" data-entity-1="*start*" data-entity-2="A" data-source-line="20" data-uid="lnk3" id="link_*start*_A"><path d="M247.21,66.3169 C247.21,81.0269 247.21,103.7069 247.21,122.9769" fill="none" id="*start*-to-A" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="247.21,128.9769,251.21,119.9769,247.21,123.9769,243.21,119.9769,247.21,128.9769" style="stroke:#181818;stroke-width:1;"/></g><!--link A to B--><g class="link" data-entity-1="A" data-entity-2="B" data-source-line="23" data-uid="lnk4" id="link_A_B"><path d="M221.72,159.5269 C204.34,167.2369 182.65,180.1369 172.21,199.4269 C163.65,215.2569 170.7518,228.6645 183.0118,241.7745" fill="none" id="A-to-B" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="187.11,246.1569,183.8843,236.8513,183.6948,242.5049,178.0412,242.3155,187.11,246.1569" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="119.609" x="173.21" y="212.4938">T1 &#39318;&#27425;&#35775;&#38382;, &#26080;&#31454;&#20105;</text></g><!--link B to C--><g class="link" data-entity-1="B" data-entity-2="C" data-source-line="24" data-uid="lnk5" id="link_B_C"><path d="M202.68,286.6769 C195.49,307.9069 185.8978,336.185 178.6878,357.435" fill="none" id="B-to-C" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="176.76,363.1169,183.4396,355.8793,178.3665,358.382,175.8638,353.3089,176.76,363.1169" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="72.3443" x="193.21" y="329.4938">T2 &#23581;&#35797;&#33719;&#21462;</text></g><!--link C to A--><g class="link" data-entity-1="C" data-entity-2="A" data-source-line="25" data-uid="lnk6" id="link_C_A"><path d="M129.91,364.1569 C81.95,339.7569 11.94,294.0369 42.21,246.4269 C82.49,183.0869 170.855,161.7727 216.145,154.5427" fill="none" id="C-to-A" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="222.07,153.5969,212.552,151.0657,217.1325,154.3851,213.8131,158.9656,222.07,153.5969" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="111.3443" x="43.21" y="270.9938">T1 &#24050;&#36864;&#20986;&#25110;&#26080;&#31454;&#20105;</text></g><!--link C to D--><g class="link" data-entity-1="C" data-entity-2="D" data-source-line="26" data-uid="lnk7" id="link_C_D"><path d="M163.66,403.6669 C160.13,417.7769 158.13,436.7669 167.21,450.4269 C185.69,478.2069 217.3845,489.1519 244.9845,494.3719" fill="none" id="C-to-D" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="250.88,495.4869,242.7801,489.884,245.9671,494.5577,241.2934,497.7447,250.88,495.4869" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="124.3444" x="168.21" y="446.4938">T1 &#20173;&#22312;&#25110;&#26377;&#20854;&#20182;&#31454;&#20105;</text></g><!--link A to D--><g class="link" data-entity-1="A" data-entity-2="D" data-source-line="27" data-uid="lnk8" id="link_A_D"><path d="M272.66,168.2569 C282.25,176.5169 292.08,187.2169 297.21,199.4269 C318.82,250.8469 304.42,395.1169 297.21,450.4269 C295.91,460.3769 294.8732,465.4178 292.2632,474.3478" fill="none" id="A-to-D" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="290.58,480.1069,296.9442,472.5904,291.9827,475.3077,289.2655,470.3461,290.58,480.1069" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="156.0002" x="310.21" y="329.4938">&#20851;&#38381;&#20559;&#21521;&#38145;&#25110;&#21021;&#22987;&#21363;&#26377;&#31454;&#20105;</text></g><!--link D to D_Held--><g class="link" data-entity-1="D" data-entity-2="D_Held" data-source-line="29" data-uid="lnk9" id="link_D_D_Held"><path d="M317.49,519.1469 C357.01,540.1869 417.4335,572.3578 458.3535,594.1378" fill="none" id="D-to-D_Held" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="463.65,596.9569,457.5847,589.1972,459.2363,594.6076,453.8259,596.2592,463.65,596.9569" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="56.3545" x="406.21" y="563.4938">CAS &#25104;&#21151;</text></g><!--link D_Held to A--><g class="link" data-entity-1="D_Held" data-entity-2="A" data-source-line="30" data-uid="lnk10" id="link_D_Held_A"><path d="M500.21,597.2969 C500.21,574.4769 500.21,535.1669 500.21,501.4269 C500.21,265.4269 500.21,265.4269 500.21,265.4269 C500.21,166.0369 342.388,152.2906 278.398,150.6506" fill="none" id="D_Held-to-A" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="272.4,150.4969,281.2946,154.7261,277.3984,150.625,281.4995,146.7288,272.4,150.4969" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="82.3546" x="501.21" y="387.9938">CAS &#37322;&#25918;&#25104;&#21151;</text></g><!--link D to E--><g class="link" data-entity-1="D" data-entity-2="E" data-source-line="31" data-uid="lnk11" id="link_D_E"><path d="M279.75,520.7869 C275.55,540.0769 269.57,570.6169 267.21,597.4269 C263.56,638.9569 269.1298,681.7508 273.5898,708.1308" fill="none" id="D-to-E" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="274.59,714.0469,277.0337,704.506,273.7565,709.1168,269.1457,705.8396,274.59,714.0469" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="148.6305" x="268.21" y="621.9938">CAS &#22833;&#36133; (&#33258;&#26059;&#21518;&#20173;&#22833;&#36133;)</text></g><!--link D_Held to E--><g class="link" data-entity-1="D_Held" data-entity-2="E" data-source-line="32" data-uid="lnk12" id="link_D_Held_E"><path d="M462.8,637.8069 C420.42,659.7569 357.3077,692.4572 316.7477,713.4672" fill="none" id="D_Held-to-E" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="311.42,716.2269,321.2513,715.6391,315.8597,713.9271,317.5717,708.5355,311.42,716.2269" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="179.715" x="404.21" y="680.4938">&#37322;&#25918;&#26102; CAS &#22833;&#36133; / &#35843;&#29992; wait()</text></g><!--link E to E_Held--><g class="link" data-entity-1="E" data-entity-2="E_Held" data-source-line="34" data-uid="lnk13" id="link_E_E_Held"><path d="M278.21,754.6769 C278.21,775.9069 278.21,803.8669 278.21,825.1169" fill="none" id="E-to-E_Held" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="278.21,831.1169,282.21,822.1169,278.21,826.1169,274.21,822.1169,278.21,831.1169" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="109.6812" x="279.21" y="797.4938">&#33719;&#21462; Monitor &#25104;&#21151;</text></g><!--link E_Held to A_Or_Wake--><g class="link" data-entity-1="E_Held" data-entity-2="A_Or_Wake" data-source-line="35" data-uid="lnk14" id="link_E_Held_A_Or_Wake"><path d="M278.21,871.6769 C278.21,892.9069 278.21,920.8669 278.21,942.1169" fill="none" id="E_Held-to-A_Or_Wake" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="278.21,948.1169,282.21,939.1169,278.21,943.1169,274.21,939.1169,278.21,948.1169" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="79.5489" x="279.21" y="914.4938">&#37322;&#25918; Monitor</text></g><!--SRC=[RPDTJnf158RlvrUSU5De90OlUz44WQGNjRsGn8kc8QCxmCHbX-oC8Tn1Mek8tw6GDDhMX5RYLsrjrM2iVuRPZt_HsLsMOckoDtFUvvnvvptP0jK8a699L40ZVD6a9K6PWT0Zo52X4yWn4qI1W4PntiJ5IU2qI7MiYWpuyeAgbGfWu291mkTdiRa4yypKm5wxjAerwrVDkJr11XC49Z9nkRkUcNOEUdQtFxXMNtTmVMGtJ-pZfltXhTs_itlD2S0SNiILWxdbV9vmmG63Jd8Y9bZCfFc201rNsBA0dCxAIB2IvsM12S6AogP95iCNf4YE6iItpmKMX4EPYe9tfkRuQzK5XWPOfvWJZdmK9gpEPxTLyyqamfgiRSdj7LM6JDnNPaRqRjTjLKUwBoP3qRczSUjRTlymL58FAH39nC5QhrbxZMX0PPyHNGjHjxvnVqZw8UM_8UbxGu97mHJ8LjTzjvjD6yAiFATSmE3wT2p-HFQbcPt7I-IV6Ab11SLw42TwzVWrn69FLJxtAM5YWzCWsGKYoeGO3onWaHbQ04rXVsKS9VnnC_14vGlkrxPrSk2StRcTiqbGpktZZuD-0ytuKDA3fa6UxplVtZkRLtAhZPA1cw1TNlrmgrLPxrkhxR_D0P8AaC7DXjphUVfUGwvS3cxQGoenekJAXTiv7UrLiN9rNnusvSQ5QXhYA1NmVjIgAPcO0sjrMwvzGiDQwCjJtFgQrVeTwhwK7ago-ztv-GKYJlt8wZJbzgRdqAz5noTv-71AvtAySGgSypTsgmTbJ4KaYb0wu4DZGKumozGQrNyzz90UynZkVNH32Fy1]--></g></svg>

<h3 id="synchronized-的可重入性"><a href="#synchronized-的可重入性" class="headerlink" title="synchronized 的可重入性"></a><code>synchronized</code> 的可重入性</h3><ul>
<li><strong>定义</strong>: 同一个线程可以多次获取它已经持有的锁，而不会导致死锁。</li>
<li><strong>实现</strong>: Monitor 内部的<code>_owner</code>记录持有线程，<code>_count</code>记录重入次数。每次重入，<code>_count</code>++；每次退出同步块，<code>_count</code>–。只有当<code>_count</code>减为 0 时，锁才真正释放。</li>
<li><strong>例子</strong>: 一个<code>synchronized</code>方法调用了同一个对象的另一个<code>synchronized</code>方法。</li>
</ul>
<h3 id="this引用逸出"><a href="#this引用逸出" class="headerlink" title="this引用逸出"></a><code>this</code>引用逸出</h3><ul>
<li><strong>危险</strong>: 在构造函数完成前，<code>this</code>引用被其他线程获取，可能导致访问到未完全初始化的对象状态，破坏<code>final</code>字段语义。</li>
<li><strong>类比</strong>: <strong>房子还没盖完，就把钥匙给了别人。</strong></li>
<li><strong>避免</strong>: 不在构造器中启动依赖当前对象状态的线程、注册监听器、调用可被子类覆盖的非 final 方法。使用工厂方法或在构造完成后再进行这些操作。</li>
</ul>
<h3 id="Object的wait-notify-notifyAll-回顾，与synchronized强关联"><a href="#Object的wait-notify-notifyAll-回顾，与synchronized强关联" class="headerlink" title="Object的wait(), notify(), notifyAll() (回顾，与synchronized强关联)"></a><code>Object</code>的<code>wait()</code>, <code>notify()</code>, <code>notifyAll()</code> (回顾，与<code>synchronized</code>强关联)</h3><ul>
<li>必须在<code>synchronized(obj)</code>代码块中由<code>obj</code>调用。</li>
<li><code>wait()</code>: 释放<code>obj</code>的锁，线程进入<code>obj</code>的<code>_WaitSet</code>等待。</li>
<li><code>notify()/notifyAll()</code>: 唤醒<code>_WaitSet</code>中一个&#x2F;所有线程，被唤醒线程需重新竞争<code>obj</code>的锁。</li>
<li><strong>类比</strong>: <strong>办公室里的会议室（锁）、休息室（_WaitSet）和广播系统（notify&#x2F;notifyAll）。</strong></li>
</ul>
<h2 id="两者在可见性、原子性、有序性上的差异"><a href="#两者在可见性、原子性、有序性上的差异" class="headerlink" title="两者在可见性、原子性、有序性上的差异"></a>两者在可见性、原子性、有序性上的差异</h2><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>volatile</code></th>
<th align="left"><code>synchronized</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>可见性</strong></td>
<td align="left"><strong>保证</strong>。对<code>volatile</code>变量的修改对其他线程立即可见。</td>
<td align="left"><strong>保证</strong>。进入同步块前从主内存读，退出同步块后写回主内存。</td>
</tr>
<tr>
<td align="left"><strong>原子性</strong></td>
<td align="left"><strong>不保证</strong>复合操作的原子性。仅保证对单个<code>volatile</code>变量的读&#x2F;写操作本身是原子的。</td>
<td align="left"><strong>保证</strong>。同步代码块内的所有操作作为一个原子单元执行，不被其他线程干扰。</td>
</tr>
<tr>
<td align="left"><strong>有序性</strong></td>
<td align="left"><strong>部分保证</strong>。禁止特定类型的指令重排序，保证<code>volatile</code>读写操作的相对顺序。</td>
<td align="left"><strong>保证</strong>。通过”一个时刻只有一个线程执行同步代码”和”管程锁定 happen-before 规则”间接保证了同步块内操作对其他线程的有序性（看起来像是串行执行）。</td>
</tr>
</tbody></table>
<p><strong>图示对比 (概念层面)</strong></p>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentStyleType="text/css" data-diagram-type="DESCRIPTION" height="570px" preserveAspectRatio="none" style="width:1279px;height:570px;background:#FFFFFF;" version="1.1" viewBox="0 0 1279 570" width="1279px" zoomAndPan="magnify"><defs/><g><!--cluster Volatile ??--><g class="cluster" data-entity="Volatile &#26426;&#21046;" data-source-line="3" data-uid="ent0002" id="cluster_Volatile &#26426;&#21046;"><path d="M8.5,6 L102.8583,6 A3.75,3.75 0 0 1 105.3583,8.5 L112.3583,28.2969 L277.5,28.2969 A2.5,2.5 0 0 1 280,30.7969 L280,445.68 A2.5,2.5 0 0 1 277.5,448.18 L8.5,448.18 A2.5,2.5 0 0 1 6,445.68 L6,8.5 A2.5,2.5 0 0 1 8.5,6" fill="none" style="stroke:#000000;stroke-width:1.5;"/><line style="stroke:#000000;stroke-width:1.5;" x1="6" x2="112.3583" y1="28.2969" y2="28.2969"/><text fill="#000000" font-family="sans-serif" font-size="14" font-weight="bold" lengthAdjust="spacing" textLength="93.3583" x="10" y="20.9951">Volatile &#26426;&#21046;</text></g><!--cluster Synchronized ??--><g class="cluster" data-entity="Synchronized &#26426;&#21046;" data-source-line="10" data-uid="ent0007" id="cluster_Synchronized &#26426;&#21046;"><path d="M637.5,6 L777.7684,6 A3.75,3.75 0 0 1 780.2684,8.5 L787.2684,28.2969 L852.5,28.2969 A2.5,2.5 0 0 1 855,30.7969 L855,560.98 A2.5,2.5 0 0 1 852.5,563.48 L637.5,563.48 A2.5,2.5 0 0 1 635,560.98 L635,8.5 A2.5,2.5 0 0 1 637.5,6" fill="none" style="stroke:#000000;stroke-width:1.5;"/><line style="stroke:#000000;stroke-width:1.5;" x1="635" x2="787.2684" y1="28.2969" y2="28.2969"/><text fill="#000000" font-family="sans-serif" font-size="14" font-weight="bold" lengthAdjust="spacing" textLength="139.2684" x="639" y="20.9951">Synchronized &#26426;&#21046;</text></g><!--entity ThreadA_V--><g class="entity" data-entity="ThreadA_V" data-source-line="4" data-uid="ent0003" id="entity_ThreadA_V"><rect fill="#F1F1F1" height="36.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="163.199" x="99.4" y="41"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="143.199" x="109.4" y="63.9951">&#32447;&#31243; A &#20889; volatile var</text></g><!--entity MainMemory_V--><g class="entity" data-entity="MainMemory_V" data-source-line="5" data-uid="ent0004" id="entity_MainMemory_V"><rect fill="#F1F1F1" height="36.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="61.9998" x="93" y="282.59"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="41.9998" x="103" y="305.5851">&#20027;&#20869;&#23384;</text></g><!--entity ThreadB_V--><g class="entity" data-entity="ThreadB_V" data-source-line="6" data-uid="ent0005" id="entity_ThreadB_V"><rect fill="#F1F1F1" height="36.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="163.2264" x="42.39" y="395.89"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="143.2264" x="52.39" y="418.8851">&#32447;&#31243; B &#35835; volatile var</text></g><!--entity NoReorder_V--><g class="entity" data-entity="NoReorder_V" data-source-line="7" data-uid="ent0006" id="entity_NoReorder_V"><rect fill="#F1F1F1" height="36.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="117.9996" x="146" y="169.29"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="97.9996" x="156" y="192.2851">&#31105;&#27490;&#37325;&#25490;&#24207;&#23631;&#38556;</text></g><!--entity ThreadA_S--><g class="entity" data-entity="ThreadA_S" data-source-line="11" data-uid="ent0008" id="entity_ThreadA_S"><rect fill="#F1F1F1" height="36.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="187.4324" x="651.28" y="41"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="167.4324" x="661.28" y="63.9951">&#32447;&#31243;A &#36827;&#20837; synchronized</text></g><!--entity MainMemory_S1--><g class="entity" data-entity="MainMemory_S1" data-source-line="12" data-uid="ent0009" id="entity_MainMemory_S1"><rect fill="#F1F1F1" height="36.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="96.9997" x="694.5" y="169.29"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="76.9997" x="704.5" y="192.2851">&#20027;&#20869;&#23384;_&#21152;&#36733;</text></g><!--entity CriticalSection_A--><g class="entity" data-entity="CriticalSection_A" data-source-line="13" data-uid="ent0010" id="entity_CriticalSection_A"><rect fill="#F1F1F1" height="36.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="161.3735" x="654.31" y="282.59"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="141.3735" x="664.31" y="305.5851">&#20020;&#30028;&#21306;&#20195;&#30721; (&#21407;&#23376;&#25191;&#34892;)</text></g><!--entity MainMemory_S2--><g class="entity" data-entity="MainMemory_S2" data-source-line="14" data-uid="ent0011" id="entity_MainMemory_S2"><rect fill="#F1F1F1" height="36.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="96.9997" x="667.5" y="395.89"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="76.9997" x="677.5" y="418.8851">&#20027;&#20869;&#23384;_&#21047;&#26032;</text></g><!--entity ThreadB_S--><g class="entity" data-entity="ThreadB_S" data-source-line="15" data-uid="ent0012" id="entity_ThreadB_S"><rect fill="#F1F1F1" height="36.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="187.4597" x="651.27" y="511.18"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="167.4597" x="661.27" y="534.1751">&#32447;&#31243;B &#36827;&#20837; synchronized</text></g><g class="entity" data-entity="GMN21" data-source-line="31" data-uid="ent0022" id="entity_GMN21"><path d="M297.34,46.58 L297.34,55.14 L262.94,59.14 L297.34,63.14 L297.34,71.7128 A0,0 0 0 0 297.34,71.7128 L616.661,71.7128 A0,0 0 0 0 616.661,71.7128 L616.661,56.58 L606.661,46.58 L297.34,46.58 A0,0 0 0 0 297.34,46.58" fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M606.661,46.58 L606.661,56.58 L616.661,56.58 L606.661,46.58" fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="298.321" x="303.34" y="63.6469">volatile: &#36731;&#37327;&#32423;&#21516;&#27493;, &#20027;&#35201;&#20445;&#35777;&#21487;&#35265;&#24615;&#21644;&#37096;&#20998;&#26377;&#24207;&#24615;</text></g><g class="entity" data-entity="GMN24" data-source-line="35" data-uid="ent0025" id="entity_GMN24"><path d="M873.82,46.58 L873.82,55.14 L839.17,59.14 L873.82,63.14 L873.82,71.7128 A0,0 0 0 0 873.82,71.7128 L1272.1883,71.7128 A0,0 0 0 0 1272.1883,71.7128 L1272.1883,56.58 L1262.1883,46.58 L873.82,46.58 A0,0 0 0 0 873.82,46.58" fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M1262.1883,46.58 L1262.1883,56.58 L1272.1883,56.58 L1262.1883,46.58" fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="377.3683" x="879.82" y="63.6469">synchronized: &#37325;&#37327;&#32423;&#21516;&#27493; (&#30456;&#23545;), &#20445;&#35777;&#21407;&#23376;&#24615;&#12289;&#21487;&#35265;&#24615;&#12289;&#26377;&#24207;&#24615;</text></g><!--link ThreadA_V to MainMemory_V--><g class="link" data-entity-1="ThreadA_V" data-entity-2="MainMemory_V" data-source-line="19" data-uid="lnk13" id="link_ThreadA_V_MainMemory_V"><path d="M155.13,77.45 C129.26,96.46 91.09,129.64 75,169.29 C58.72,209.42 85.446,252.4976 105.236,277.6076" fill="none" id="ThreadA_V-to-MainMemory_V" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="108.95,282.32,106.5206,272.7755,105.855,278.393,100.2375,277.7274,108.95,282.32" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="52.0001" x="76" y="192.0069">&#31435;&#21363;&#21047;&#26032;</text></g><!--link MainMemory_V to ThreadB_V--><g class="link" data-entity-1="MainMemory_V" data-entity-2="ThreadB_V" data-source-line="20" data-uid="lnk14" id="link_MainMemory_V_ThreadB_V"><path d="M124,319.13 C124,339.91 124,368.5 124,389.4" fill="none" id="MainMemory_V-to-ThreadB_V" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="124,395.4,128,386.4,124,390.4,120,386.4,124,395.4" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="117.0001" x="125" y="361.9569">&#31435;&#21363;&#23545;&#20854;&#20182;&#32447;&#31243;&#21487;&#35265;</text></g><!--link ThreadA_V to NoReorder_V--><g class="link" data-entity-1="ThreadA_V" data-entity-2="NoReorder_V" data-source-line="21" data-uid="lnk15" id="link_ThreadA_V_NoReorder_V"><path d="M184.34,77.71 C188.92,101.83 195.9999,139.0855 200.5699,163.1355" fill="none" id="ThreadA_V-to-NoReorder_V" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="201.69,169.03,203.9396,159.4415,200.7566,164.1179,196.0802,160.9349,201.69,169.03" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="65.0001" x="196" y="127.8569">&#31105;&#27490;&#37325;&#25490;&#24207;</text></g><!--link NoReorder_V to MainMemory_V--><g class="link" data-entity-1="NoReorder_V" data-entity-2="MainMemory_V" data-source-line="22" data-uid="lnk16" id="link_NoReorder_V_MainMemory_V"><path d="M192.34,205.83 C177.22,226.62 155.5717,256.3595 140.3617,277.2495" fill="none" id="NoReorder_V-to-MainMemory_V" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="136.83,282.1,145.3612,277.1787,139.773,278.0579,138.8938,272.4698,136.83,282.1" style="stroke:#181818;stroke-width:1;"/></g><!--link ThreadA_S to MainMemory_S1--><g class="link" data-entity-1="ThreadA_S" data-entity-2="MainMemory_S1" data-source-line="25" data-uid="lnk17" id="link_ThreadA_S_MainMemory_S1"><path d="M744.72,77.71 C744.34,101.83 743.7548,138.9807 743.3748,163.0307" fill="none" id="ThreadA_S-to-MainMemory_S1" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="743.28,169.03,747.4217,160.0943,743.359,164.0306,739.4227,159.9679,743.28,169.03" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="78.0001" x="745" y="120.3569">&#28165;&#31354;&#24037;&#20316;&#20869;&#23384;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="78.0001" x="745" y="135.4897">&#20174;&#20027;&#20869;&#23384;&#21152;&#36733;</text></g><!--link MainMemory_S1 to CriticalSection_A--><g class="link" data-entity-1="MainMemory_S1" data-entity-2="CriticalSection_A" data-source-line="26" data-uid="lnk18" id="link_MainMemory_S1_CriticalSection_A"><path d="M741.75,205.83 C740.26,226.62 738.1997,255.2254 736.6997,276.1154" fill="none" id="MainMemory_S1-to-CriticalSection_A" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="736.27,282.1,740.9043,273.4096,736.6281,277.1128,732.9249,272.8366,736.27,282.1" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="78.0001" x="740" y="248.6569">&#25191;&#34892;&#21516;&#27493;&#20195;&#30721;</text></g><!--link CriticalSection_A to MainMemory_S2--><g class="link" data-entity-1="CriticalSection_A" data-entity-2="MainMemory_S2" data-source-line="27" data-uid="lnk19" id="link_CriticalSection_A_MainMemory_S2"><path d="M732.03,319.13 C728.48,339.91 723.5902,368.5857 720.0202,389.4857" fill="none" id="CriticalSection_A-to-MainMemory_S2" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="719.01,395.4,724.4683,387.202,719.8519,390.4714,716.5825,385.855,719.01,395.4" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="104.0001" x="727" y="361.9569">&#20462;&#25913;&#21047;&#26032;&#21040;&#20027;&#20869;&#23384;</text></g><!--link MainMemory_S2 to ThreadB_S--><g class="link" data-entity-1="MainMemory_S2" data-entity-2="ThreadB_S" data-source-line="28" data-uid="lnk20" id="link_MainMemory_S2_ThreadB_S"><path d="M720.4,432.24 C725.86,453.54 733.5922,483.7774 739.0622,505.1474" fill="none" id="MainMemory_S2-to-ThreadB_S" style="stroke:#181818;stroke-width:1;"/><polygon fill="#181818" points="740.55,510.96,742.1933,501.2492,739.3101,506.1162,734.4432,503.233,740.55,510.96" style="stroke:#181818;stroke-width:1;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="143.0002" x="733" y="477.2469">&#37322;&#25918;&#38145;&#21518;&#23545;&#20854;&#20182;&#32447;&#31243;&#21487;&#35265;</text></g><!--SRC=[XLFBRjD05DtxAwwwePNeebrsWPIm3WkCkW4KZPoXiPgC8yUg511IB9H7sxnKfHNG80eeJH4AAGfgKriX7uF7ZxzWd6aJssd4pffxxZddtkERtvL93gae2vAIpIa44qtK2XaCAfOqH7OoM11oIDf5EnXMjfKCqcHMj3i6hLwjm1i1uBbZJ9oBGuW1BN-0lJl87b9V0ih3ixIAKIgMtFQXriYavHBjlv-M4aWc2PnLr0AltXB5mHsOouZYjz1ptUv_zIfrkt54ZIRzrVG-TgQm9yfJhAWfh3BWsu1tiK2ajAeG-JLEtUS_1kxab9Qwa0y0GnE8eGcIzE3C7O-ZWuWR7FNREQxHcc6Ptvmp7LPfupFjj-pzdlkbjZRjUQpAcYoXZCZsB2ia6OkmLw_jayi5zisvuVX_3CUPORQ01p1BBO6bD29oFWkqD7I6fZ3B1jRN7uNYW2rmVXpI-f3x448r7pnBOuuStD3IbMMUS7kqEN1xUaGY48xV5mvH25QZXln1GX4k7KQCzeeRJCiUbPpl1htkMkCEN_4BOfcDsS9vcaAupITQoCadc-P8MpMxt-K92ukmg8jDrcXDVjhj6xvJMhsSgGjXO7318clpAWTs-u_NrcchSV-Q1Q9ex6RbdRG6oglGqTqTqXQuOzEhD1sZnvq_1ARldklMv9Cxq3cHNUpHevhtxe9MotPddwN2NWHCKk0BB9FnBoFu5_gEwq4fM7LEHypv6jFaQlmUYhs_nRao-rxK_0S0]--></g></svg>

<h2 id="性能对比与选择指南"><a href="#性能对比与选择指南" class="headerlink" title="性能对比与选择指南"></a>性能对比与选择指南</h2><ul>
<li><p><strong><code>volatile</code></strong>:</p>
<ul>
<li><strong>性能开销</strong>: 通常比<code>synchronized</code>的重量级锁小。它不涉及线程的阻塞和唤醒，主要开销在于内存屏障的插入和缓存一致性协议的执行。</li>
<li><strong>特点</strong>: 是 JVM 提供的最轻量级的同步机制。</li>
</ul>
</li>
<li><p><strong><code>synchronized</code></strong>:</p>
<ul>
<li><strong>性能开销</strong>:<ul>
<li><strong>无竞争或偏向锁&#x2F;轻量级锁</strong>: 开销很小，可能接近甚至优于<code>volatile</code>（因为<code>volatile</code>每次读写都有屏障）。</li>
<li><strong>重量级锁</strong>: 开销较大，涉及到线程阻塞、唤醒、用户态&#x2F;内核态切换。</li>
</ul>
</li>
<li><strong>优化</strong>: JVM 在 JDK 1.6 后对<code>synchronized</code>做了大量优化（锁升级），使其在很多场景下性能不再是瓶颈。</li>
</ul>
</li>
<li><p><strong>选择指南</strong>:</p>
</li>
</ul>
<ol>
<li><strong>功能需求优先</strong>:<ul>
<li>如果需要保证<strong>复合操作的原子性</strong>（例如计数器递增、检查并更新等），必须使用<code>synchronized</code>（或<code>Lock</code>，或<code>Atomic*</code>类）。<code>volatile</code>无法满足。</li>
<li>如果只是需要保证<strong>单个变量的可见性</strong>，并且对该变量的操作不依赖于其当前值（或者原子性由其他方式保证），那么<code>volatile</code>是一个更轻量级的选择。</li>
</ul>
</li>
<li><strong>锁的粒度</strong>:<ul>
<li><code>synchronized</code>可以锁定整个方法或代码块，保护多个操作。</li>
<li><code>volatile</code>只能修饰变量，作用于变量级别的读写。</li>
</ul>
</li>
<li><strong>性能考量 (在功能满足前提下)</strong>:<ul>
<li>如果锁竞争不激烈，或者同步代码块执行非常快，JVM 对<code>synchronized</code>的优化可能使其性能良好。</li>
<li>如果只是需要可见性，<code>volatile</code>通常开销更小。</li>
<li>在高竞争情况下，如果<code>synchronized</code>膨胀为重量级锁，其开销会显著增加。此时如果能用<code>Atomic*</code>类或 JUC <code>Lock</code>的特定优化（如分段锁）可能会更好。</li>
</ul>
</li>
<li><strong>代码可读性与简洁性</strong>:<ul>
<li><code>synchronized</code>用法相对简单直观，不易出错（自动释放锁）。</li>
<li><code>volatile</code>的正确使用需要对 JMM 有更深的理解，以避免误用（比如期望它保证原子性）。</li>
</ul>
</li>
</ol>
<p><strong>一句话总结选择</strong>:</p>
<ul>
<li>用<code>volatile</code>保证<strong>变量可见性</strong>和<strong>禁止指令重排</strong>（如状态标志、DCL）。</li>
<li>用<code>synchronized</code>保证<strong>代码块原子性</strong>和<strong>相关变量的可见性与有序性</strong>。</li>
</ul>
<h2 id="实际代码示例对比"><a href="#实际代码示例对比" class="headerlink" title="实际代码示例对比"></a>实际代码示例对比</h2><h3 id="示例-1：计数器实现"><a href="#示例-1：计数器实现" class="headerlink" title="示例 1：计数器实现"></a>示例 1：计数器实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 错误用法：volatile无法保证复合操作原子性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;  <span class="comment">// 这不是原子操作！</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确用法1：使用synchronized</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;  <span class="comment">// 原子性得到保证</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确用法2：使用原子类（推荐）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count.incrementAndGet();  <span class="comment">// CAS实现，性能更好</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="示例-2：单例模式中的应用"><a href="#示例-2：单例模式中的应用" class="headerlink" title="示例 2：单例模式中的应用"></a>示例 2：单例模式中的应用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ✅ volatile在双重检查锁定中的正确使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;  <span class="comment">// 必须使用volatile</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;  <span class="comment">// 第一次检查</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;  <span class="comment">// 第二次检查</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();  <span class="comment">// 防止指令重排序</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为什么需要volatile？</span></span><br><span class="line"><span class="comment">// new Singleton()分为三步：</span></span><br><span class="line"><span class="comment">// 1. 分配内存空间</span></span><br><span class="line"><span class="comment">// 2. 初始化对象</span></span><br><span class="line"><span class="comment">// 3. instance指向内存地址</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 可能的重排序：1 -&gt; 3 -&gt; 2</span></span><br><span class="line"><span class="comment">// 没有volatile时，其他线程可能看到未初始化完成的对象</span></span><br></pre></td></tr></table></figure>

<h3 id="示例-3：生产者-消费者模式"><a href="#示例-3：生产者-消费者模式" class="headerlink" title="示例 3：生产者-消费者模式"></a>示例 3：生产者-消费者模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// volatile适用场景：简单的状态标志</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">running</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产者线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">producer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (running) &#123;  <span class="comment">// volatile读，能及时看到停止信号</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="string">&quot;data-&quot;</span> + System.currentTimeMillis());</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费者线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (running || !queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> queue.poll(<span class="number">100</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">                <span class="keyword">if</span> (data != <span class="literal">null</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Consumed: &quot;</span> + data);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        running = <span class="literal">false</span>;  <span class="comment">// volatile写，立即对所有线程可见</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试高频问题总结"><a href="#面试高频问题总结" class="headerlink" title="面试高频问题总结"></a>面试高频问题总结</h2><h3 id="⭐⭐⭐-超高频问题"><a href="#⭐⭐⭐-超高频问题" class="headerlink" title="⭐⭐⭐ 超高频问题"></a>⭐⭐⭐ 超高频问题</h3><ol>
<li><p><strong>volatile 和 synchronized 的区别是什么？</strong></p>
<ul>
<li><strong>volatile</strong>：轻量级，保证可见性和有序性，不保证原子性</li>
<li><strong>synchronized</strong>：重量级，保证原子性、可见性、有序性</li>
</ul>
</li>
<li><p><strong>volatile 能否保证原子性？为什么？</strong></p>
<ul>
<li><strong>不能</strong>。volatile 只保证读写操作本身的原子性，不保证复合操作（如 i++）的原子性</li>
<li>i++包含：读取 i 的值 → 计算 i+1 → 写回 i，三个操作在多线程下可能被打断</li>
</ul>
</li>
<li><p><strong>什么情况下使用 volatile？</strong></p>
<ul>
<li>状态标志（如停止标志）</li>
<li>双重检查锁定中的实例变量</li>
<li>读多写少的共享变量</li>
<li>不依赖当前值的变量更新</li>
</ul>
</li>
</ol>
<h3 id="⭐⭐-高频问题"><a href="#⭐⭐-高频问题" class="headerlink" title="⭐⭐ 高频问题"></a>⭐⭐ 高频问题</h3><ol start="4">
<li><p><strong>synchronized 的锁优化有哪些？</strong></p>
<ul>
<li>偏向锁 → 轻量级锁 → 重量级锁</li>
<li>自旋锁、自适应自旋</li>
<li>锁粗化、锁消除</li>
</ul>
</li>
<li><p><strong>volatile 的实现原理是什么？</strong></p>
<ul>
<li>内存屏障：LoadLoad、LoadStore、StoreLoad、StoreStore</li>
<li>缓存一致性协议（MESI）</li>
<li>CPU 的 lock 前缀指令</li>
</ul>
</li>
<li><p><strong>synchronized 和 ReentrantLock 的区别？</strong></p>
<ul>
<li>synchronized：JVM 内置、自动释放、不可中断</li>
<li>ReentrantLock：API 级别、手动释放、可中断、支持公平锁</li>
</ul>
</li>
</ol>
<h3 id="⭐-进阶问题"><a href="#⭐-进阶问题" class="headerlink" title="⭐ 进阶问题"></a>⭐ 进阶问题</h3><ol start="7">
<li><p><strong>happen-before 规则中 volatile 的作用？</strong></p>
<ul>
<li>volatile 写 happen-before 后续的 volatile 读</li>
<li>建立内存可见性的偏序关系</li>
</ul>
</li>
<li><p><strong>synchronized 在字节码层面如何实现？</strong></p>
<ul>
<li>同步代码块：monitorenter + monitorexit</li>
<li>同步方法：ACC_SYNCHRONIZED 标志</li>
</ul>
</li>
</ol>
<h2 id="最佳实践指南"><a href="#最佳实践指南" class="headerlink" title="最佳实践指南"></a>最佳实践指南</h2><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><ol>
<li><p><strong>最小化同步范围</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 不好的做法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">processData</span><span class="params">(List&lt;Data&gt; dataList)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Data data : dataList) &#123;</span><br><span class="line">        <span class="comment">// 大量非关键计算</span></span><br><span class="line">        calculate(data);</span><br><span class="line">        <span class="comment">// 真正需要同步的操作</span></span><br><span class="line">        updateSharedResource(data.getResult());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 好的做法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processData</span><span class="params">(List&lt;Data&gt; dataList)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Data data : dataList) &#123;</span><br><span class="line">        <span class="comment">// 非关键计算放在同步块外</span></span><br><span class="line">        <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> calculate(data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只同步关键操作</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            updateSharedResource(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>选择合适的锁对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankAccount</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">balanceLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();  <span class="comment">// ✅ 专用锁对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">double</span> balance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(<span class="type">double</span> amount)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (balanceLock) &#123;  <span class="comment">// 而不是synchronized(this)</span></span><br><span class="line">            <span class="keyword">if</span> (balance &gt;= amount) &#123;</span><br><span class="line">                balance -= amount;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优先使用并发工具类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ✅ 推荐使用AtomicReference</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;Config&gt; config = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 而不是</span></span><br><span class="line"><span class="comment">// private volatile Config config;</span></span><br><span class="line"><span class="comment">// public synchronized void updateConfig(Config newConfig) &#123;...&#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="性能优化建议"><a href="#性能优化建议" class="headerlink" title="性能优化建议"></a>性能优化建议</h3><ol>
<li><p><strong>减少锁竞争</strong></p>
<ul>
<li>使用 ThreadLocal 避免共享</li>
<li>使用分段锁（如 ConcurrentHashMap）</li>
<li>使用无锁数据结构</li>
</ul>
</li>
<li><p><strong>合理使用 volatile</strong></p>
<ul>
<li>避免过度使用 volatile（每次访问都有内存屏障开销）</li>
<li>读多写少场景优先考虑 volatile</li>
</ul>
</li>
<li><p><strong>监控锁竞争情况</strong></p>
<ul>
<li>使用 JProfiler、VisualVM 等工具</li>
<li>关注线程 dump 中的 BLOCKED 状态</li>
</ul>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本文的深入分析，我们全面对比了<code>volatile</code>和<code>synchronized</code>两个关键字：</p>
<h3 id="🎯-核心要点回顾"><a href="#🎯-核心要点回顾" class="headerlink" title="🎯 核心要点回顾"></a>🎯 核心要点回顾</h3><ol>
<li><p><strong>功能定位不同</strong>：</p>
<ul>
<li><code>volatile</code>：轻量级同步，解决可见性和有序性</li>
<li><code>synchronized</code>：完整同步方案，解决原子性、可见性、有序性</li>
</ul>
</li>
<li><p><strong>适用场景不同</strong>：</p>
<ul>
<li><code>volatile</code>：状态标志、DCL、读多写少</li>
<li><code>synchronized</code>：复合操作、临界区保护、完整的同步需求</li>
</ul>
</li>
<li><p><strong>性能特征不同</strong>：</p>
<ul>
<li><code>volatile</code>：无锁，开销小但功能有限</li>
<li><code>synchronized</code>：有锁优化，功能全面但开销相对较大</li>
</ul>
</li>
</ol>
<h3 id="🚀-实际应用建议"><a href="#🚀-实际应用建议" class="headerlink" title="🚀 实际应用建议"></a>🚀 实际应用建议</h3><ol>
<li><p><strong>优先级顺序</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">并发工具类 &gt; synchronized &gt; volatile &gt; 无同步</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>选择决策树</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">需要原子性？</span><br><span class="line">├── 是 → 使用synchronized或Lock或Atomic类</span><br><span class="line">└── 否 → 需要可见性？</span><br><span class="line">    ├── 是 → 考虑volatile</span><br><span class="line">    └── 否 → 无需同步</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>性能测试验证</strong>：</p>
<ul>
<li>不要凭感觉选择，通过基准测试验证</li>
<li>关注实际的并发场景和数据量</li>
</ul>
</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%BA%BF%E7%A8%8B/" rel="tag"># 线程</a>
              <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="tag"># 并发编程</a>
              <a href="/tags/Java/" rel="tag"># Java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/05/19/Java-Threads/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-JMM/" rel="prev" title="Java 内存模型(JMM)">
      <i class="fa fa-chevron-left"></i> Java 内存模型(JMM)
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/05/23/Java-Threads/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%86-%E5%9F%BA%E7%A1%80%E7%AF%87/" rel="next" title="Java 并发编程面试题合集 - 基础篇">
      Java 并发编程面试题合集 - 基础篇 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Volatile-%E4%B8%8E-Synchronized-%E6%B7%B1%E5%BA%A6%E5%AF%B9%E6%AF%94"><span class="nav-number">1.</span> <span class="nav-text">Volatile 与 Synchronized 深度对比</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="nav-number">1.1.</span> <span class="nav-text">写在前面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%B7%B1%E5%85%A5%E5%AF%B9%E6%AF%94%E8%BF%99%E4%B8%A4%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9F"><span class="nav-number">1.2.</span> <span class="nav-text">为什么要深入对比这两个关键字？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile-%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.3.</span> <span class="nav-text">volatile 关键字原理与应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%90%86%E6%A0%B8%E5%BF%83-%E5%9F%BA%E4%BA%8E-JMM"><span class="nav-number">1.3.1.</span> <span class="nav-text">原理核心 (基于 JMM):</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.3.2.</span> <span class="nav-text">应用场景:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized-%E5%85%B3%E9%94%AE%E5%AD%97%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%BA%94%E7%94%A8"><span class="nav-number">1.4.</span> <span class="nav-text">synchronized 关键字实现机制与应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized-%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E4%B8%8E%E9%94%81%E5%AE%9A%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.4.1.</span> <span class="nav-text">synchronized 的基本用法与锁定对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized-%E7%9A%84%E6%A0%B8%E5%BF%83%E4%BD%9C%E7%94%A8"><span class="nav-number">1.4.2.</span> <span class="nav-text">synchronized 的核心作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized-%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-%E5%9F%BA%E4%BA%8E%E5%AF%B9%E8%B1%A1%E7%9B%91%E8%A7%86%E5%99%A8-Monitor"><span class="nav-number">1.4.3.</span> <span class="nav-text">synchronized 的底层原理 (基于对象监视器 Monitor)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96%E4%B8%8E%E5%8D%87%E7%BA%A7-HotSpot-JVM"><span class="nav-number">1.4.4.</span> <span class="nav-text">锁的优化与升级 (HotSpot JVM)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized-%E7%9A%84%E5%8F%AF%E9%87%8D%E5%85%A5%E6%80%A7"><span class="nav-number">1.4.5.</span> <span class="nav-text">synchronized 的可重入性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#this%E5%BC%95%E7%94%A8%E9%80%B8%E5%87%BA"><span class="nav-number">1.4.6.</span> <span class="nav-text">this引用逸出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object%E7%9A%84wait-notify-notifyAll-%E5%9B%9E%E9%A1%BE%EF%BC%8C%E4%B8%8Esynchronized%E5%BC%BA%E5%85%B3%E8%81%94"><span class="nav-number">1.4.7.</span> <span class="nav-text">Object的wait(), notify(), notifyAll() (回顾，与synchronized强关联)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%A4%E8%80%85%E5%9C%A8%E5%8F%AF%E8%A7%81%E6%80%A7%E3%80%81%E5%8E%9F%E5%AD%90%E6%80%A7%E3%80%81%E6%9C%89%E5%BA%8F%E6%80%A7%E4%B8%8A%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="nav-number">1.5.</span> <span class="nav-text">两者在可见性、原子性、有序性上的差异</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94%E4%B8%8E%E9%80%89%E6%8B%A9%E6%8C%87%E5%8D%97"><span class="nav-number">1.6.</span> <span class="nav-text">性能对比与选择指南</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%99%85%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E5%AF%B9%E6%AF%94"><span class="nav-number">1.7.</span> <span class="nav-text">实际代码示例对比</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1%EF%BC%9A%E8%AE%A1%E6%95%B0%E5%99%A8%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.7.1.</span> <span class="nav-text">示例 1：计数器实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">1.7.2.</span> <span class="nav-text">示例 2：单例模式中的应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-3%EF%BC%9A%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.7.3.</span> <span class="nav-text">示例 3：生产者-消费者模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93"><span class="nav-number">1.8.</span> <span class="nav-text">面试高频问题总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%AD%90%E2%AD%90%E2%AD%90-%E8%B6%85%E9%AB%98%E9%A2%91%E9%97%AE%E9%A2%98"><span class="nav-number">1.8.1.</span> <span class="nav-text">⭐⭐⭐ 超高频问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%AD%90%E2%AD%90-%E9%AB%98%E9%A2%91%E9%97%AE%E9%A2%98"><span class="nav-number">1.8.2.</span> <span class="nav-text">⭐⭐ 高频问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%AD%90-%E8%BF%9B%E9%98%B6%E9%97%AE%E9%A2%98"><span class="nav-number">1.8.3.</span> <span class="nav-text">⭐ 进阶问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97"><span class="nav-number">1.9.</span> <span class="nav-text">最佳实践指南</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-number">1.9.1.</span> <span class="nav-text">设计原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE"><span class="nav-number">1.9.2.</span> <span class="nav-text">性能优化建议</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.10.</span> <span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%F0%9F%8E%AF-%E6%A0%B8%E5%BF%83%E8%A6%81%E7%82%B9%E5%9B%9E%E9%A1%BE"><span class="nav-number">1.10.1.</span> <span class="nav-text">🎯 核心要点回顾</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%F0%9F%9A%80-%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%BB%BA%E8%AE%AE"><span class="nav-number">1.10.2.</span> <span class="nav-text">🚀 实际应用建议</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">makotogu</p>
  <div class="site-description" itemprop="description">Java|数据库|分布式|架构<br>分享我的学习之路</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/makotogu?tab" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;makotogu?tab" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:jianwangp@icloud.com" title="E-Mail → mailto:jianwangp@icloud.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">makotogu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

</body>
</html>
